// WARNING: This file has automatically been generated
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package generated

/*
#cgo LDFLAGS: -L${SRCDIR}/..
#cgo pkg-config: ${SRCDIR}/../filcrypto.pc
#include "../filcrypto.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"runtime"
	"unsafe"
)

// _GO__ function as declared in filecoin-ffi/<predefine>:36
func _GO__(arg0 []byte) {
	carg0, carg0AllocMap := copyPCharBytes((*sliceHeader)(unsafe.Pointer(&arg0)))
	C.__GO__(carg0)
	runtime.KeepAlive(carg0AllocMap)
}

// DestroyGpuDeviceResponse function as declared in filecoin-ffi/filcrypto.h:91
func DestroyGpuDeviceResponse(ptr []ResultArraySliceBoxedUint8T) {
	cptr, cptrAllocMap := unpackArgSResultArraySliceBoxedUint8T(ptr)
	C.destroy_gpu_device_response(cptr)
	packSResultArraySliceBoxedUint8T(ptr, cptr)
	runtime.KeepAlive(cptrAllocMap)
}

// DestroyInitLogFdResponse function as declared in filecoin-ffi/filcrypto.h:102
func DestroyInitLogFdResponse(ptr []ResultVoidT) {
	cptr, cptrAllocMap := unpackArgSResultVoidT(ptr)
	C.destroy_init_log_fd_response(cptr)
	packSResultVoidT(ptr, cptr)
	runtime.KeepAlive(cptrAllocMap)
}

// Hash function as declared in filecoin-ffi/filcrypto.h:156
func Hash(message SliceRefUint8T) *HashResponseT {
	cmessage, cmessageAllocMap := message.PassValue()
	__ret := C.hash(cmessage)
	runtime.KeepAlive(cmessageAllocMap)
	__v := NewHashResponseTRef(unsafe.Pointer(__ret))
	return __v
}

// Aggregate function as declared in filecoin-ffi/filcrypto.h:183
func Aggregate(flattenedSignatures SliceRefUint8T) *AggregateResponseT {
	cflattenedSignatures, cflattenedSignaturesAllocMap := flattenedSignatures.PassValue()
	__ret := C.aggregate(cflattenedSignatures)
	runtime.KeepAlive(cflattenedSignaturesAllocMap)
	__v := NewAggregateResponseTRef(unsafe.Pointer(__ret))
	return __v
}

// Verify function as declared in filecoin-ffi/filcrypto.h:195
func Verify(signature []Uint896ArrayT, flattenedDigests SliceRefUint8T, flattenedPublicKeys SliceRefUint8T) Int32T {
	csignature, csignatureAllocMap := unpackArgSUint896ArrayT(signature)
	cflattenedDigests, cflattenedDigestsAllocMap := flattenedDigests.PassValue()
	cflattenedPublicKeys, cflattenedPublicKeysAllocMap := flattenedPublicKeys.PassValue()
	__ret := C.verify(csignature, cflattenedDigests, cflattenedPublicKeys)
	runtime.KeepAlive(cflattenedPublicKeysAllocMap)
	runtime.KeepAlive(cflattenedDigestsAllocMap)
	packSUint896ArrayT(signature, csignature)
	runtime.KeepAlive(csignatureAllocMap)
	__v := (Int32T)(__ret)
	return __v
}

// HashVerify function as declared in filecoin-ffi/filcrypto.h:223
func HashVerify(signature []Uint896ArrayT, flattenedMessages SliceRefUint8T, messageSizes []ArraySizeT, flattenedPublicKeys SliceRefUint8T) Int32T {
	csignature, csignatureAllocMap := unpackArgSUint896ArrayT(signature)
	cflattenedMessages, cflattenedMessagesAllocMap := flattenedMessages.PassValue()
	cmessageSizes, cmessageSizesAllocMap := unpackArgSArraySizeT(messageSizes)
	cflattenedPublicKeys, cflattenedPublicKeysAllocMap := flattenedPublicKeys.PassValue()
	__ret := C.hash_verify(csignature, cflattenedMessages, cmessageSizes, cflattenedPublicKeys)
	runtime.KeepAlive(cflattenedPublicKeysAllocMap)
	packSArraySizeT(messageSizes, cmessageSizes)
	runtime.KeepAlive(cmessageSizesAllocMap)
	runtime.KeepAlive(cflattenedMessagesAllocMap)
	packSUint896ArrayT(signature, csignature)
	runtime.KeepAlive(csignatureAllocMap)
	__v := (Int32T)(__ret)
	return __v
}

// PrivateKeyGenerate function as declared in filecoin-ffi/filcrypto.h:249
func PrivateKeyGenerate() *PrivateKeyGenerateResponseT {
	__ret := C.private_key_generate()
	__v := NewPrivateKeyGenerateResponseTRef(unsafe.Pointer(__ret))
	return __v
}

// PrivateKeyGenerateWithSeed function as declared in filecoin-ffi/filcrypto.h:268
func PrivateKeyGenerateWithSeed(rawSeed ByteArray32T) *PrivateKeyGenerateResponseT {
	crawSeed, crawSeedAllocMap := rawSeed.PassValue()
	__ret := C.private_key_generate_with_seed(crawSeed)
	runtime.KeepAlive(crawSeedAllocMap)
	__v := NewPrivateKeyGenerateResponseTRef(unsafe.Pointer(__ret))
	return __v
}

// PrivateKeySign function as declared in filecoin-ffi/filcrypto.h:290
func PrivateKeySign(rawPrivateKey []Uint832ArrayT, message SliceRefUint8T) *PrivateKeySignResponseT {
	crawPrivateKey, crawPrivateKeyAllocMap := unpackArgSUint832ArrayT(rawPrivateKey)
	cmessage, cmessageAllocMap := message.PassValue()
	__ret := C.private_key_sign(crawPrivateKey, cmessage)
	runtime.KeepAlive(cmessageAllocMap)
	packSUint832ArrayT(rawPrivateKey, crawPrivateKey)
	runtime.KeepAlive(crawPrivateKeyAllocMap)
	__v := NewPrivateKeySignResponseTRef(unsafe.Pointer(__ret))
	return __v
}

// PrivateKeyPublicKey function as declared in filecoin-ffi/filcrypto.h:320
func PrivateKeyPublicKey(rawPrivateKey []Uint832ArrayT) *PrivateKeyPublicKeyResponseT {
	crawPrivateKey, crawPrivateKeyAllocMap := unpackArgSUint832ArrayT(rawPrivateKey)
	__ret := C.private_key_public_key(crawPrivateKey)
	packSUint832ArrayT(rawPrivateKey, crawPrivateKey)
	runtime.KeepAlive(crawPrivateKeyAllocMap)
	__v := NewPrivateKeyPublicKeyResponseTRef(unsafe.Pointer(__ret))
	return __v
}

// CreateZeroSignature function as declared in filecoin-ffi/filcrypto.h:337
func CreateZeroSignature() *ZeroSignatureResponseT {
	__ret := C.create_zero_signature()
	__v := NewZeroSignatureResponseTRef(unsafe.Pointer(__ret))
	return __v
}

// DropSignature function as declared in filecoin-ffi/filcrypto.h:342
func DropSignature(sig []ZeroSignatureResponseT) {
	csig, csigAllocMap := unpackArgSZeroSignatureResponseT(sig)
	C.drop_signature(csig)
	packSZeroSignatureResponseT(sig, csig)
	runtime.KeepAlive(csigAllocMap)
}

// GetGpuDevices function as declared in filecoin-ffi/filcrypto.h:348
func GetGpuDevices() *ResultArraySliceBoxedUint8T {
	__ret := C.get_gpu_devices()
	__v := NewResultArraySliceBoxedUint8TRef(unsafe.Pointer(__ret))
	return __v
}

// InitLogFd function as declared in filecoin-ffi/filcrypto.h:359
func InitLogFd(logFd Int32T) *ResultVoidT {
	clogFd, clogFdAllocMap := (C.int32_t)(logFd), cgoAllocsUnknown
	__ret := C.init_log_fd(clogFd)
	runtime.KeepAlive(clogFdAllocMap)
	__v := NewResultVoidTRef(unsafe.Pointer(__ret))
	return __v
}

// WriteWithAlignment function as declared in filecoin-ffi/filcrypto.h:445
func WriteWithAlignment(registeredProof RegisteredSealProofT, srcFd Int32T, srcSize Uint64T, dstFd Int32T, existingPieceSizes SliceRefUint64T) *ResultWriteWithAlignmentT {
	cregisteredProof, cregisteredProofAllocMap := (C.RegisteredSealProof_t)(registeredProof), cgoAllocsUnknown
	csrcFd, csrcFdAllocMap := (C.int32_t)(srcFd), cgoAllocsUnknown
	csrcSize, csrcSizeAllocMap := (C.uint64_t)(srcSize), cgoAllocsUnknown
	cdstFd, cdstFdAllocMap := (C.int32_t)(dstFd), cgoAllocsUnknown
	cexistingPieceSizes, cexistingPieceSizesAllocMap := existingPieceSizes.PassValue()
	__ret := C.write_with_alignment(cregisteredProof, csrcFd, csrcSize, cdstFd, cexistingPieceSizes)
	runtime.KeepAlive(cexistingPieceSizesAllocMap)
	runtime.KeepAlive(cdstFdAllocMap)
	runtime.KeepAlive(csrcSizeAllocMap)
	runtime.KeepAlive(csrcFdAllocMap)
	runtime.KeepAlive(cregisteredProofAllocMap)
	__v := NewResultWriteWithAlignmentTRef(unsafe.Pointer(__ret))
	return __v
}

// WriteWithoutAlignment function as declared in filecoin-ffi/filcrypto.h:473
func WriteWithoutAlignment(registeredProof RegisteredSealProofT, srcFd Int32T, srcSize Uint64T, dstFd Int32T) *ResultWriteWithoutAlignmentT {
	cregisteredProof, cregisteredProofAllocMap := (C.RegisteredSealProof_t)(registeredProof), cgoAllocsUnknown
	csrcFd, csrcFdAllocMap := (C.int32_t)(srcFd), cgoAllocsUnknown
	csrcSize, csrcSizeAllocMap := (C.uint64_t)(srcSize), cgoAllocsUnknown
	cdstFd, cdstFdAllocMap := (C.int32_t)(dstFd), cgoAllocsUnknown
	__ret := C.write_without_alignment(cregisteredProof, csrcFd, csrcSize, cdstFd)
	runtime.KeepAlive(cdstFdAllocMap)
	runtime.KeepAlive(csrcSizeAllocMap)
	runtime.KeepAlive(csrcFdAllocMap)
	runtime.KeepAlive(cregisteredProofAllocMap)
	__v := NewResultWriteWithoutAlignmentTRef(unsafe.Pointer(__ret))
	return __v
}

// Fauxrep function as declared in filecoin-ffi/filcrypto.h:489
func Fauxrep(registeredProof RegisteredSealProofT, cacheDirPath SliceRefUint8T, sealedSectorPath SliceRefUint8T) *ResultByteArray32T {
	cregisteredProof, cregisteredProofAllocMap := (C.RegisteredSealProof_t)(registeredProof), cgoAllocsUnknown
	ccacheDirPath, ccacheDirPathAllocMap := cacheDirPath.PassValue()
	csealedSectorPath, csealedSectorPathAllocMap := sealedSectorPath.PassValue()
	__ret := C.fauxrep(cregisteredProof, ccacheDirPath, csealedSectorPath)
	runtime.KeepAlive(csealedSectorPathAllocMap)
	runtime.KeepAlive(ccacheDirPathAllocMap)
	runtime.KeepAlive(cregisteredProofAllocMap)
	__v := NewResultByteArray32TRef(unsafe.Pointer(__ret))
	return __v
}

// Fauxrep2 function as declared in filecoin-ffi/filcrypto.h:494
func Fauxrep2(registeredProof RegisteredSealProofT, cacheDirPath SliceRefUint8T, existingPAuxPath SliceRefUint8T) *ResultByteArray32T {
	cregisteredProof, cregisteredProofAllocMap := (C.RegisteredSealProof_t)(registeredProof), cgoAllocsUnknown
	ccacheDirPath, ccacheDirPathAllocMap := cacheDirPath.PassValue()
	cexistingPAuxPath, cexistingPAuxPathAllocMap := existingPAuxPath.PassValue()
	__ret := C.fauxrep2(cregisteredProof, ccacheDirPath, cexistingPAuxPath)
	runtime.KeepAlive(cexistingPAuxPathAllocMap)
	runtime.KeepAlive(ccacheDirPathAllocMap)
	runtime.KeepAlive(cregisteredProofAllocMap)
	__v := NewResultByteArray32TRef(unsafe.Pointer(__ret))
	return __v
}

// SealPreCommitPhase1 function as declared in filecoin-ffi/filcrypto.h:531
func SealPreCommitPhase1(registeredProof RegisteredSealProofT, cacheDirPath SliceRefUint8T, stagedSectorPath SliceRefUint8T, sealedSectorPath SliceRefUint8T, sectorId Uint64T, proverId ByteArray32T, ticket ByteArray32T, pieces []ArrayPublicPieceInfoT) *ResultSliceBoxedUint8T {
	cregisteredProof, cregisteredProofAllocMap := (C.RegisteredSealProof_t)(registeredProof), cgoAllocsUnknown
	ccacheDirPath, ccacheDirPathAllocMap := cacheDirPath.PassValue()
	cstagedSectorPath, cstagedSectorPathAllocMap := stagedSectorPath.PassValue()
	csealedSectorPath, csealedSectorPathAllocMap := sealedSectorPath.PassValue()
	csectorId, csectorIdAllocMap := (C.uint64_t)(sectorId), cgoAllocsUnknown
	cproverId, cproverIdAllocMap := proverId.PassValue()
	cticket, cticketAllocMap := ticket.PassValue()
	cpieces, cpiecesAllocMap := unpackArgSArrayPublicPieceInfoT(pieces)
	__ret := C.seal_pre_commit_phase1(cregisteredProof, ccacheDirPath, cstagedSectorPath, csealedSectorPath, csectorId, cproverId, cticket, cpieces)
	packSArrayPublicPieceInfoT(pieces, cpieces)
	runtime.KeepAlive(cpiecesAllocMap)
	runtime.KeepAlive(cticketAllocMap)
	runtime.KeepAlive(cproverIdAllocMap)
	runtime.KeepAlive(csectorIdAllocMap)
	runtime.KeepAlive(csealedSectorPathAllocMap)
	runtime.KeepAlive(cstagedSectorPathAllocMap)
	runtime.KeepAlive(ccacheDirPathAllocMap)
	runtime.KeepAlive(cregisteredProofAllocMap)
	__v := NewResultSliceBoxedUint8TRef(unsafe.Pointer(__ret))
	return __v
}

// SealPreCommitPhase2 function as declared in filecoin-ffi/filcrypto.h:564
func SealPreCommitPhase2(sealPreCommitPhase1Output SliceRefUint8T, cacheDirPath SliceRefUint8T, sealedSectorPath SliceRefUint8T) *ResultSealPreCommitPhase2T {
	csealPreCommitPhase1Output, csealPreCommitPhase1OutputAllocMap := sealPreCommitPhase1Output.PassValue()
	ccacheDirPath, ccacheDirPathAllocMap := cacheDirPath.PassValue()
	csealedSectorPath, csealedSectorPathAllocMap := sealedSectorPath.PassValue()
	__ret := C.seal_pre_commit_phase2(csealPreCommitPhase1Output, ccacheDirPath, csealedSectorPath)
	runtime.KeepAlive(csealedSectorPathAllocMap)
	runtime.KeepAlive(ccacheDirPathAllocMap)
	runtime.KeepAlive(csealPreCommitPhase1OutputAllocMap)
	__v := NewResultSealPreCommitPhase2TRef(unsafe.Pointer(__ret))
	return __v
}

// SealCommitPhase1 function as declared in filecoin-ffi/filcrypto.h:572
func SealCommitPhase1(registeredProof RegisteredSealProofT, commR ByteArray32T, commD ByteArray32T, cacheDirPath SliceRefUint8T, replicaPath SliceRefUint8T, sectorId Uint64T, proverId ByteArray32T, ticket ByteArray32T, seed ByteArray32T, pieces []ArrayPublicPieceInfoT) *ResultSliceBoxedUint8T {
	cregisteredProof, cregisteredProofAllocMap := (C.RegisteredSealProof_t)(registeredProof), cgoAllocsUnknown
	ccommR, ccommRAllocMap := commR.PassValue()
	ccommD, ccommDAllocMap := commD.PassValue()
	ccacheDirPath, ccacheDirPathAllocMap := cacheDirPath.PassValue()
	creplicaPath, creplicaPathAllocMap := replicaPath.PassValue()
	csectorId, csectorIdAllocMap := (C.uint64_t)(sectorId), cgoAllocsUnknown
	cproverId, cproverIdAllocMap := proverId.PassValue()
	cticket, cticketAllocMap := ticket.PassValue()
	cseed, cseedAllocMap := seed.PassValue()
	cpieces, cpiecesAllocMap := unpackArgSArrayPublicPieceInfoT(pieces)
	__ret := C.seal_commit_phase1(cregisteredProof, ccommR, ccommD, ccacheDirPath, creplicaPath, csectorId, cproverId, cticket, cseed, cpieces)
	packSArrayPublicPieceInfoT(pieces, cpieces)
	runtime.KeepAlive(cpiecesAllocMap)
	runtime.KeepAlive(cseedAllocMap)
	runtime.KeepAlive(cticketAllocMap)
	runtime.KeepAlive(cproverIdAllocMap)
	runtime.KeepAlive(csectorIdAllocMap)
	runtime.KeepAlive(creplicaPathAllocMap)
	runtime.KeepAlive(ccacheDirPathAllocMap)
	runtime.KeepAlive(ccommDAllocMap)
	runtime.KeepAlive(ccommRAllocMap)
	runtime.KeepAlive(cregisteredProofAllocMap)
	__v := NewResultSliceBoxedUint8TRef(unsafe.Pointer(__ret))
	return __v
}

// SealCommitPhase2 function as declared in filecoin-ffi/filcrypto.h:600
func SealCommitPhase2(sealCommitPhase1Output SliceRefUint8T, sectorId Uint64T, proverId ByteArray32T) *ResultSealCommitPhase2T {
	csealCommitPhase1Output, csealCommitPhase1OutputAllocMap := sealCommitPhase1Output.PassValue()
	csectorId, csectorIdAllocMap := (C.uint64_t)(sectorId), cgoAllocsUnknown
	cproverId, cproverIdAllocMap := proverId.PassValue()
	__ret := C.seal_commit_phase2(csealCommitPhase1Output, csectorId, cproverId)
	runtime.KeepAlive(cproverIdAllocMap)
	runtime.KeepAlive(csectorIdAllocMap)
	runtime.KeepAlive(csealCommitPhase1OutputAllocMap)
	__v := NewResultSealCommitPhase2TRef(unsafe.Pointer(__ret))
	return __v
}

// AggregateSealProofs function as declared in filecoin-ffi/filcrypto.h:642
func AggregateSealProofs(registeredProof RegisteredSealProofT, registeredAggregation RegisteredAggregationProofT, commRs ArrayByteArray32T, seeds ArrayByteArray32T, sealCommitResponses []ArraySealCommitPhase2T) *ResultSliceBoxedUint8T {
	cregisteredProof, cregisteredProofAllocMap := (C.RegisteredSealProof_t)(registeredProof), cgoAllocsUnknown
	cregisteredAggregation, cregisteredAggregationAllocMap := (C.RegisteredAggregationProof_t)(registeredAggregation), cgoAllocsUnknown
	ccommRs, ccommRsAllocMap := commRs.PassValue()
	cseeds, cseedsAllocMap := seeds.PassValue()
	csealCommitResponses, csealCommitResponsesAllocMap := unpackArgSArraySealCommitPhase2T(sealCommitResponses)
	__ret := C.aggregate_seal_proofs(cregisteredProof, cregisteredAggregation, ccommRs, cseeds, csealCommitResponses)
	packSArraySealCommitPhase2T(sealCommitResponses, csealCommitResponses)
	runtime.KeepAlive(csealCommitResponsesAllocMap)
	runtime.KeepAlive(cseedsAllocMap)
	runtime.KeepAlive(ccommRsAllocMap)
	runtime.KeepAlive(cregisteredAggregationAllocMap)
	runtime.KeepAlive(cregisteredProofAllocMap)
	__v := NewResultSliceBoxedUint8TRef(unsafe.Pointer(__ret))
	return __v
}

// VerifyAggregateSealProof function as declared in filecoin-ffi/filcrypto.h:690
func VerifyAggregateSealProof(registeredProof RegisteredSealProofT, registeredAggregation RegisteredAggregationProofT, proverId ByteArray32T, proof SliceRefUint8T, commitInputs []ArrayAggregationInputsT) *ResultBoolT {
	cregisteredProof, cregisteredProofAllocMap := (C.RegisteredSealProof_t)(registeredProof), cgoAllocsUnknown
	cregisteredAggregation, cregisteredAggregationAllocMap := (C.RegisteredAggregationProof_t)(registeredAggregation), cgoAllocsUnknown
	cproverId, cproverIdAllocMap := proverId.PassValue()
	cproof, cproofAllocMap := proof.PassValue()
	ccommitInputs, ccommitInputsAllocMap := unpackArgSArrayAggregationInputsT(commitInputs)
	__ret := C.verify_aggregate_seal_proof(cregisteredProof, cregisteredAggregation, cproverId, cproof, ccommitInputs)
	packSArrayAggregationInputsT(commitInputs, ccommitInputs)
	runtime.KeepAlive(ccommitInputsAllocMap)
	runtime.KeepAlive(cproofAllocMap)
	runtime.KeepAlive(cproverIdAllocMap)
	runtime.KeepAlive(cregisteredAggregationAllocMap)
	runtime.KeepAlive(cregisteredProofAllocMap)
	__v := NewResultBoolTRef(unsafe.Pointer(__ret))
	return __v
}

// UnsealRange function as declared in filecoin-ffi/filcrypto.h:700
func UnsealRange(registeredProof RegisteredSealProofT, cacheDirPath SliceRefUint8T, sealedSectorFdRaw Int32T, unsealOutputFdRaw Int32T, sectorId Uint64T, proverId ByteArray32T, ticket ByteArray32T, commD ByteArray32T, unpaddedByteIndex Uint64T, unpaddedBytesAmount Uint64T) *ResultVoidT {
	cregisteredProof, cregisteredProofAllocMap := (C.RegisteredSealProof_t)(registeredProof), cgoAllocsUnknown
	ccacheDirPath, ccacheDirPathAllocMap := cacheDirPath.PassValue()
	csealedSectorFdRaw, csealedSectorFdRawAllocMap := (C.int32_t)(sealedSectorFdRaw), cgoAllocsUnknown
	cunsealOutputFdRaw, cunsealOutputFdRawAllocMap := (C.int32_t)(unsealOutputFdRaw), cgoAllocsUnknown
	csectorId, csectorIdAllocMap := (C.uint64_t)(sectorId), cgoAllocsUnknown
	cproverId, cproverIdAllocMap := proverId.PassValue()
	cticket, cticketAllocMap := ticket.PassValue()
	ccommD, ccommDAllocMap := commD.PassValue()
	cunpaddedByteIndex, cunpaddedByteIndexAllocMap := (C.uint64_t)(unpaddedByteIndex), cgoAllocsUnknown
	cunpaddedBytesAmount, cunpaddedBytesAmountAllocMap := (C.uint64_t)(unpaddedBytesAmount), cgoAllocsUnknown
	__ret := C.unseal_range(cregisteredProof, ccacheDirPath, csealedSectorFdRaw, cunsealOutputFdRaw, csectorId, cproverId, cticket, ccommD, cunpaddedByteIndex, cunpaddedBytesAmount)
	runtime.KeepAlive(cunpaddedBytesAmountAllocMap)
	runtime.KeepAlive(cunpaddedByteIndexAllocMap)
	runtime.KeepAlive(ccommDAllocMap)
	runtime.KeepAlive(cticketAllocMap)
	runtime.KeepAlive(cproverIdAllocMap)
	runtime.KeepAlive(csectorIdAllocMap)
	runtime.KeepAlive(cunsealOutputFdRawAllocMap)
	runtime.KeepAlive(csealedSectorFdRawAllocMap)
	runtime.KeepAlive(ccacheDirPathAllocMap)
	runtime.KeepAlive(cregisteredProofAllocMap)
	__v := NewResultVoidTRef(unsafe.Pointer(__ret))
	return __v
}

// VerifySeal function as declared in filecoin-ffi/filcrypto.h:715
func VerifySeal(registeredProof RegisteredSealProofT, commR ByteArray32T, commD ByteArray32T, proverId ByteArray32T, ticket ByteArray32T, seed ByteArray32T, sectorId Uint64T, proof SliceRefUint8T) *ResultBoolT {
	cregisteredProof, cregisteredProofAllocMap := (C.RegisteredSealProof_t)(registeredProof), cgoAllocsUnknown
	ccommR, ccommRAllocMap := commR.PassValue()
	ccommD, ccommDAllocMap := commD.PassValue()
	cproverId, cproverIdAllocMap := proverId.PassValue()
	cticket, cticketAllocMap := ticket.PassValue()
	cseed, cseedAllocMap := seed.PassValue()
	csectorId, csectorIdAllocMap := (C.uint64_t)(sectorId), cgoAllocsUnknown
	cproof, cproofAllocMap := proof.PassValue()
	__ret := C.verify_seal(cregisteredProof, ccommR, ccommD, cproverId, cticket, cseed, csectorId, cproof)
	runtime.KeepAlive(cproofAllocMap)
	runtime.KeepAlive(csectorIdAllocMap)
	runtime.KeepAlive(cseedAllocMap)
	runtime.KeepAlive(cticketAllocMap)
	runtime.KeepAlive(cproverIdAllocMap)
	runtime.KeepAlive(ccommDAllocMap)
	runtime.KeepAlive(ccommRAllocMap)
	runtime.KeepAlive(cregisteredProofAllocMap)
	__v := NewResultBoolTRef(unsafe.Pointer(__ret))
	return __v
}

// GenerateWinningPostSectorChallenge function as declared in filecoin-ffi/filcrypto.h:782
func GenerateWinningPostSectorChallenge(registeredProof RegisteredPoStProofT, randomness ByteArray32T, sectorSetLen Uint64T, proverId ByteArray32T) *ResultArrayUint64T {
	cregisteredProof, cregisteredProofAllocMap := (C.RegisteredPoStProof_t)(registeredProof), cgoAllocsUnknown
	crandomness, crandomnessAllocMap := randomness.PassValue()
	csectorSetLen, csectorSetLenAllocMap := (C.uint64_t)(sectorSetLen), cgoAllocsUnknown
	cproverId, cproverIdAllocMap := proverId.PassValue()
	__ret := C.generate_winning_post_sector_challenge(cregisteredProof, crandomness, csectorSetLen, cproverId)
	runtime.KeepAlive(cproverIdAllocMap)
	runtime.KeepAlive(csectorSetLenAllocMap)
	runtime.KeepAlive(crandomnessAllocMap)
	runtime.KeepAlive(cregisteredProofAllocMap)
	__v := NewResultArrayUint64TRef(unsafe.Pointer(__ret))
	return __v
}

// GenerateFallbackSectorChallenges function as declared in filecoin-ffi/filcrypto.h:811
func GenerateFallbackSectorChallenges(registeredProof RegisteredPoStProofT, randomness ByteArray32T, sectorIds []ArrayUint64T, proverId ByteArray32T) *ResultGenerateFallbackSectorChallengesT {
	cregisteredProof, cregisteredProofAllocMap := (C.RegisteredPoStProof_t)(registeredProof), cgoAllocsUnknown
	crandomness, crandomnessAllocMap := randomness.PassValue()
	csectorIds, csectorIdsAllocMap := unpackArgSArrayUint64T(sectorIds)
	cproverId, cproverIdAllocMap := proverId.PassValue()
	__ret := C.generate_fallback_sector_challenges(cregisteredProof, crandomness, csectorIds, cproverId)
	runtime.KeepAlive(cproverIdAllocMap)
	packSArrayUint64T(sectorIds, csectorIds)
	runtime.KeepAlive(csectorIdsAllocMap)
	runtime.KeepAlive(crandomnessAllocMap)
	runtime.KeepAlive(cregisteredProofAllocMap)
	__v := NewResultGenerateFallbackSectorChallengesTRef(unsafe.Pointer(__ret))
	return __v
}

// GenerateSingleVanillaProof function as declared in filecoin-ffi/filcrypto.h:834
func GenerateSingleVanillaProof(replica PrivateReplicaInfoT, challenges []ArrayUint64T) *ResultSliceBoxedUint8T {
	creplica, creplicaAllocMap := replica.PassValue()
	cchallenges, cchallengesAllocMap := unpackArgSArrayUint64T(challenges)
	__ret := C.generate_single_vanilla_proof(creplica, cchallenges)
	packSArrayUint64T(challenges, cchallenges)
	runtime.KeepAlive(cchallengesAllocMap)
	runtime.KeepAlive(creplicaAllocMap)
	__v := NewResultSliceBoxedUint8TRef(unsafe.Pointer(__ret))
	return __v
}

// GenerateWinningPostWithVanilla function as declared in filecoin-ffi/filcrypto.h:870
func GenerateWinningPostWithVanilla(registeredProof RegisteredPoStProofT, randomness ByteArray32T, proverId ByteArray32T, vanillaProofs []ArraySliceBoxedUint8T) *ResultArrayPoStProofT {
	cregisteredProof, cregisteredProofAllocMap := (C.RegisteredPoStProof_t)(registeredProof), cgoAllocsUnknown
	crandomness, crandomnessAllocMap := randomness.PassValue()
	cproverId, cproverIdAllocMap := proverId.PassValue()
	cvanillaProofs, cvanillaProofsAllocMap := unpackArgSArraySliceBoxedUint8T(vanillaProofs)
	__ret := C.generate_winning_post_with_vanilla(cregisteredProof, crandomness, cproverId, cvanillaProofs)
	packSArraySliceBoxedUint8T(vanillaProofs, cvanillaProofs)
	runtime.KeepAlive(cvanillaProofsAllocMap)
	runtime.KeepAlive(cproverIdAllocMap)
	runtime.KeepAlive(crandomnessAllocMap)
	runtime.KeepAlive(cregisteredProofAllocMap)
	__v := NewResultArrayPoStProofTRef(unsafe.Pointer(__ret))
	return __v
}

// GenerateWinningPost function as declared in filecoin-ffi/filcrypto.h:890
func GenerateWinningPost(randomness ByteArray32T, replicas []ArrayPrivateReplicaInfoT, proverId ByteArray32T) *ResultArrayPoStProofT {
	crandomness, crandomnessAllocMap := randomness.PassValue()
	creplicas, creplicasAllocMap := unpackArgSArrayPrivateReplicaInfoT(replicas)
	cproverId, cproverIdAllocMap := proverId.PassValue()
	__ret := C.generate_winning_post(crandomness, creplicas, cproverId)
	runtime.KeepAlive(cproverIdAllocMap)
	packSArrayPrivateReplicaInfoT(replicas, creplicas)
	runtime.KeepAlive(creplicasAllocMap)
	runtime.KeepAlive(crandomnessAllocMap)
	__v := NewResultArrayPoStProofTRef(unsafe.Pointer(__ret))
	return __v
}

// VerifyWinningPost function as declared in filecoin-ffi/filcrypto.h:919
func VerifyWinningPost(randomness ByteArray32T, replicas []ArrayPublicReplicaInfoT, proofs []ArrayPoStProofT, proverId ByteArray32T) *ResultBoolT {
	crandomness, crandomnessAllocMap := randomness.PassValue()
	creplicas, creplicasAllocMap := unpackArgSArrayPublicReplicaInfoT(replicas)
	cproofs, cproofsAllocMap := unpackArgSArrayPoStProofT(proofs)
	cproverId, cproverIdAllocMap := proverId.PassValue()
	__ret := C.verify_winning_post(crandomness, creplicas, cproofs, cproverId)
	runtime.KeepAlive(cproverIdAllocMap)
	packSArrayPoStProofT(proofs, cproofs)
	runtime.KeepAlive(cproofsAllocMap)
	packSArrayPublicReplicaInfoT(replicas, creplicas)
	runtime.KeepAlive(creplicasAllocMap)
	runtime.KeepAlive(crandomnessAllocMap)
	__v := NewResultBoolTRef(unsafe.Pointer(__ret))
	return __v
}

// GenerateWindowPostWithVanilla function as declared in filecoin-ffi/filcrypto.h:946
func GenerateWindowPostWithVanilla(registeredProof RegisteredPoStProofT, randomness ByteArray32T, proverId ByteArray32T, vanillaProofs []ArraySliceBoxedUint8T) *ResultGenerateWindowPoStT {
	cregisteredProof, cregisteredProofAllocMap := (C.RegisteredPoStProof_t)(registeredProof), cgoAllocsUnknown
	crandomness, crandomnessAllocMap := randomness.PassValue()
	cproverId, cproverIdAllocMap := proverId.PassValue()
	cvanillaProofs, cvanillaProofsAllocMap := unpackArgSArraySliceBoxedUint8T(vanillaProofs)
	__ret := C.generate_window_post_with_vanilla(cregisteredProof, crandomness, cproverId, cvanillaProofs)
	packSArraySliceBoxedUint8T(vanillaProofs, cvanillaProofs)
	runtime.KeepAlive(cvanillaProofsAllocMap)
	runtime.KeepAlive(cproverIdAllocMap)
	runtime.KeepAlive(crandomnessAllocMap)
	runtime.KeepAlive(cregisteredProofAllocMap)
	__v := NewResultGenerateWindowPoStTRef(unsafe.Pointer(__ret))
	return __v
}

// GenerateWindowPost function as declared in filecoin-ffi/filcrypto.h:955
func GenerateWindowPost(randomness ByteArray32T, replicas []ArrayPrivateReplicaInfoT, proverId ByteArray32T) *ResultGenerateWindowPoStT {
	crandomness, crandomnessAllocMap := randomness.PassValue()
	creplicas, creplicasAllocMap := unpackArgSArrayPrivateReplicaInfoT(replicas)
	cproverId, cproverIdAllocMap := proverId.PassValue()
	__ret := C.generate_window_post(crandomness, creplicas, cproverId)
	runtime.KeepAlive(cproverIdAllocMap)
	packSArrayPrivateReplicaInfoT(replicas, creplicas)
	runtime.KeepAlive(creplicasAllocMap)
	runtime.KeepAlive(crandomnessAllocMap)
	__v := NewResultGenerateWindowPoStTRef(unsafe.Pointer(__ret))
	return __v
}

// VerifyWindowPost function as declared in filecoin-ffi/filcrypto.h:963
func VerifyWindowPost(randomness ByteArray32T, replicas []ArrayPublicReplicaInfoT, proofs []ArrayPoStProofT, proverId ByteArray32T) *ResultBoolT {
	crandomness, crandomnessAllocMap := randomness.PassValue()
	creplicas, creplicasAllocMap := unpackArgSArrayPublicReplicaInfoT(replicas)
	cproofs, cproofsAllocMap := unpackArgSArrayPoStProofT(proofs)
	cproverId, cproverIdAllocMap := proverId.PassValue()
	__ret := C.verify_window_post(crandomness, creplicas, cproofs, cproverId)
	runtime.KeepAlive(cproverIdAllocMap)
	packSArrayPoStProofT(proofs, cproofs)
	runtime.KeepAlive(cproofsAllocMap)
	packSArrayPublicReplicaInfoT(replicas, creplicas)
	runtime.KeepAlive(creplicasAllocMap)
	runtime.KeepAlive(crandomnessAllocMap)
	__v := NewResultBoolTRef(unsafe.Pointer(__ret))
	return __v
}

// MergeWindowPostPartitionProofs function as declared in filecoin-ffi/filcrypto.h:1001
func MergeWindowPostPartitionProofs(registeredProof RegisteredPoStProofT, partitionProofs []ArrayPartitionSnarkProofT) *ResultPoStProofT {
	cregisteredProof, cregisteredProofAllocMap := (C.RegisteredPoStProof_t)(registeredProof), cgoAllocsUnknown
	cpartitionProofs, cpartitionProofsAllocMap := unpackArgSArrayPartitionSnarkProofT(partitionProofs)
	__ret := C.merge_window_post_partition_proofs(cregisteredProof, cpartitionProofs)
	packSArrayPartitionSnarkProofT(partitionProofs, cpartitionProofs)
	runtime.KeepAlive(cpartitionProofsAllocMap)
	runtime.KeepAlive(cregisteredProofAllocMap)
	__v := NewResultPoStProofTRef(unsafe.Pointer(__ret))
	return __v
}

// GetNumPartitionForFallbackPost function as declared in filecoin-ffi/filcrypto.h:1018
func GetNumPartitionForFallbackPost(registeredProof RegisteredPoStProofT, numSectors SizeT) *ResultSizeT {
	cregisteredProof, cregisteredProofAllocMap := (C.RegisteredPoStProof_t)(registeredProof), cgoAllocsUnknown
	cnumSectors, cnumSectorsAllocMap := (C.size_t)(numSectors), cgoAllocsUnknown
	__ret := C.get_num_partition_for_fallback_post(cregisteredProof, cnumSectors)
	runtime.KeepAlive(cnumSectorsAllocMap)
	runtime.KeepAlive(cregisteredProofAllocMap)
	__v := NewResultSizeTRef(unsafe.Pointer(__ret))
	return __v
}

// GenerateSingleWindowPostWithVanilla function as declared in filecoin-ffi/filcrypto.h:1043
func GenerateSingleWindowPostWithVanilla(registeredProof RegisteredPoStProofT, randomness ByteArray32T, proverId ByteArray32T, vanillaProofs []ArraySliceBoxedUint8T, partitionIndex SizeT) *ResultGenerateSingleWindowPoStWithVanillaT {
	cregisteredProof, cregisteredProofAllocMap := (C.RegisteredPoStProof_t)(registeredProof), cgoAllocsUnknown
	crandomness, crandomnessAllocMap := randomness.PassValue()
	cproverId, cproverIdAllocMap := proverId.PassValue()
	cvanillaProofs, cvanillaProofsAllocMap := unpackArgSArraySliceBoxedUint8T(vanillaProofs)
	cpartitionIndex, cpartitionIndexAllocMap := (C.size_t)(partitionIndex), cgoAllocsUnknown
	__ret := C.generate_single_window_post_with_vanilla(cregisteredProof, crandomness, cproverId, cvanillaProofs, cpartitionIndex)
	runtime.KeepAlive(cpartitionIndexAllocMap)
	packSArraySliceBoxedUint8T(vanillaProofs, cvanillaProofs)
	runtime.KeepAlive(cvanillaProofsAllocMap)
	runtime.KeepAlive(cproverIdAllocMap)
	runtime.KeepAlive(crandomnessAllocMap)
	runtime.KeepAlive(cregisteredProofAllocMap)
	__v := NewResultGenerateSingleWindowPoStWithVanillaTRef(unsafe.Pointer(__ret))
	return __v
}

// EmptySectorUpdateEncodeInto function as declared in filecoin-ffi/filcrypto.h:1096
func EmptySectorUpdateEncodeInto(registeredProof RegisteredUpdateProofT, newReplicaPath SliceRefUint8T, newCacheDirPath SliceRefUint8T, sectorKeyPath SliceRefUint8T, sectorKeyCacheDirPath SliceRefUint8T, stagedDataPath SliceRefUint8T, pieces []ArrayPublicPieceInfoT) *ResultEmptySectorUpdateEncodeIntoT {
	cregisteredProof, cregisteredProofAllocMap := (C.RegisteredUpdateProof_t)(registeredProof), cgoAllocsUnknown
	cnewReplicaPath, cnewReplicaPathAllocMap := newReplicaPath.PassValue()
	cnewCacheDirPath, cnewCacheDirPathAllocMap := newCacheDirPath.PassValue()
	csectorKeyPath, csectorKeyPathAllocMap := sectorKeyPath.PassValue()
	csectorKeyCacheDirPath, csectorKeyCacheDirPathAllocMap := sectorKeyCacheDirPath.PassValue()
	cstagedDataPath, cstagedDataPathAllocMap := stagedDataPath.PassValue()
	cpieces, cpiecesAllocMap := unpackArgSArrayPublicPieceInfoT(pieces)
	__ret := C.empty_sector_update_encode_into(cregisteredProof, cnewReplicaPath, cnewCacheDirPath, csectorKeyPath, csectorKeyCacheDirPath, cstagedDataPath, cpieces)
	packSArrayPublicPieceInfoT(pieces, cpieces)
	runtime.KeepAlive(cpiecesAllocMap)
	runtime.KeepAlive(cstagedDataPathAllocMap)
	runtime.KeepAlive(csectorKeyCacheDirPathAllocMap)
	runtime.KeepAlive(csectorKeyPathAllocMap)
	runtime.KeepAlive(cnewCacheDirPathAllocMap)
	runtime.KeepAlive(cnewReplicaPathAllocMap)
	runtime.KeepAlive(cregisteredProofAllocMap)
	__v := NewResultEmptySectorUpdateEncodeIntoTRef(unsafe.Pointer(__ret))
	return __v
}

// EmptySectorUpdateDecodeFrom function as declared in filecoin-ffi/filcrypto.h:1108
func EmptySectorUpdateDecodeFrom(registeredProof RegisteredUpdateProofT, outDataPath SliceRefUint8T, replicaPath SliceRefUint8T, sectorKeyPath SliceRefUint8T, sectorKeyCacheDirPath SliceRefUint8T, commDNew ByteArray32T) *ResultVoidT {
	cregisteredProof, cregisteredProofAllocMap := (C.RegisteredUpdateProof_t)(registeredProof), cgoAllocsUnknown
	coutDataPath, coutDataPathAllocMap := outDataPath.PassValue()
	creplicaPath, creplicaPathAllocMap := replicaPath.PassValue()
	csectorKeyPath, csectorKeyPathAllocMap := sectorKeyPath.PassValue()
	csectorKeyCacheDirPath, csectorKeyCacheDirPathAllocMap := sectorKeyCacheDirPath.PassValue()
	ccommDNew, ccommDNewAllocMap := commDNew.PassValue()
	__ret := C.empty_sector_update_decode_from(cregisteredProof, coutDataPath, creplicaPath, csectorKeyPath, csectorKeyCacheDirPath, ccommDNew)
	runtime.KeepAlive(ccommDNewAllocMap)
	runtime.KeepAlive(csectorKeyCacheDirPathAllocMap)
	runtime.KeepAlive(csectorKeyPathAllocMap)
	runtime.KeepAlive(creplicaPathAllocMap)
	runtime.KeepAlive(coutDataPathAllocMap)
	runtime.KeepAlive(cregisteredProofAllocMap)
	__v := NewResultVoidTRef(unsafe.Pointer(__ret))
	return __v
}

// EmptySectorUpdateRemoveEncodedData function as declared in filecoin-ffi/filcrypto.h:1119
func EmptySectorUpdateRemoveEncodedData(registeredProof RegisteredUpdateProofT, sectorKeyPath SliceRefUint8T, sectorKeyCacheDirPath SliceRefUint8T, replicaPath SliceRefUint8T, replicaCachePath SliceRefUint8T, dataPath SliceRefUint8T, commDNew ByteArray32T) *ResultVoidT {
	cregisteredProof, cregisteredProofAllocMap := (C.RegisteredUpdateProof_t)(registeredProof), cgoAllocsUnknown
	csectorKeyPath, csectorKeyPathAllocMap := sectorKeyPath.PassValue()
	csectorKeyCacheDirPath, csectorKeyCacheDirPathAllocMap := sectorKeyCacheDirPath.PassValue()
	creplicaPath, creplicaPathAllocMap := replicaPath.PassValue()
	creplicaCachePath, creplicaCachePathAllocMap := replicaCachePath.PassValue()
	cdataPath, cdataPathAllocMap := dataPath.PassValue()
	ccommDNew, ccommDNewAllocMap := commDNew.PassValue()
	__ret := C.empty_sector_update_remove_encoded_data(cregisteredProof, csectorKeyPath, csectorKeyCacheDirPath, creplicaPath, creplicaCachePath, cdataPath, ccommDNew)
	runtime.KeepAlive(ccommDNewAllocMap)
	runtime.KeepAlive(cdataPathAllocMap)
	runtime.KeepAlive(creplicaCachePathAllocMap)
	runtime.KeepAlive(creplicaPathAllocMap)
	runtime.KeepAlive(csectorKeyCacheDirPathAllocMap)
	runtime.KeepAlive(csectorKeyPathAllocMap)
	runtime.KeepAlive(cregisteredProofAllocMap)
	__v := NewResultVoidTRef(unsafe.Pointer(__ret))
	return __v
}

// GenerateEmptySectorUpdatePartitionProofs function as declared in filecoin-ffi/filcrypto.h:1131
func GenerateEmptySectorUpdatePartitionProofs(registeredProof RegisteredUpdateProofT, commROld ByteArray32T, commRNew ByteArray32T, commDNew ByteArray32T, sectorKeyPath SliceRefUint8T, sectorKeyCacheDirPath SliceRefUint8T, replicaPath SliceRefUint8T, replicaCachePath SliceRefUint8T) *ResultArraySliceBoxedUint8T {
	cregisteredProof, cregisteredProofAllocMap := (C.RegisteredUpdateProof_t)(registeredProof), cgoAllocsUnknown
	ccommROld, ccommROldAllocMap := commROld.PassValue()
	ccommRNew, ccommRNewAllocMap := commRNew.PassValue()
	ccommDNew, ccommDNewAllocMap := commDNew.PassValue()
	csectorKeyPath, csectorKeyPathAllocMap := sectorKeyPath.PassValue()
	csectorKeyCacheDirPath, csectorKeyCacheDirPathAllocMap := sectorKeyCacheDirPath.PassValue()
	creplicaPath, creplicaPathAllocMap := replicaPath.PassValue()
	creplicaCachePath, creplicaCachePathAllocMap := replicaCachePath.PassValue()
	__ret := C.generate_empty_sector_update_partition_proofs(cregisteredProof, ccommROld, ccommRNew, ccommDNew, csectorKeyPath, csectorKeyCacheDirPath, creplicaPath, creplicaCachePath)
	runtime.KeepAlive(creplicaCachePathAllocMap)
	runtime.KeepAlive(creplicaPathAllocMap)
	runtime.KeepAlive(csectorKeyCacheDirPathAllocMap)
	runtime.KeepAlive(csectorKeyPathAllocMap)
	runtime.KeepAlive(ccommDNewAllocMap)
	runtime.KeepAlive(ccommRNewAllocMap)
	runtime.KeepAlive(ccommROldAllocMap)
	runtime.KeepAlive(cregisteredProofAllocMap)
	__v := NewResultArraySliceBoxedUint8TRef(unsafe.Pointer(__ret))
	return __v
}

// VerifyEmptySectorUpdatePartitionProofs function as declared in filecoin-ffi/filcrypto.h:1144
func VerifyEmptySectorUpdatePartitionProofs(registeredProof RegisteredUpdateProofT, proofs []ArraySliceBoxedUint8T, commROld ByteArray32T, commRNew ByteArray32T, commDNew ByteArray32T) *ResultBoolT {
	cregisteredProof, cregisteredProofAllocMap := (C.RegisteredUpdateProof_t)(registeredProof), cgoAllocsUnknown
	cproofs, cproofsAllocMap := unpackArgSArraySliceBoxedUint8T(proofs)
	ccommROld, ccommROldAllocMap := commROld.PassValue()
	ccommRNew, ccommRNewAllocMap := commRNew.PassValue()
	ccommDNew, ccommDNewAllocMap := commDNew.PassValue()
	__ret := C.verify_empty_sector_update_partition_proofs(cregisteredProof, cproofs, ccommROld, ccommRNew, ccommDNew)
	runtime.KeepAlive(ccommDNewAllocMap)
	runtime.KeepAlive(ccommRNewAllocMap)
	runtime.KeepAlive(ccommROldAllocMap)
	packSArraySliceBoxedUint8T(proofs, cproofs)
	runtime.KeepAlive(cproofsAllocMap)
	runtime.KeepAlive(cregisteredProofAllocMap)
	__v := NewResultBoolTRef(unsafe.Pointer(__ret))
	return __v
}

// GenerateEmptySectorUpdateProofWithVanilla function as declared in filecoin-ffi/filcrypto.h:1154
func GenerateEmptySectorUpdateProofWithVanilla(registeredProof RegisteredUpdateProofT, vanillaProofs []ArraySliceBoxedUint8T, commROld ByteArray32T, commRNew ByteArray32T, commDNew ByteArray32T) *ResultSliceBoxedUint8T {
	cregisteredProof, cregisteredProofAllocMap := (C.RegisteredUpdateProof_t)(registeredProof), cgoAllocsUnknown
	cvanillaProofs, cvanillaProofsAllocMap := unpackArgSArraySliceBoxedUint8T(vanillaProofs)
	ccommROld, ccommROldAllocMap := commROld.PassValue()
	ccommRNew, ccommRNewAllocMap := commRNew.PassValue()
	ccommDNew, ccommDNewAllocMap := commDNew.PassValue()
	__ret := C.generate_empty_sector_update_proof_with_vanilla(cregisteredProof, cvanillaProofs, ccommROld, ccommRNew, ccommDNew)
	runtime.KeepAlive(ccommDNewAllocMap)
	runtime.KeepAlive(ccommRNewAllocMap)
	runtime.KeepAlive(ccommROldAllocMap)
	packSArraySliceBoxedUint8T(vanillaProofs, cvanillaProofs)
	runtime.KeepAlive(cvanillaProofsAllocMap)
	runtime.KeepAlive(cregisteredProofAllocMap)
	__v := NewResultSliceBoxedUint8TRef(unsafe.Pointer(__ret))
	return __v
}

// GenerateEmptySectorUpdateProof function as declared in filecoin-ffi/filcrypto.h:1164
func GenerateEmptySectorUpdateProof(registeredProof RegisteredUpdateProofT, commROld ByteArray32T, commRNew ByteArray32T, commDNew ByteArray32T, sectorKeyPath SliceRefUint8T, sectorKeyCacheDirPath SliceRefUint8T, replicaPath SliceRefUint8T, replicaCachePath SliceRefUint8T) *ResultSliceBoxedUint8T {
	cregisteredProof, cregisteredProofAllocMap := (C.RegisteredUpdateProof_t)(registeredProof), cgoAllocsUnknown
	ccommROld, ccommROldAllocMap := commROld.PassValue()
	ccommRNew, ccommRNewAllocMap := commRNew.PassValue()
	ccommDNew, ccommDNewAllocMap := commDNew.PassValue()
	csectorKeyPath, csectorKeyPathAllocMap := sectorKeyPath.PassValue()
	csectorKeyCacheDirPath, csectorKeyCacheDirPathAllocMap := sectorKeyCacheDirPath.PassValue()
	creplicaPath, creplicaPathAllocMap := replicaPath.PassValue()
	creplicaCachePath, creplicaCachePathAllocMap := replicaCachePath.PassValue()
	__ret := C.generate_empty_sector_update_proof(cregisteredProof, ccommROld, ccommRNew, ccommDNew, csectorKeyPath, csectorKeyCacheDirPath, creplicaPath, creplicaCachePath)
	runtime.KeepAlive(creplicaCachePathAllocMap)
	runtime.KeepAlive(creplicaPathAllocMap)
	runtime.KeepAlive(csectorKeyCacheDirPathAllocMap)
	runtime.KeepAlive(csectorKeyPathAllocMap)
	runtime.KeepAlive(ccommDNewAllocMap)
	runtime.KeepAlive(ccommRNewAllocMap)
	runtime.KeepAlive(ccommROldAllocMap)
	runtime.KeepAlive(cregisteredProofAllocMap)
	__v := NewResultSliceBoxedUint8TRef(unsafe.Pointer(__ret))
	return __v
}

// VerifyEmptySectorUpdateProof function as declared in filecoin-ffi/filcrypto.h:1177
func VerifyEmptySectorUpdateProof(registeredProof RegisteredUpdateProofT, proof SliceRefUint8T, commROld ByteArray32T, commRNew ByteArray32T, commDNew ByteArray32T) *ResultBoolT {
	cregisteredProof, cregisteredProofAllocMap := (C.RegisteredUpdateProof_t)(registeredProof), cgoAllocsUnknown
	cproof, cproofAllocMap := proof.PassValue()
	ccommROld, ccommROldAllocMap := commROld.PassValue()
	ccommRNew, ccommRNewAllocMap := commRNew.PassValue()
	ccommDNew, ccommDNewAllocMap := commDNew.PassValue()
	__ret := C.verify_empty_sector_update_proof(cregisteredProof, cproof, ccommROld, ccommRNew, ccommDNew)
	runtime.KeepAlive(ccommDNewAllocMap)
	runtime.KeepAlive(ccommRNewAllocMap)
	runtime.KeepAlive(ccommROldAllocMap)
	runtime.KeepAlive(cproofAllocMap)
	runtime.KeepAlive(cregisteredProofAllocMap)
	__v := NewResultBoolTRef(unsafe.Pointer(__ret))
	return __v
}

// GeneratePieceCommitment function as declared in filecoin-ffi/filcrypto.h:1206
func GeneratePieceCommitment(registeredProof RegisteredSealProofT, pieceFdRaw Int32T, unpaddedPieceSize Uint64T) *ResultGeneratePieceCommitmentT {
	cregisteredProof, cregisteredProofAllocMap := (C.RegisteredSealProof_t)(registeredProof), cgoAllocsUnknown
	cpieceFdRaw, cpieceFdRawAllocMap := (C.int32_t)(pieceFdRaw), cgoAllocsUnknown
	cunpaddedPieceSize, cunpaddedPieceSizeAllocMap := (C.uint64_t)(unpaddedPieceSize), cgoAllocsUnknown
	__ret := C.generate_piece_commitment(cregisteredProof, cpieceFdRaw, cunpaddedPieceSize)
	runtime.KeepAlive(cunpaddedPieceSizeAllocMap)
	runtime.KeepAlive(cpieceFdRawAllocMap)
	runtime.KeepAlive(cregisteredProofAllocMap)
	__v := NewResultGeneratePieceCommitmentTRef(unsafe.Pointer(__ret))
	return __v
}

// GenerateDataCommitment function as declared in filecoin-ffi/filcrypto.h:1214
func GenerateDataCommitment(registeredProof RegisteredSealProofT, pieces []ArrayPublicPieceInfoT) *ResultByteArray32T {
	cregisteredProof, cregisteredProofAllocMap := (C.RegisteredSealProof_t)(registeredProof), cgoAllocsUnknown
	cpieces, cpiecesAllocMap := unpackArgSArrayPublicPieceInfoT(pieces)
	__ret := C.generate_data_commitment(cregisteredProof, cpieces)
	packSArrayPublicPieceInfoT(pieces, cpieces)
	runtime.KeepAlive(cpiecesAllocMap)
	runtime.KeepAlive(cregisteredProofAllocMap)
	__v := NewResultByteArray32TRef(unsafe.Pointer(__ret))
	return __v
}

// ClearCache function as declared in filecoin-ffi/filcrypto.h:1218
func ClearCache(sectorSize Uint64T, cacheDirPath SliceRefUint8T) *ResultVoidT {
	csectorSize, csectorSizeAllocMap := (C.uint64_t)(sectorSize), cgoAllocsUnknown
	ccacheDirPath, ccacheDirPathAllocMap := cacheDirPath.PassValue()
	__ret := C.clear_cache(csectorSize, ccacheDirPath)
	runtime.KeepAlive(ccacheDirPathAllocMap)
	runtime.KeepAlive(csectorSizeAllocMap)
	__v := NewResultVoidTRef(unsafe.Pointer(__ret))
	return __v
}

// DestroyWriteWithAlignmentResponse function as declared in filecoin-ffi/filcrypto.h:1222
func DestroyWriteWithAlignmentResponse(ptr []ResultWriteWithAlignmentT) {
	cptr, cptrAllocMap := unpackArgSResultWriteWithAlignmentT(ptr)
	C.destroy_write_with_alignment_response(cptr)
	packSResultWriteWithAlignmentT(ptr, cptr)
	runtime.KeepAlive(cptrAllocMap)
}

// DestroyWriteWithoutAlignmentResponse function as declared in filecoin-ffi/filcrypto.h:1225
func DestroyWriteWithoutAlignmentResponse(ptr []ResultWriteWithoutAlignmentT) {
	cptr, cptrAllocMap := unpackArgSResultWriteWithoutAlignmentT(ptr)
	C.destroy_write_without_alignment_response(cptr)
	packSResultWriteWithoutAlignmentT(ptr, cptr)
	runtime.KeepAlive(cptrAllocMap)
}

// DestroyFauxrepResponse function as declared in filecoin-ffi/filcrypto.h:1228
func DestroyFauxrepResponse(ptr []ResultByteArray32T) {
	cptr, cptrAllocMap := unpackArgSResultByteArray32T(ptr)
	C.destroy_fauxrep_response(cptr)
	packSResultByteArray32T(ptr, cptr)
	runtime.KeepAlive(cptrAllocMap)
}

// DestroySealPreCommitPhase1Response function as declared in filecoin-ffi/filcrypto.h:1231
func DestroySealPreCommitPhase1Response(ptr []ResultSliceBoxedUint8T) {
	cptr, cptrAllocMap := unpackArgSResultSliceBoxedUint8T(ptr)
	C.destroy_seal_pre_commit_phase1_response(cptr)
	packSResultSliceBoxedUint8T(ptr, cptr)
	runtime.KeepAlive(cptrAllocMap)
}

// DestroySealPreCommitPhase2Response function as declared in filecoin-ffi/filcrypto.h:1234
func DestroySealPreCommitPhase2Response(ptr []ResultSealPreCommitPhase2T) {
	cptr, cptrAllocMap := unpackArgSResultSealPreCommitPhase2T(ptr)
	C.destroy_seal_pre_commit_phase2_response(cptr)
	packSResultSealPreCommitPhase2T(ptr, cptr)
	runtime.KeepAlive(cptrAllocMap)
}

// DestroySealCommitPhase1Response function as declared in filecoin-ffi/filcrypto.h:1237
func DestroySealCommitPhase1Response(ptr []ResultSliceBoxedUint8T) {
	cptr, cptrAllocMap := unpackArgSResultSliceBoxedUint8T(ptr)
	C.destroy_seal_commit_phase1_response(cptr)
	packSResultSliceBoxedUint8T(ptr, cptr)
	runtime.KeepAlive(cptrAllocMap)
}

// DestroySealCommitPhase2Response function as declared in filecoin-ffi/filcrypto.h:1240
func DestroySealCommitPhase2Response(ptr []ResultSealCommitPhase2T) {
	cptr, cptrAllocMap := unpackArgSResultSealCommitPhase2T(ptr)
	C.destroy_seal_commit_phase2_response(cptr)
	packSResultSealCommitPhase2T(ptr, cptr)
	runtime.KeepAlive(cptrAllocMap)
}

// DestroyUnsealRangeResponse function as declared in filecoin-ffi/filcrypto.h:1243
func DestroyUnsealRangeResponse(ptr []ResultVoidT) {
	cptr, cptrAllocMap := unpackArgSResultVoidT(ptr)
	C.destroy_unseal_range_response(cptr)
	packSResultVoidT(ptr, cptr)
	runtime.KeepAlive(cptrAllocMap)
}

// DestroyGeneratePieceCommitmentResponse function as declared in filecoin-ffi/filcrypto.h:1246
func DestroyGeneratePieceCommitmentResponse(ptr []ResultGeneratePieceCommitmentT) {
	cptr, cptrAllocMap := unpackArgSResultGeneratePieceCommitmentT(ptr)
	C.destroy_generate_piece_commitment_response(cptr)
	packSResultGeneratePieceCommitmentT(ptr, cptr)
	runtime.KeepAlive(cptrAllocMap)
}

// DestroyGenerateDataCommitmentResponse function as declared in filecoin-ffi/filcrypto.h:1249
func DestroyGenerateDataCommitmentResponse(ptr []ResultByteArray32T) {
	cptr, cptrAllocMap := unpackArgSResultByteArray32T(ptr)
	C.destroy_generate_data_commitment_response(cptr)
	packSResultByteArray32T(ptr, cptr)
	runtime.KeepAlive(cptrAllocMap)
}

// DestroyStringResponse function as declared in filecoin-ffi/filcrypto.h:1252
func DestroyStringResponse(ptr []ResultSliceBoxedUint8T) {
	cptr, cptrAllocMap := unpackArgSResultSliceBoxedUint8T(ptr)
	C.destroy_string_response(cptr)
	packSResultSliceBoxedUint8T(ptr, cptr)
	runtime.KeepAlive(cptrAllocMap)
}

// GetMaxUserBytesPerStagedSector function as declared in filecoin-ffi/filcrypto.h:1258
func GetMaxUserBytesPerStagedSector(registeredProof RegisteredSealProofT) Uint64T {
	cregisteredProof, cregisteredProofAllocMap := (C.RegisteredSealProof_t)(registeredProof), cgoAllocsUnknown
	__ret := C.get_max_user_bytes_per_staged_sector(cregisteredProof)
	runtime.KeepAlive(cregisteredProofAllocMap)
	__v := (Uint64T)(__ret)
	return __v
}

// GetSealParamsCid function as declared in filecoin-ffi/filcrypto.h:1264
func GetSealParamsCid(registeredProof RegisteredSealProofT) *ResultSliceBoxedUint8T {
	cregisteredProof, cregisteredProofAllocMap := (C.RegisteredSealProof_t)(registeredProof), cgoAllocsUnknown
	__ret := C.get_seal_params_cid(cregisteredProof)
	runtime.KeepAlive(cregisteredProofAllocMap)
	__v := NewResultSliceBoxedUint8TRef(unsafe.Pointer(__ret))
	return __v
}

// GetSealVerifyingKeyCid function as declared in filecoin-ffi/filcrypto.h:1270
func GetSealVerifyingKeyCid(registeredProof RegisteredSealProofT) *ResultSliceBoxedUint8T {
	cregisteredProof, cregisteredProofAllocMap := (C.RegisteredSealProof_t)(registeredProof), cgoAllocsUnknown
	__ret := C.get_seal_verifying_key_cid(cregisteredProof)
	runtime.KeepAlive(cregisteredProofAllocMap)
	__v := NewResultSliceBoxedUint8TRef(unsafe.Pointer(__ret))
	return __v
}

// GetSealParamsPath function as declared in filecoin-ffi/filcrypto.h:1277
func GetSealParamsPath(registeredProof RegisteredSealProofT) *ResultSliceBoxedUint8T {
	cregisteredProof, cregisteredProofAllocMap := (C.RegisteredSealProof_t)(registeredProof), cgoAllocsUnknown
	__ret := C.get_seal_params_path(cregisteredProof)
	runtime.KeepAlive(cregisteredProofAllocMap)
	__v := NewResultSliceBoxedUint8TRef(unsafe.Pointer(__ret))
	return __v
}

// GetSealVerifyingKeyPath function as declared in filecoin-ffi/filcrypto.h:1284
func GetSealVerifyingKeyPath(registeredProof RegisteredSealProofT) *ResultSliceBoxedUint8T {
	cregisteredProof, cregisteredProofAllocMap := (C.RegisteredSealProof_t)(registeredProof), cgoAllocsUnknown
	__ret := C.get_seal_verifying_key_path(cregisteredProof)
	runtime.KeepAlive(cregisteredProofAllocMap)
	__v := NewResultSliceBoxedUint8TRef(unsafe.Pointer(__ret))
	return __v
}

// GetSealCircuitIdentifier function as declared in filecoin-ffi/filcrypto.h:1290
func GetSealCircuitIdentifier(registeredProof RegisteredSealProofT) *ResultSliceBoxedUint8T {
	cregisteredProof, cregisteredProofAllocMap := (C.RegisteredSealProof_t)(registeredProof), cgoAllocsUnknown
	__ret := C.get_seal_circuit_identifier(cregisteredProof)
	runtime.KeepAlive(cregisteredProofAllocMap)
	__v := NewResultSliceBoxedUint8TRef(unsafe.Pointer(__ret))
	return __v
}

// GetSealVersion function as declared in filecoin-ffi/filcrypto.h:1296
func GetSealVersion(registeredProof RegisteredSealProofT) *ResultSliceBoxedUint8T {
	cregisteredProof, cregisteredProofAllocMap := (C.RegisteredSealProof_t)(registeredProof), cgoAllocsUnknown
	__ret := C.get_seal_version(cregisteredProof)
	runtime.KeepAlive(cregisteredProofAllocMap)
	__v := NewResultSliceBoxedUint8TRef(unsafe.Pointer(__ret))
	return __v
}

// GetPostParamsCid function as declared in filecoin-ffi/filcrypto.h:1302
func GetPostParamsCid(registeredProof RegisteredPoStProofT) *ResultSliceBoxedUint8T {
	cregisteredProof, cregisteredProofAllocMap := (C.RegisteredPoStProof_t)(registeredProof), cgoAllocsUnknown
	__ret := C.get_post_params_cid(cregisteredProof)
	runtime.KeepAlive(cregisteredProofAllocMap)
	__v := NewResultSliceBoxedUint8TRef(unsafe.Pointer(__ret))
	return __v
}

// GetPostVerifyingKeyCid function as declared in filecoin-ffi/filcrypto.h:1308
func GetPostVerifyingKeyCid(registeredProof RegisteredPoStProofT) *ResultSliceBoxedUint8T {
	cregisteredProof, cregisteredProofAllocMap := (C.RegisteredPoStProof_t)(registeredProof), cgoAllocsUnknown
	__ret := C.get_post_verifying_key_cid(cregisteredProof)
	runtime.KeepAlive(cregisteredProofAllocMap)
	__v := NewResultSliceBoxedUint8TRef(unsafe.Pointer(__ret))
	return __v
}

// GetPostParamsPath function as declared in filecoin-ffi/filcrypto.h:1315
func GetPostParamsPath(registeredProof RegisteredPoStProofT) *ResultSliceBoxedUint8T {
	cregisteredProof, cregisteredProofAllocMap := (C.RegisteredPoStProof_t)(registeredProof), cgoAllocsUnknown
	__ret := C.get_post_params_path(cregisteredProof)
	runtime.KeepAlive(cregisteredProofAllocMap)
	__v := NewResultSliceBoxedUint8TRef(unsafe.Pointer(__ret))
	return __v
}

// GetPostVerifyingKeyPath function as declared in filecoin-ffi/filcrypto.h:1322
func GetPostVerifyingKeyPath(registeredProof RegisteredPoStProofT) *ResultSliceBoxedUint8T {
	cregisteredProof, cregisteredProofAllocMap := (C.RegisteredPoStProof_t)(registeredProof), cgoAllocsUnknown
	__ret := C.get_post_verifying_key_path(cregisteredProof)
	runtime.KeepAlive(cregisteredProofAllocMap)
	__v := NewResultSliceBoxedUint8TRef(unsafe.Pointer(__ret))
	return __v
}

// GetPostCircuitIdentifier function as declared in filecoin-ffi/filcrypto.h:1328
func GetPostCircuitIdentifier(registeredProof RegisteredPoStProofT) *ResultSliceBoxedUint8T {
	cregisteredProof, cregisteredProofAllocMap := (C.RegisteredPoStProof_t)(registeredProof), cgoAllocsUnknown
	__ret := C.get_post_circuit_identifier(cregisteredProof)
	runtime.KeepAlive(cregisteredProofAllocMap)
	__v := NewResultSliceBoxedUint8TRef(unsafe.Pointer(__ret))
	return __v
}

// GetPostVersion function as declared in filecoin-ffi/filcrypto.h:1334
func GetPostVersion(registeredProof RegisteredPoStProofT) *ResultSliceBoxedUint8T {
	cregisteredProof, cregisteredProofAllocMap := (C.RegisteredPoStProof_t)(registeredProof), cgoAllocsUnknown
	__ret := C.get_post_version(cregisteredProof)
	runtime.KeepAlive(cregisteredProofAllocMap)
	__v := NewResultSliceBoxedUint8TRef(unsafe.Pointer(__ret))
	return __v
}

// DestroyVerifySealResponse function as declared in filecoin-ffi/filcrypto.h:1340
func DestroyVerifySealResponse(ptr []ResultBoolT) {
	cptr, cptrAllocMap := unpackArgSResultBoolT(ptr)
	C.destroy_verify_seal_response(cptr)
	packSResultBoolT(ptr, cptr)
	runtime.KeepAlive(cptrAllocMap)
}

// DestroyVerifyAggregateSealResponse function as declared in filecoin-ffi/filcrypto.h:1346
func DestroyVerifyAggregateSealResponse(ptr []ResultBoolT) {
	cptr, cptrAllocMap := unpackArgSResultBoolT(ptr)
	C.destroy_verify_aggregate_seal_response(cptr)
	packSResultBoolT(ptr, cptr)
	runtime.KeepAlive(cptrAllocMap)
}

// DestroyFinalizeTicketResponse function as declared in filecoin-ffi/filcrypto.h:1349
func DestroyFinalizeTicketResponse(ptr []ResultByteArray32T) {
	cptr, cptrAllocMap := unpackArgSResultByteArray32T(ptr)
	C.destroy_finalize_ticket_response(cptr)
	packSResultByteArray32T(ptr, cptr)
	runtime.KeepAlive(cptrAllocMap)
}

// DestroyVerifyWinningPostResponse function as declared in filecoin-ffi/filcrypto.h:1355
func DestroyVerifyWinningPostResponse(ptr []ResultBoolT) {
	cptr, cptrAllocMap := unpackArgSResultBoolT(ptr)
	C.destroy_verify_winning_post_response(cptr)
	packSResultBoolT(ptr, cptr)
	runtime.KeepAlive(cptrAllocMap)
}

// DestroyVerifyWindowPostResponse function as declared in filecoin-ffi/filcrypto.h:1358
func DestroyVerifyWindowPostResponse(ptr []ResultBoolT) {
	cptr, cptrAllocMap := unpackArgSResultBoolT(ptr)
	C.destroy_verify_window_post_response(cptr)
	packSResultBoolT(ptr, cptr)
	runtime.KeepAlive(cptrAllocMap)
}

// DestroyGenerateFallbackSectorChallengesResponse function as declared in filecoin-ffi/filcrypto.h:1361
func DestroyGenerateFallbackSectorChallengesResponse(ptr []ResultGenerateFallbackSectorChallengesT) {
	cptr, cptrAllocMap := unpackArgSResultGenerateFallbackSectorChallengesT(ptr)
	C.destroy_generate_fallback_sector_challenges_response(cptr)
	packSResultGenerateFallbackSectorChallengesT(ptr, cptr)
	runtime.KeepAlive(cptrAllocMap)
}

// DestroyGenerateSingleVanillaProofResponse function as declared in filecoin-ffi/filcrypto.h:1364
func DestroyGenerateSingleVanillaProofResponse(ptr []ResultSliceBoxedUint8T) {
	cptr, cptrAllocMap := unpackArgSResultSliceBoxedUint8T(ptr)
	C.destroy_generate_single_vanilla_proof_response(cptr)
	packSResultSliceBoxedUint8T(ptr, cptr)
	runtime.KeepAlive(cptrAllocMap)
}

// DestroyGenerateSingleWindowPostWithVanillaResponse function as declared in filecoin-ffi/filcrypto.h:1367
func DestroyGenerateSingleWindowPostWithVanillaResponse(ptr []ResultGenerateSingleWindowPoStWithVanillaT) {
	cptr, cptrAllocMap := unpackArgSResultGenerateSingleWindowPoStWithVanillaT(ptr)
	C.destroy_generate_single_window_post_with_vanilla_response(cptr)
	packSResultGenerateSingleWindowPoStWithVanillaT(ptr, cptr)
	runtime.KeepAlive(cptrAllocMap)
}

// DestroyGetNumPartitionForFallbackPostResponse function as declared in filecoin-ffi/filcrypto.h:1370
func DestroyGetNumPartitionForFallbackPostResponse(ptr []ResultSizeT) {
	cptr, cptrAllocMap := unpackArgSResultSizeT(ptr)
	C.destroy_get_num_partition_for_fallback_post_response(cptr)
	packSResultSizeT(ptr, cptr)
	runtime.KeepAlive(cptrAllocMap)
}

// DestroyMergeWindowPostPartitionProofsResponse function as declared in filecoin-ffi/filcrypto.h:1373
func DestroyMergeWindowPostPartitionProofsResponse(ptr []ResultPoStProofT) {
	cptr, cptrAllocMap := unpackArgSResultPoStProofT(ptr)
	C.destroy_merge_window_post_partition_proofs_response(cptr)
	packSResultPoStProofT(ptr, cptr)
	runtime.KeepAlive(cptrAllocMap)
}

// DestroyGenerateWinningPostResponse function as declared in filecoin-ffi/filcrypto.h:1376
func DestroyGenerateWinningPostResponse(ptr []ResultArrayPoStProofT) {
	cptr, cptrAllocMap := unpackArgSResultArrayPoStProofT(ptr)
	C.destroy_generate_winning_post_response(cptr)
	packSResultArrayPoStProofT(ptr, cptr)
	runtime.KeepAlive(cptrAllocMap)
}

// DestroyGenerateWindowPostResponse function as declared in filecoin-ffi/filcrypto.h:1379
func DestroyGenerateWindowPostResponse(ptr []ResultGenerateWindowPoStT) {
	cptr, cptrAllocMap := unpackArgSResultGenerateWindowPoStT(ptr)
	C.destroy_generate_window_post_response(cptr)
	packSResultGenerateWindowPoStT(ptr, cptr)
	runtime.KeepAlive(cptrAllocMap)
}

// DestroyGenerateWinningPostSectorChallenge function as declared in filecoin-ffi/filcrypto.h:1382
func DestroyGenerateWinningPostSectorChallenge(ptr []ResultArrayUint64T) {
	cptr, cptrAllocMap := unpackArgSResultArrayUint64T(ptr)
	C.destroy_generate_winning_post_sector_challenge(cptr)
	packSResultArrayUint64T(ptr, cptr)
	runtime.KeepAlive(cptrAllocMap)
}

// DestroyClearCacheResponse function as declared in filecoin-ffi/filcrypto.h:1385
func DestroyClearCacheResponse(ptr []ResultVoidT) {
	cptr, cptrAllocMap := unpackArgSResultVoidT(ptr)
	C.destroy_clear_cache_response(cptr)
	packSResultVoidT(ptr, cptr)
	runtime.KeepAlive(cptrAllocMap)
}

// DestroyAggregateProof function as declared in filecoin-ffi/filcrypto.h:1391
func DestroyAggregateProof(ptr []ResultSliceBoxedUint8T) {
	cptr, cptrAllocMap := unpackArgSResultSliceBoxedUint8T(ptr)
	C.destroy_aggregate_proof(cptr)
	packSResultSliceBoxedUint8T(ptr, cptr)
	runtime.KeepAlive(cptrAllocMap)
}

// DestroyEmptySectorUpdateGenerateProofResponse function as declared in filecoin-ffi/filcrypto.h:1397
func DestroyEmptySectorUpdateGenerateProofResponse(ptr []ResultSliceBoxedUint8T) {
	cptr, cptrAllocMap := unpackArgSResultSliceBoxedUint8T(ptr)
	C.destroy_empty_sector_update_generate_proof_response(cptr)
	packSResultSliceBoxedUint8T(ptr, cptr)
	runtime.KeepAlive(cptrAllocMap)
}

// DestroyEmptySectorUpdateVerifyProofResponse function as declared in filecoin-ffi/filcrypto.h:1403
func DestroyEmptySectorUpdateVerifyProofResponse(ptr []ResultBoolT) {
	cptr, cptrAllocMap := unpackArgSResultBoolT(ptr)
	C.destroy_empty_sector_update_verify_proof_response(cptr)
	packSResultBoolT(ptr, cptr)
	runtime.KeepAlive(cptrAllocMap)
}

// DestroyGenerateEmptySectorUpdatePartitionProofResponse function as declared in filecoin-ffi/filcrypto.h:1409
func DestroyGenerateEmptySectorUpdatePartitionProofResponse(ptr []ResultArraySliceBoxedUint8T) {
	cptr, cptrAllocMap := unpackArgSResultArraySliceBoxedUint8T(ptr)
	C.destroy_generate_empty_sector_update_partition_proof_response(cptr)
	packSResultArraySliceBoxedUint8T(ptr, cptr)
	runtime.KeepAlive(cptrAllocMap)
}

// DestroyVerifyEmptySectorUpdatePartitionProofResponse function as declared in filecoin-ffi/filcrypto.h:1415
func DestroyVerifyEmptySectorUpdatePartitionProofResponse(ptr []ResultBoolT) {
	cptr, cptrAllocMap := unpackArgSResultBoolT(ptr)
	C.destroy_verify_empty_sector_update_partition_proof_response(cptr)
	packSResultBoolT(ptr, cptr)
	runtime.KeepAlive(cptrAllocMap)
}

// DestroyEmptySectorUpdateEncodeIntoResponse function as declared in filecoin-ffi/filcrypto.h:1421
func DestroyEmptySectorUpdateEncodeIntoResponse(ptr []ResultEmptySectorUpdateEncodeIntoT) {
	cptr, cptrAllocMap := unpackArgSResultEmptySectorUpdateEncodeIntoT(ptr)
	C.destroy_empty_sector_update_encode_into_response(cptr)
	packSResultEmptySectorUpdateEncodeIntoT(ptr, cptr)
	runtime.KeepAlive(cptrAllocMap)
}

// DestroyEmptySectorUpdateDecodeFromResponse function as declared in filecoin-ffi/filcrypto.h:1427
func DestroyEmptySectorUpdateDecodeFromResponse(ptr []ResultVoidT) {
	cptr, cptrAllocMap := unpackArgSResultVoidT(ptr)
	C.destroy_empty_sector_update_decode_from_response(cptr)
	packSResultVoidT(ptr, cptr)
	runtime.KeepAlive(cptrAllocMap)
}

// DestroyEmptySectorUpdateRemoveEncodedDataResponse function as declared in filecoin-ffi/filcrypto.h:1433
func DestroyEmptySectorUpdateRemoveEncodedDataResponse(ptr []ResultVoidT) {
	cptr, cptrAllocMap := unpackArgSResultVoidT(ptr)
	C.destroy_empty_sector_update_remove_encoded_data_response(cptr)
	packSResultVoidT(ptr, cptr)
	runtime.KeepAlive(cptrAllocMap)
}

// DestroyHashResponse function as declared in filecoin-ffi/filcrypto.h:1436
func DestroyHashResponse(ptr []HashResponseT) {
	cptr, cptrAllocMap := unpackArgSHashResponseT(ptr)
	C.destroy_hash_response(cptr)
	packSHashResponseT(ptr, cptr)
	runtime.KeepAlive(cptrAllocMap)
}

// DestroyAggregateResponse function as declared in filecoin-ffi/filcrypto.h:1439
func DestroyAggregateResponse(ptr []AggregateResponseT) {
	cptr, cptrAllocMap := unpackArgSAggregateResponseT(ptr)
	C.destroy_aggregate_response(cptr)
	packSAggregateResponseT(ptr, cptr)
	runtime.KeepAlive(cptrAllocMap)
}

// DestroyPrivateKeyGenerateResponse function as declared in filecoin-ffi/filcrypto.h:1442
func DestroyPrivateKeyGenerateResponse(ptr []PrivateKeyGenerateResponseT) {
	cptr, cptrAllocMap := unpackArgSPrivateKeyGenerateResponseT(ptr)
	C.destroy_private_key_generate_response(cptr)
	packSPrivateKeyGenerateResponseT(ptr, cptr)
	runtime.KeepAlive(cptrAllocMap)
}

// DestroyPrivateKeySignResponse function as declared in filecoin-ffi/filcrypto.h:1445
func DestroyPrivateKeySignResponse(ptr []PrivateKeySignResponseT) {
	cptr, cptrAllocMap := unpackArgSPrivateKeySignResponseT(ptr)
	C.destroy_private_key_sign_response(cptr)
	packSPrivateKeySignResponseT(ptr, cptr)
	runtime.KeepAlive(cptrAllocMap)
}

// DestroyPrivateKeyPublicKeyResponse function as declared in filecoin-ffi/filcrypto.h:1448
func DestroyPrivateKeyPublicKeyResponse(ptr []PrivateKeyPublicKeyResponseT) {
	cptr, cptrAllocMap := unpackArgSPrivateKeyPublicKeyResponseT(ptr)
	C.destroy_private_key_public_key_response(cptr)
	packSPrivateKeyPublicKeyResponseT(ptr, cptr)
	runtime.KeepAlive(cptrAllocMap)
}

// DestroyZeroSignatureResponse function as declared in filecoin-ffi/filcrypto.h:1451
func DestroyZeroSignatureResponse(ptr []ZeroSignatureResponseT) {
	cptr, cptrAllocMap := unpackArgSZeroSignatureResponseT(ptr)
	C.destroy_zero_signature_response(cptr)
	packSZeroSignatureResponseT(ptr, cptr)
	runtime.KeepAlive(cptrAllocMap)
}
