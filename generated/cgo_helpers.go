// WARNING: This file has automatically been generated
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package generated

/*
#cgo LDFLAGS: -L${SRCDIR}/..
#cgo pkg-config: ${SRCDIR}/../filcrypto.pc
#include "../filcrypto.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"fmt"
	"runtime"
	"sync"
	"unsafe"
)

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

// allocFilBLSDigestMemory allocates memory for type C.fil_BLSDigest in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilBLSDigestMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilBLSDigestValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilBLSDigestValue = unsafe.Sizeof([1]C.fil_BLSDigest{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilBLSDigest) Ref() *C.fil_BLSDigest {
	if x == nil {
		return nil
	}
	return x.ref215fc78c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilBLSDigest) Free() {
	if x != nil && x.allocs215fc78c != nil {
		x.allocs215fc78c.(*cgoAllocMap).Free()
		x.ref215fc78c = nil
	}
}

// NewFilBLSDigestRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilBLSDigestRef(ref unsafe.Pointer) *FilBLSDigest {
	if ref == nil {
		return nil
	}
	obj := new(FilBLSDigest)
	obj.ref215fc78c = (*C.fil_BLSDigest)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilBLSDigest) PassRef() (*C.fil_BLSDigest, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref215fc78c != nil {
		return x.ref215fc78c, nil
	}
	mem215fc78c := allocFilBLSDigestMemory(1)
	ref215fc78c := (*C.fil_BLSDigest)(mem215fc78c)
	allocs215fc78c := new(cgoAllocMap)
	allocs215fc78c.Add(mem215fc78c)

	var cinner_allocs *cgoAllocMap
	ref215fc78c.inner, cinner_allocs = *(*[96]C.uint8_t)(unsafe.Pointer(&x.Inner)), cgoAllocsUnknown
	allocs215fc78c.Borrow(cinner_allocs)

	x.ref215fc78c = ref215fc78c
	x.allocs215fc78c = allocs215fc78c
	return ref215fc78c, allocs215fc78c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilBLSDigest) PassValue() (C.fil_BLSDigest, *cgoAllocMap) {
	if x.ref215fc78c != nil {
		return *x.ref215fc78c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilBLSDigest) Deref() {
	if x.ref215fc78c == nil {
		return
	}
	x.Inner = *(*[96]byte)(unsafe.Pointer(&x.ref215fc78c.inner))
}

// allocFilHashResponseMemory allocates memory for type C.fil_HashResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilHashResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilHashResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilHashResponseValue = unsafe.Sizeof([1]C.fil_HashResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilHashResponse) Ref() *C.fil_HashResponse {
	if x == nil {
		return nil
	}
	return x.refc52a22ef
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilHashResponse) Free() {
	if x != nil && x.allocsc52a22ef != nil {
		x.allocsc52a22ef.(*cgoAllocMap).Free()
		x.refc52a22ef = nil
	}
}

// NewFilHashResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilHashResponseRef(ref unsafe.Pointer) *FilHashResponse {
	if ref == nil {
		return nil
	}
	obj := new(FilHashResponse)
	obj.refc52a22ef = (*C.fil_HashResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilHashResponse) PassRef() (*C.fil_HashResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc52a22ef != nil {
		return x.refc52a22ef, nil
	}
	memc52a22ef := allocFilHashResponseMemory(1)
	refc52a22ef := (*C.fil_HashResponse)(memc52a22ef)
	allocsc52a22ef := new(cgoAllocMap)
	allocsc52a22ef.Add(memc52a22ef)

	var cdigest_allocs *cgoAllocMap
	refc52a22ef.digest, cdigest_allocs = x.Digest.PassValue()
	allocsc52a22ef.Borrow(cdigest_allocs)

	x.refc52a22ef = refc52a22ef
	x.allocsc52a22ef = allocsc52a22ef
	return refc52a22ef, allocsc52a22ef

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilHashResponse) PassValue() (C.fil_HashResponse, *cgoAllocMap) {
	if x.refc52a22ef != nil {
		return *x.refc52a22ef, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilHashResponse) Deref() {
	if x.refc52a22ef == nil {
		return
	}
	x.Digest = *NewFilBLSDigestRef(unsafe.Pointer(&x.refc52a22ef.digest))
}

// allocFilBLSSignatureMemory allocates memory for type C.fil_BLSSignature in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilBLSSignatureMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilBLSSignatureValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilBLSSignatureValue = unsafe.Sizeof([1]C.fil_BLSSignature{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilBLSSignature) Ref() *C.fil_BLSSignature {
	if x == nil {
		return nil
	}
	return x.refa2ac09ba
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilBLSSignature) Free() {
	if x != nil && x.allocsa2ac09ba != nil {
		x.allocsa2ac09ba.(*cgoAllocMap).Free()
		x.refa2ac09ba = nil
	}
}

// NewFilBLSSignatureRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilBLSSignatureRef(ref unsafe.Pointer) *FilBLSSignature {
	if ref == nil {
		return nil
	}
	obj := new(FilBLSSignature)
	obj.refa2ac09ba = (*C.fil_BLSSignature)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilBLSSignature) PassRef() (*C.fil_BLSSignature, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa2ac09ba != nil {
		return x.refa2ac09ba, nil
	}
	mema2ac09ba := allocFilBLSSignatureMemory(1)
	refa2ac09ba := (*C.fil_BLSSignature)(mema2ac09ba)
	allocsa2ac09ba := new(cgoAllocMap)
	allocsa2ac09ba.Add(mema2ac09ba)

	var cinner_allocs *cgoAllocMap
	refa2ac09ba.inner, cinner_allocs = *(*[96]C.uint8_t)(unsafe.Pointer(&x.Inner)), cgoAllocsUnknown
	allocsa2ac09ba.Borrow(cinner_allocs)

	x.refa2ac09ba = refa2ac09ba
	x.allocsa2ac09ba = allocsa2ac09ba
	return refa2ac09ba, allocsa2ac09ba

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilBLSSignature) PassValue() (C.fil_BLSSignature, *cgoAllocMap) {
	if x.refa2ac09ba != nil {
		return *x.refa2ac09ba, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilBLSSignature) Deref() {
	if x.refa2ac09ba == nil {
		return
	}
	x.Inner = *(*[96]byte)(unsafe.Pointer(&x.refa2ac09ba.inner))
}

// allocFilAggregateResponseMemory allocates memory for type C.fil_AggregateResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilAggregateResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilAggregateResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilAggregateResponseValue = unsafe.Sizeof([1]C.fil_AggregateResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilAggregateResponse) Ref() *C.fil_AggregateResponse {
	if x == nil {
		return nil
	}
	return x.refb3efa36d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilAggregateResponse) Free() {
	if x != nil && x.allocsb3efa36d != nil {
		x.allocsb3efa36d.(*cgoAllocMap).Free()
		x.refb3efa36d = nil
	}
}

// NewFilAggregateResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilAggregateResponseRef(ref unsafe.Pointer) *FilAggregateResponse {
	if ref == nil {
		return nil
	}
	obj := new(FilAggregateResponse)
	obj.refb3efa36d = (*C.fil_AggregateResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilAggregateResponse) PassRef() (*C.fil_AggregateResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb3efa36d != nil {
		return x.refb3efa36d, nil
	}
	memb3efa36d := allocFilAggregateResponseMemory(1)
	refb3efa36d := (*C.fil_AggregateResponse)(memb3efa36d)
	allocsb3efa36d := new(cgoAllocMap)
	allocsb3efa36d.Add(memb3efa36d)

	var csignature_allocs *cgoAllocMap
	refb3efa36d.signature, csignature_allocs = x.Signature.PassValue()
	allocsb3efa36d.Borrow(csignature_allocs)

	x.refb3efa36d = refb3efa36d
	x.allocsb3efa36d = allocsb3efa36d
	return refb3efa36d, allocsb3efa36d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilAggregateResponse) PassValue() (C.fil_AggregateResponse, *cgoAllocMap) {
	if x.refb3efa36d != nil {
		return *x.refb3efa36d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilAggregateResponse) Deref() {
	if x.refb3efa36d == nil {
		return
	}
	x.Signature = *NewFilBLSSignatureRef(unsafe.Pointer(&x.refb3efa36d.signature))
}

// allocFilBLSPrivateKeyMemory allocates memory for type C.fil_BLSPrivateKey in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilBLSPrivateKeyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilBLSPrivateKeyValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilBLSPrivateKeyValue = unsafe.Sizeof([1]C.fil_BLSPrivateKey{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilBLSPrivateKey) Ref() *C.fil_BLSPrivateKey {
	if x == nil {
		return nil
	}
	return x.ref2f77fe3a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilBLSPrivateKey) Free() {
	if x != nil && x.allocs2f77fe3a != nil {
		x.allocs2f77fe3a.(*cgoAllocMap).Free()
		x.ref2f77fe3a = nil
	}
}

// NewFilBLSPrivateKeyRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilBLSPrivateKeyRef(ref unsafe.Pointer) *FilBLSPrivateKey {
	if ref == nil {
		return nil
	}
	obj := new(FilBLSPrivateKey)
	obj.ref2f77fe3a = (*C.fil_BLSPrivateKey)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilBLSPrivateKey) PassRef() (*C.fil_BLSPrivateKey, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2f77fe3a != nil {
		return x.ref2f77fe3a, nil
	}
	mem2f77fe3a := allocFilBLSPrivateKeyMemory(1)
	ref2f77fe3a := (*C.fil_BLSPrivateKey)(mem2f77fe3a)
	allocs2f77fe3a := new(cgoAllocMap)
	allocs2f77fe3a.Add(mem2f77fe3a)

	var cinner_allocs *cgoAllocMap
	ref2f77fe3a.inner, cinner_allocs = *(*[32]C.uint8_t)(unsafe.Pointer(&x.Inner)), cgoAllocsUnknown
	allocs2f77fe3a.Borrow(cinner_allocs)

	x.ref2f77fe3a = ref2f77fe3a
	x.allocs2f77fe3a = allocs2f77fe3a
	return ref2f77fe3a, allocs2f77fe3a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilBLSPrivateKey) PassValue() (C.fil_BLSPrivateKey, *cgoAllocMap) {
	if x.ref2f77fe3a != nil {
		return *x.ref2f77fe3a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilBLSPrivateKey) Deref() {
	if x.ref2f77fe3a == nil {
		return
	}
	x.Inner = *(*[32]byte)(unsafe.Pointer(&x.ref2f77fe3a.inner))
}

// allocFilPrivateKeyGenerateResponseMemory allocates memory for type C.fil_PrivateKeyGenerateResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilPrivateKeyGenerateResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilPrivateKeyGenerateResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilPrivateKeyGenerateResponseValue = unsafe.Sizeof([1]C.fil_PrivateKeyGenerateResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilPrivateKeyGenerateResponse) Ref() *C.fil_PrivateKeyGenerateResponse {
	if x == nil {
		return nil
	}
	return x.ref2dba09f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilPrivateKeyGenerateResponse) Free() {
	if x != nil && x.allocs2dba09f != nil {
		x.allocs2dba09f.(*cgoAllocMap).Free()
		x.ref2dba09f = nil
	}
}

// NewFilPrivateKeyGenerateResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilPrivateKeyGenerateResponseRef(ref unsafe.Pointer) *FilPrivateKeyGenerateResponse {
	if ref == nil {
		return nil
	}
	obj := new(FilPrivateKeyGenerateResponse)
	obj.ref2dba09f = (*C.fil_PrivateKeyGenerateResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilPrivateKeyGenerateResponse) PassRef() (*C.fil_PrivateKeyGenerateResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2dba09f != nil {
		return x.ref2dba09f, nil
	}
	mem2dba09f := allocFilPrivateKeyGenerateResponseMemory(1)
	ref2dba09f := (*C.fil_PrivateKeyGenerateResponse)(mem2dba09f)
	allocs2dba09f := new(cgoAllocMap)
	allocs2dba09f.Add(mem2dba09f)

	var cprivate_key_allocs *cgoAllocMap
	ref2dba09f.private_key, cprivate_key_allocs = x.PrivateKey.PassValue()
	allocs2dba09f.Borrow(cprivate_key_allocs)

	x.ref2dba09f = ref2dba09f
	x.allocs2dba09f = allocs2dba09f
	return ref2dba09f, allocs2dba09f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilPrivateKeyGenerateResponse) PassValue() (C.fil_PrivateKeyGenerateResponse, *cgoAllocMap) {
	if x.ref2dba09f != nil {
		return *x.ref2dba09f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilPrivateKeyGenerateResponse) Deref() {
	if x.ref2dba09f == nil {
		return
	}
	x.PrivateKey = *NewFilBLSPrivateKeyRef(unsafe.Pointer(&x.ref2dba09f.private_key))
}

// allocFilByteArray32Memory allocates memory for type C.fil_ByteArray32 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilByteArray32Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilByteArray32Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilByteArray32Value = unsafe.Sizeof([1]C.fil_ByteArray32{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilByteArray32) Ref() *C.fil_ByteArray32 {
	if x == nil {
		return nil
	}
	return x.ref3d84e09c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilByteArray32) Free() {
	if x != nil && x.allocs3d84e09c != nil {
		x.allocs3d84e09c.(*cgoAllocMap).Free()
		x.ref3d84e09c = nil
	}
}

// NewFilByteArray32Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilByteArray32Ref(ref unsafe.Pointer) *FilByteArray32 {
	if ref == nil {
		return nil
	}
	obj := new(FilByteArray32)
	obj.ref3d84e09c = (*C.fil_ByteArray32)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilByteArray32) PassRef() (*C.fil_ByteArray32, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3d84e09c != nil {
		return x.ref3d84e09c, nil
	}
	mem3d84e09c := allocFilByteArray32Memory(1)
	ref3d84e09c := (*C.fil_ByteArray32)(mem3d84e09c)
	allocs3d84e09c := new(cgoAllocMap)
	allocs3d84e09c.Add(mem3d84e09c)

	var cinner_allocs *cgoAllocMap
	ref3d84e09c.inner, cinner_allocs = *(*[32]C.uint8_t)(unsafe.Pointer(&x.Inner)), cgoAllocsUnknown
	allocs3d84e09c.Borrow(cinner_allocs)

	x.ref3d84e09c = ref3d84e09c
	x.allocs3d84e09c = allocs3d84e09c
	return ref3d84e09c, allocs3d84e09c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilByteArray32) PassValue() (C.fil_ByteArray32, *cgoAllocMap) {
	if x.ref3d84e09c != nil {
		return *x.ref3d84e09c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilByteArray32) Deref() {
	if x.ref3d84e09c == nil {
		return
	}
	x.Inner = *(*[32]byte)(unsafe.Pointer(&x.ref3d84e09c.inner))
}

// allocFilPrivateKeySignResponseMemory allocates memory for type C.fil_PrivateKeySignResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilPrivateKeySignResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilPrivateKeySignResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilPrivateKeySignResponseValue = unsafe.Sizeof([1]C.fil_PrivateKeySignResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilPrivateKeySignResponse) Ref() *C.fil_PrivateKeySignResponse {
	if x == nil {
		return nil
	}
	return x.refcdf97b28
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilPrivateKeySignResponse) Free() {
	if x != nil && x.allocscdf97b28 != nil {
		x.allocscdf97b28.(*cgoAllocMap).Free()
		x.refcdf97b28 = nil
	}
}

// NewFilPrivateKeySignResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilPrivateKeySignResponseRef(ref unsafe.Pointer) *FilPrivateKeySignResponse {
	if ref == nil {
		return nil
	}
	obj := new(FilPrivateKeySignResponse)
	obj.refcdf97b28 = (*C.fil_PrivateKeySignResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilPrivateKeySignResponse) PassRef() (*C.fil_PrivateKeySignResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refcdf97b28 != nil {
		return x.refcdf97b28, nil
	}
	memcdf97b28 := allocFilPrivateKeySignResponseMemory(1)
	refcdf97b28 := (*C.fil_PrivateKeySignResponse)(memcdf97b28)
	allocscdf97b28 := new(cgoAllocMap)
	allocscdf97b28.Add(memcdf97b28)

	var csignature_allocs *cgoAllocMap
	refcdf97b28.signature, csignature_allocs = x.Signature.PassValue()
	allocscdf97b28.Borrow(csignature_allocs)

	x.refcdf97b28 = refcdf97b28
	x.allocscdf97b28 = allocscdf97b28
	return refcdf97b28, allocscdf97b28

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilPrivateKeySignResponse) PassValue() (C.fil_PrivateKeySignResponse, *cgoAllocMap) {
	if x.refcdf97b28 != nil {
		return *x.refcdf97b28, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilPrivateKeySignResponse) Deref() {
	if x.refcdf97b28 == nil {
		return
	}
	x.Signature = *NewFilBLSSignatureRef(unsafe.Pointer(&x.refcdf97b28.signature))
}

// allocFilBLSPublicKeyMemory allocates memory for type C.fil_BLSPublicKey in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilBLSPublicKeyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilBLSPublicKeyValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilBLSPublicKeyValue = unsafe.Sizeof([1]C.fil_BLSPublicKey{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilBLSPublicKey) Ref() *C.fil_BLSPublicKey {
	if x == nil {
		return nil
	}
	return x.ref6d0cab13
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilBLSPublicKey) Free() {
	if x != nil && x.allocs6d0cab13 != nil {
		x.allocs6d0cab13.(*cgoAllocMap).Free()
		x.ref6d0cab13 = nil
	}
}

// NewFilBLSPublicKeyRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilBLSPublicKeyRef(ref unsafe.Pointer) *FilBLSPublicKey {
	if ref == nil {
		return nil
	}
	obj := new(FilBLSPublicKey)
	obj.ref6d0cab13 = (*C.fil_BLSPublicKey)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilBLSPublicKey) PassRef() (*C.fil_BLSPublicKey, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6d0cab13 != nil {
		return x.ref6d0cab13, nil
	}
	mem6d0cab13 := allocFilBLSPublicKeyMemory(1)
	ref6d0cab13 := (*C.fil_BLSPublicKey)(mem6d0cab13)
	allocs6d0cab13 := new(cgoAllocMap)
	allocs6d0cab13.Add(mem6d0cab13)

	var cinner_allocs *cgoAllocMap
	ref6d0cab13.inner, cinner_allocs = *(*[48]C.uint8_t)(unsafe.Pointer(&x.Inner)), cgoAllocsUnknown
	allocs6d0cab13.Borrow(cinner_allocs)

	x.ref6d0cab13 = ref6d0cab13
	x.allocs6d0cab13 = allocs6d0cab13
	return ref6d0cab13, allocs6d0cab13

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilBLSPublicKey) PassValue() (C.fil_BLSPublicKey, *cgoAllocMap) {
	if x.ref6d0cab13 != nil {
		return *x.ref6d0cab13, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilBLSPublicKey) Deref() {
	if x.ref6d0cab13 == nil {
		return
	}
	x.Inner = *(*[48]byte)(unsafe.Pointer(&x.ref6d0cab13.inner))
}

// allocFilPrivateKeyPublicKeyResponseMemory allocates memory for type C.fil_PrivateKeyPublicKeyResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilPrivateKeyPublicKeyResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilPrivateKeyPublicKeyResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilPrivateKeyPublicKeyResponseValue = unsafe.Sizeof([1]C.fil_PrivateKeyPublicKeyResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilPrivateKeyPublicKeyResponse) Ref() *C.fil_PrivateKeyPublicKeyResponse {
	if x == nil {
		return nil
	}
	return x.refee14e59d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilPrivateKeyPublicKeyResponse) Free() {
	if x != nil && x.allocsee14e59d != nil {
		x.allocsee14e59d.(*cgoAllocMap).Free()
		x.refee14e59d = nil
	}
}

// NewFilPrivateKeyPublicKeyResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilPrivateKeyPublicKeyResponseRef(ref unsafe.Pointer) *FilPrivateKeyPublicKeyResponse {
	if ref == nil {
		return nil
	}
	obj := new(FilPrivateKeyPublicKeyResponse)
	obj.refee14e59d = (*C.fil_PrivateKeyPublicKeyResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilPrivateKeyPublicKeyResponse) PassRef() (*C.fil_PrivateKeyPublicKeyResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refee14e59d != nil {
		return x.refee14e59d, nil
	}
	memee14e59d := allocFilPrivateKeyPublicKeyResponseMemory(1)
	refee14e59d := (*C.fil_PrivateKeyPublicKeyResponse)(memee14e59d)
	allocsee14e59d := new(cgoAllocMap)
	allocsee14e59d.Add(memee14e59d)

	var cpublic_key_allocs *cgoAllocMap
	refee14e59d.public_key, cpublic_key_allocs = x.PublicKey.PassValue()
	allocsee14e59d.Borrow(cpublic_key_allocs)

	x.refee14e59d = refee14e59d
	x.allocsee14e59d = allocsee14e59d
	return refee14e59d, allocsee14e59d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilPrivateKeyPublicKeyResponse) PassValue() (C.fil_PrivateKeyPublicKeyResponse, *cgoAllocMap) {
	if x.refee14e59d != nil {
		return *x.refee14e59d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilPrivateKeyPublicKeyResponse) Deref() {
	if x.refee14e59d == nil {
		return
	}
	x.PublicKey = *NewFilBLSPublicKeyRef(unsafe.Pointer(&x.refee14e59d.public_key))
}

// allocFilZeroSignatureResponseMemory allocates memory for type C.fil_ZeroSignatureResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilZeroSignatureResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilZeroSignatureResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilZeroSignatureResponseValue = unsafe.Sizeof([1]C.fil_ZeroSignatureResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilZeroSignatureResponse) Ref() *C.fil_ZeroSignatureResponse {
	if x == nil {
		return nil
	}
	return x.ref835a0405
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilZeroSignatureResponse) Free() {
	if x != nil && x.allocs835a0405 != nil {
		x.allocs835a0405.(*cgoAllocMap).Free()
		x.ref835a0405 = nil
	}
}

// NewFilZeroSignatureResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilZeroSignatureResponseRef(ref unsafe.Pointer) *FilZeroSignatureResponse {
	if ref == nil {
		return nil
	}
	obj := new(FilZeroSignatureResponse)
	obj.ref835a0405 = (*C.fil_ZeroSignatureResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilZeroSignatureResponse) PassRef() (*C.fil_ZeroSignatureResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref835a0405 != nil {
		return x.ref835a0405, nil
	}
	mem835a0405 := allocFilZeroSignatureResponseMemory(1)
	ref835a0405 := (*C.fil_ZeroSignatureResponse)(mem835a0405)
	allocs835a0405 := new(cgoAllocMap)
	allocs835a0405.Add(mem835a0405)

	var csignature_allocs *cgoAllocMap
	ref835a0405.signature, csignature_allocs = x.Signature.PassValue()
	allocs835a0405.Borrow(csignature_allocs)

	x.ref835a0405 = ref835a0405
	x.allocs835a0405 = allocs835a0405
	return ref835a0405, allocs835a0405

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilZeroSignatureResponse) PassValue() (C.fil_ZeroSignatureResponse, *cgoAllocMap) {
	if x.ref835a0405 != nil {
		return *x.ref835a0405, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilZeroSignatureResponse) Deref() {
	if x.ref835a0405 == nil {
		return
	}
	x.Signature = *NewFilBLSSignatureRef(unsafe.Pointer(&x.ref835a0405.signature))
}

// allocFilArrayU8Memory allocates memory for type C.fil_Array_u8 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilArrayU8Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilArrayU8Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilArrayU8Value = unsafe.Sizeof([1]C.fil_Array_u8{})

type sliceHeader struct {
	Data unsafe.Pointer
	Len  int
	Cap  int
}

// allocPUint8TMemory allocates memory for type *C.uint8_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPUint8TMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPUint8TValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPUint8TValue = unsafe.Sizeof([1]*C.uint8_t{})

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// unpackSSByte transforms a sliced Go data structure into plain C format.
func unpackSSByte(x [][]byte) (unpacked **C.uint8_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPUint8TMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.uint8_t)(unsafe.Pointer(h0))
	for i0 := range x {
		h := (*sliceHeader)(unsafe.Pointer(&x[i0]))
		v0[i0] = (*C.uint8_t)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.uint8_t)(h.Data)
	return
}

// packSSByte reads sliced Go data structure out from plain C format.
func packSSByte(v [][]byte, ptr0 **C.uint8_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.uint8_t)(unsafe.Pointer(ptr0)))[i0]
		hxfc4425b := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxfc4425b.Data = unsafe.Pointer(ptr1)
		hxfc4425b.Cap = 0x7fffffff
		// hxfc4425b.Len = ?
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilArrayU8) Ref() *C.fil_Array_u8 {
	if x == nil {
		return nil
	}
	return x.ref86f68f93
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilArrayU8) Free() {
	if x != nil && x.allocs86f68f93 != nil {
		x.allocs86f68f93.(*cgoAllocMap).Free()
		x.ref86f68f93 = nil
	}
}

// NewFilArrayU8Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilArrayU8Ref(ref unsafe.Pointer) *FilArrayU8 {
	if ref == nil {
		return nil
	}
	obj := new(FilArrayU8)
	obj.ref86f68f93 = (*C.fil_Array_u8)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilArrayU8) PassRef() (*C.fil_Array_u8, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref86f68f93 != nil {
		return x.ref86f68f93, nil
	}
	mem86f68f93 := allocFilArrayU8Memory(1)
	ref86f68f93 := (*C.fil_Array_u8)(mem86f68f93)
	allocs86f68f93 := new(cgoAllocMap)
	allocs86f68f93.Add(mem86f68f93)

	var cptr_allocs *cgoAllocMap
	ref86f68f93.ptr, cptr_allocs = unpackSSByte(x.Ptr)
	allocs86f68f93.Borrow(cptr_allocs)

	var clen_allocs *cgoAllocMap
	ref86f68f93.len, clen_allocs = (C.uintptr_t)(x.Len), cgoAllocsUnknown
	allocs86f68f93.Borrow(clen_allocs)

	x.ref86f68f93 = ref86f68f93
	x.allocs86f68f93 = allocs86f68f93
	return ref86f68f93, allocs86f68f93

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilArrayU8) PassValue() (C.fil_Array_u8, *cgoAllocMap) {
	if x.ref86f68f93 != nil {
		return *x.ref86f68f93, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilArrayU8) Deref() {
	if x.ref86f68f93 == nil {
		return
	}
	packSSByte(x.Ptr, x.ref86f68f93.ptr)
	x.Len = (uint64)(x.ref86f68f93.len)
}

// allocFilBytesMemory allocates memory for type C.fil_Bytes in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilBytesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilBytesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilBytesValue = unsafe.Sizeof([1]C.fil_Bytes{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilBytes) Ref() *C.fil_Bytes {
	if x == nil {
		return nil
	}
	return x.ref1605074
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilBytes) Free() {
	if x != nil && x.allocs1605074 != nil {
		x.allocs1605074.(*cgoAllocMap).Free()
		x.ref1605074 = nil
	}
}

// NewFilBytesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilBytesRef(ref unsafe.Pointer) *FilBytes {
	if ref == nil {
		return nil
	}
	obj := new(FilBytes)
	obj.ref1605074 = (*C.fil_Bytes)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilBytes) PassRef() (*C.fil_Bytes, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1605074 != nil {
		return x.ref1605074, nil
	}
	mem1605074 := allocFilBytesMemory(1)
	ref1605074 := (*C.fil_Bytes)(mem1605074)
	allocs1605074 := new(cgoAllocMap)
	allocs1605074.Add(mem1605074)

	var cptr_allocs *cgoAllocMap
	ref1605074.ptr, cptr_allocs = unpackSSByte(x.Ptr)
	allocs1605074.Borrow(cptr_allocs)

	var clen_allocs *cgoAllocMap
	ref1605074.len, clen_allocs = (C.uintptr_t)(x.Len), cgoAllocsUnknown
	allocs1605074.Borrow(clen_allocs)

	x.ref1605074 = ref1605074
	x.allocs1605074 = allocs1605074
	return ref1605074, allocs1605074

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilBytes) PassValue() (C.fil_Bytes, *cgoAllocMap) {
	if x.ref1605074 != nil {
		return *x.ref1605074, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilBytes) Deref() {
	if x.ref1605074 == nil {
		return
	}
	packSSByte(x.Ptr, x.ref1605074.ptr)
	x.Len = (uint64)(x.ref1605074.len)
}

// allocFilWriteWithAlignmentMemory allocates memory for type C.fil_WriteWithAlignment in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilWriteWithAlignmentMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilWriteWithAlignmentValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilWriteWithAlignmentValue = unsafe.Sizeof([1]C.fil_WriteWithAlignment{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilWriteWithAlignment) Ref() *C.fil_WriteWithAlignment {
	if x == nil {
		return nil
	}
	return x.reffc1bd1
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilWriteWithAlignment) Free() {
	if x != nil && x.allocsfc1bd1 != nil {
		x.allocsfc1bd1.(*cgoAllocMap).Free()
		x.reffc1bd1 = nil
	}
}

// NewFilWriteWithAlignmentRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilWriteWithAlignmentRef(ref unsafe.Pointer) *FilWriteWithAlignment {
	if ref == nil {
		return nil
	}
	obj := new(FilWriteWithAlignment)
	obj.reffc1bd1 = (*C.fil_WriteWithAlignment)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilWriteWithAlignment) PassRef() (*C.fil_WriteWithAlignment, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffc1bd1 != nil {
		return x.reffc1bd1, nil
	}
	memfc1bd1 := allocFilWriteWithAlignmentMemory(1)
	reffc1bd1 := (*C.fil_WriteWithAlignment)(memfc1bd1)
	allocsfc1bd1 := new(cgoAllocMap)
	allocsfc1bd1.Add(memfc1bd1)

	var ccomm_p_allocs *cgoAllocMap
	reffc1bd1.comm_p, ccomm_p_allocs = *(*[32]C.uint8_t)(unsafe.Pointer(&x.CommP)), cgoAllocsUnknown
	allocsfc1bd1.Borrow(ccomm_p_allocs)

	var cleft_alignment_unpadded_allocs *cgoAllocMap
	reffc1bd1.left_alignment_unpadded, cleft_alignment_unpadded_allocs = (C.uint64_t)(x.LeftAlignmentUnpadded), cgoAllocsUnknown
	allocsfc1bd1.Borrow(cleft_alignment_unpadded_allocs)

	var ctotal_write_unpadded_allocs *cgoAllocMap
	reffc1bd1.total_write_unpadded, ctotal_write_unpadded_allocs = (C.uint64_t)(x.TotalWriteUnpadded), cgoAllocsUnknown
	allocsfc1bd1.Borrow(ctotal_write_unpadded_allocs)

	x.reffc1bd1 = reffc1bd1
	x.allocsfc1bd1 = allocsfc1bd1
	return reffc1bd1, allocsfc1bd1

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilWriteWithAlignment) PassValue() (C.fil_WriteWithAlignment, *cgoAllocMap) {
	if x.reffc1bd1 != nil {
		return *x.reffc1bd1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilWriteWithAlignment) Deref() {
	if x.reffc1bd1 == nil {
		return
	}
	x.CommP = *(*[32]byte)(unsafe.Pointer(&x.reffc1bd1.comm_p))
	x.LeftAlignmentUnpadded = (uint64)(x.reffc1bd1.left_alignment_unpadded)
	x.TotalWriteUnpadded = (uint64)(x.reffc1bd1.total_write_unpadded)
}

// allocFilResultWriteWithAlignmentMemory allocates memory for type C.fil_Result_WriteWithAlignment in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilResultWriteWithAlignmentMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilResultWriteWithAlignmentValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilResultWriteWithAlignmentValue = unsafe.Sizeof([1]C.fil_Result_WriteWithAlignment{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilResultWriteWithAlignment) Ref() *C.fil_Result_WriteWithAlignment {
	if x == nil {
		return nil
	}
	return x.refc8fc94a1
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilResultWriteWithAlignment) Free() {
	if x != nil && x.allocsc8fc94a1 != nil {
		x.allocsc8fc94a1.(*cgoAllocMap).Free()
		x.refc8fc94a1 = nil
	}
}

// NewFilResultWriteWithAlignmentRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilResultWriteWithAlignmentRef(ref unsafe.Pointer) *FilResultWriteWithAlignment {
	if ref == nil {
		return nil
	}
	obj := new(FilResultWriteWithAlignment)
	obj.refc8fc94a1 = (*C.fil_Result_WriteWithAlignment)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilResultWriteWithAlignment) PassRef() (*C.fil_Result_WriteWithAlignment, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc8fc94a1 != nil {
		return x.refc8fc94a1, nil
	}
	memc8fc94a1 := allocFilResultWriteWithAlignmentMemory(1)
	refc8fc94a1 := (*C.fil_Result_WriteWithAlignment)(memc8fc94a1)
	allocsc8fc94a1 := new(cgoAllocMap)
	allocsc8fc94a1.Add(memc8fc94a1)

	var cstatus_code_allocs *cgoAllocMap
	refc8fc94a1.status_code, cstatus_code_allocs = (C.fil_FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocsc8fc94a1.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	refc8fc94a1.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocsc8fc94a1.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	refc8fc94a1.value, cvalue_allocs = x.Value.PassValue()
	allocsc8fc94a1.Borrow(cvalue_allocs)

	x.refc8fc94a1 = refc8fc94a1
	x.allocsc8fc94a1 = allocsc8fc94a1
	return refc8fc94a1, allocsc8fc94a1

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilResultWriteWithAlignment) PassValue() (C.fil_Result_WriteWithAlignment, *cgoAllocMap) {
	if x.refc8fc94a1 != nil {
		return *x.refc8fc94a1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilResultWriteWithAlignment) Deref() {
	if x.refc8fc94a1 == nil {
		return
	}
	x.StatusCode = (FilFCPResponseStatus)(x.refc8fc94a1.status_code)
	x.ErrorMsg = *NewFilBytesRef(unsafe.Pointer(&x.refc8fc94a1.error_msg))
	x.Value = *NewFilWriteWithAlignmentRef(unsafe.Pointer(&x.refc8fc94a1.value))
}

// allocFilWriteWithAlignmentResponseMemory allocates memory for type C.fil_WriteWithAlignmentResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilWriteWithAlignmentResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilWriteWithAlignmentResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilWriteWithAlignmentResponseValue = unsafe.Sizeof([1]C.fil_WriteWithAlignmentResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilWriteWithAlignmentResponse) Ref() *C.fil_WriteWithAlignmentResponse {
	if x == nil {
		return nil
	}
	return x.refa330e79
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilWriteWithAlignmentResponse) Free() {
	if x != nil && x.allocsa330e79 != nil {
		x.allocsa330e79.(*cgoAllocMap).Free()
		x.refa330e79 = nil
	}
}

// NewFilWriteWithAlignmentResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilWriteWithAlignmentResponseRef(ref unsafe.Pointer) *FilWriteWithAlignmentResponse {
	if ref == nil {
		return nil
	}
	obj := new(FilWriteWithAlignmentResponse)
	obj.refa330e79 = (*C.fil_WriteWithAlignmentResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilWriteWithAlignmentResponse) PassRef() (*C.fil_WriteWithAlignmentResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa330e79 != nil {
		return x.refa330e79, nil
	}
	mema330e79 := allocFilWriteWithAlignmentResponseMemory(1)
	refa330e79 := (*C.fil_WriteWithAlignmentResponse)(mema330e79)
	allocsa330e79 := new(cgoAllocMap)
	allocsa330e79.Add(mema330e79)

	var cstatus_code_allocs *cgoAllocMap
	refa330e79.status_code, cstatus_code_allocs = (C.fil_FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocsa330e79.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	refa330e79.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocsa330e79.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	refa330e79.value, cvalue_allocs = x.Value.PassValue()
	allocsa330e79.Borrow(cvalue_allocs)

	x.refa330e79 = refa330e79
	x.allocsa330e79 = allocsa330e79
	return refa330e79, allocsa330e79

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilWriteWithAlignmentResponse) PassValue() (C.fil_WriteWithAlignmentResponse, *cgoAllocMap) {
	if x.refa330e79 != nil {
		return *x.refa330e79, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilWriteWithAlignmentResponse) Deref() {
	if x.refa330e79 == nil {
		return
	}
	x.StatusCode = (FilFCPResponseStatus)(x.refa330e79.status_code)
	x.ErrorMsg = *NewFilBytesRef(unsafe.Pointer(&x.refa330e79.error_msg))
	x.Value = *NewFilWriteWithAlignmentRef(unsafe.Pointer(&x.refa330e79.value))
}

// allocFilArrayU64Memory allocates memory for type C.fil_Array_u64 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilArrayU64Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilArrayU64Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilArrayU64Value = unsafe.Sizeof([1]C.fil_Array_u64{})

// allocPUint64TMemory allocates memory for type *C.uint64_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPUint64TMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPUint64TValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPUint64TValue = unsafe.Sizeof([1]*C.uint64_t{})

// unpackSSUUint64 transforms a sliced Go data structure into plain C format.
func unpackSSUUint64(x [][]uint64) (unpacked **C.uint64_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPUint64TMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.uint64_t)(unsafe.Pointer(h0))
	for i0 := range x {
		h := (*sliceHeader)(unsafe.Pointer(&x[i0]))
		v0[i0] = (*C.uint64_t)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.uint64_t)(h.Data)
	return
}

// packSSUUint64 reads sliced Go data structure out from plain C format.
func packSSUUint64(v [][]uint64, ptr0 **C.uint64_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.uint64_t)(unsafe.Pointer(ptr0)))[i0]
		hxff2234b := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxff2234b.Data = unsafe.Pointer(ptr1)
		hxff2234b.Cap = 0x7fffffff
		// hxff2234b.Len = ?
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilArrayU64) Ref() *C.fil_Array_u64 {
	if x == nil {
		return nil
	}
	return x.ref4b502c7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilArrayU64) Free() {
	if x != nil && x.allocs4b502c7 != nil {
		x.allocs4b502c7.(*cgoAllocMap).Free()
		x.ref4b502c7 = nil
	}
}

// NewFilArrayU64Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilArrayU64Ref(ref unsafe.Pointer) *FilArrayU64 {
	if ref == nil {
		return nil
	}
	obj := new(FilArrayU64)
	obj.ref4b502c7 = (*C.fil_Array_u64)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilArrayU64) PassRef() (*C.fil_Array_u64, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4b502c7 != nil {
		return x.ref4b502c7, nil
	}
	mem4b502c7 := allocFilArrayU64Memory(1)
	ref4b502c7 := (*C.fil_Array_u64)(mem4b502c7)
	allocs4b502c7 := new(cgoAllocMap)
	allocs4b502c7.Add(mem4b502c7)

	var cptr_allocs *cgoAllocMap
	ref4b502c7.ptr, cptr_allocs = unpackSSUUint64(x.Ptr)
	allocs4b502c7.Borrow(cptr_allocs)

	var clen_allocs *cgoAllocMap
	ref4b502c7.len, clen_allocs = (C.uintptr_t)(x.Len), cgoAllocsUnknown
	allocs4b502c7.Borrow(clen_allocs)

	x.ref4b502c7 = ref4b502c7
	x.allocs4b502c7 = allocs4b502c7
	return ref4b502c7, allocs4b502c7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilArrayU64) PassValue() (C.fil_Array_u64, *cgoAllocMap) {
	if x.ref4b502c7 != nil {
		return *x.ref4b502c7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilArrayU64) Deref() {
	if x.ref4b502c7 == nil {
		return
	}
	packSSUUint64(x.Ptr, x.ref4b502c7.ptr)
	x.Len = (uint64)(x.ref4b502c7.len)
}

// allocFilWriteWithoutAlignmentMemory allocates memory for type C.fil_WriteWithoutAlignment in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilWriteWithoutAlignmentMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilWriteWithoutAlignmentValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilWriteWithoutAlignmentValue = unsafe.Sizeof([1]C.fil_WriteWithoutAlignment{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilWriteWithoutAlignment) Ref() *C.fil_WriteWithoutAlignment {
	if x == nil {
		return nil
	}
	return x.ref5d8e90d6
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilWriteWithoutAlignment) Free() {
	if x != nil && x.allocs5d8e90d6 != nil {
		x.allocs5d8e90d6.(*cgoAllocMap).Free()
		x.ref5d8e90d6 = nil
	}
}

// NewFilWriteWithoutAlignmentRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilWriteWithoutAlignmentRef(ref unsafe.Pointer) *FilWriteWithoutAlignment {
	if ref == nil {
		return nil
	}
	obj := new(FilWriteWithoutAlignment)
	obj.ref5d8e90d6 = (*C.fil_WriteWithoutAlignment)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilWriteWithoutAlignment) PassRef() (*C.fil_WriteWithoutAlignment, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5d8e90d6 != nil {
		return x.ref5d8e90d6, nil
	}
	mem5d8e90d6 := allocFilWriteWithoutAlignmentMemory(1)
	ref5d8e90d6 := (*C.fil_WriteWithoutAlignment)(mem5d8e90d6)
	allocs5d8e90d6 := new(cgoAllocMap)
	allocs5d8e90d6.Add(mem5d8e90d6)

	var ccomm_p_allocs *cgoAllocMap
	ref5d8e90d6.comm_p, ccomm_p_allocs = *(*[32]C.uint8_t)(unsafe.Pointer(&x.CommP)), cgoAllocsUnknown
	allocs5d8e90d6.Borrow(ccomm_p_allocs)

	var ctotal_write_unpadded_allocs *cgoAllocMap
	ref5d8e90d6.total_write_unpadded, ctotal_write_unpadded_allocs = (C.uint64_t)(x.TotalWriteUnpadded), cgoAllocsUnknown
	allocs5d8e90d6.Borrow(ctotal_write_unpadded_allocs)

	x.ref5d8e90d6 = ref5d8e90d6
	x.allocs5d8e90d6 = allocs5d8e90d6
	return ref5d8e90d6, allocs5d8e90d6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilWriteWithoutAlignment) PassValue() (C.fil_WriteWithoutAlignment, *cgoAllocMap) {
	if x.ref5d8e90d6 != nil {
		return *x.ref5d8e90d6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilWriteWithoutAlignment) Deref() {
	if x.ref5d8e90d6 == nil {
		return
	}
	x.CommP = *(*[32]byte)(unsafe.Pointer(&x.ref5d8e90d6.comm_p))
	x.TotalWriteUnpadded = (uint64)(x.ref5d8e90d6.total_write_unpadded)
}

// allocFilResultWriteWithoutAlignmentMemory allocates memory for type C.fil_Result_WriteWithoutAlignment in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilResultWriteWithoutAlignmentMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilResultWriteWithoutAlignmentValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilResultWriteWithoutAlignmentValue = unsafe.Sizeof([1]C.fil_Result_WriteWithoutAlignment{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilResultWriteWithoutAlignment) Ref() *C.fil_Result_WriteWithoutAlignment {
	if x == nil {
		return nil
	}
	return x.refb5647cca
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilResultWriteWithoutAlignment) Free() {
	if x != nil && x.allocsb5647cca != nil {
		x.allocsb5647cca.(*cgoAllocMap).Free()
		x.refb5647cca = nil
	}
}

// NewFilResultWriteWithoutAlignmentRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilResultWriteWithoutAlignmentRef(ref unsafe.Pointer) *FilResultWriteWithoutAlignment {
	if ref == nil {
		return nil
	}
	obj := new(FilResultWriteWithoutAlignment)
	obj.refb5647cca = (*C.fil_Result_WriteWithoutAlignment)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilResultWriteWithoutAlignment) PassRef() (*C.fil_Result_WriteWithoutAlignment, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb5647cca != nil {
		return x.refb5647cca, nil
	}
	memb5647cca := allocFilResultWriteWithoutAlignmentMemory(1)
	refb5647cca := (*C.fil_Result_WriteWithoutAlignment)(memb5647cca)
	allocsb5647cca := new(cgoAllocMap)
	allocsb5647cca.Add(memb5647cca)

	var cstatus_code_allocs *cgoAllocMap
	refb5647cca.status_code, cstatus_code_allocs = (C.fil_FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocsb5647cca.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	refb5647cca.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocsb5647cca.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	refb5647cca.value, cvalue_allocs = x.Value.PassValue()
	allocsb5647cca.Borrow(cvalue_allocs)

	x.refb5647cca = refb5647cca
	x.allocsb5647cca = allocsb5647cca
	return refb5647cca, allocsb5647cca

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilResultWriteWithoutAlignment) PassValue() (C.fil_Result_WriteWithoutAlignment, *cgoAllocMap) {
	if x.refb5647cca != nil {
		return *x.refb5647cca, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilResultWriteWithoutAlignment) Deref() {
	if x.refb5647cca == nil {
		return
	}
	x.StatusCode = (FilFCPResponseStatus)(x.refb5647cca.status_code)
	x.ErrorMsg = *NewFilBytesRef(unsafe.Pointer(&x.refb5647cca.error_msg))
	x.Value = *NewFilWriteWithoutAlignmentRef(unsafe.Pointer(&x.refb5647cca.value))
}

// allocFilWriteWithoutAlignmentResponseMemory allocates memory for type C.fil_WriteWithoutAlignmentResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilWriteWithoutAlignmentResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilWriteWithoutAlignmentResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilWriteWithoutAlignmentResponseValue = unsafe.Sizeof([1]C.fil_WriteWithoutAlignmentResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilWriteWithoutAlignmentResponse) Ref() *C.fil_WriteWithoutAlignmentResponse {
	if x == nil {
		return nil
	}
	return x.refc8e1ed8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilWriteWithoutAlignmentResponse) Free() {
	if x != nil && x.allocsc8e1ed8 != nil {
		x.allocsc8e1ed8.(*cgoAllocMap).Free()
		x.refc8e1ed8 = nil
	}
}

// NewFilWriteWithoutAlignmentResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilWriteWithoutAlignmentResponseRef(ref unsafe.Pointer) *FilWriteWithoutAlignmentResponse {
	if ref == nil {
		return nil
	}
	obj := new(FilWriteWithoutAlignmentResponse)
	obj.refc8e1ed8 = (*C.fil_WriteWithoutAlignmentResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilWriteWithoutAlignmentResponse) PassRef() (*C.fil_WriteWithoutAlignmentResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc8e1ed8 != nil {
		return x.refc8e1ed8, nil
	}
	memc8e1ed8 := allocFilWriteWithoutAlignmentResponseMemory(1)
	refc8e1ed8 := (*C.fil_WriteWithoutAlignmentResponse)(memc8e1ed8)
	allocsc8e1ed8 := new(cgoAllocMap)
	allocsc8e1ed8.Add(memc8e1ed8)

	var cstatus_code_allocs *cgoAllocMap
	refc8e1ed8.status_code, cstatus_code_allocs = (C.fil_FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocsc8e1ed8.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	refc8e1ed8.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocsc8e1ed8.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	refc8e1ed8.value, cvalue_allocs = x.Value.PassValue()
	allocsc8e1ed8.Borrow(cvalue_allocs)

	x.refc8e1ed8 = refc8e1ed8
	x.allocsc8e1ed8 = allocsc8e1ed8
	return refc8e1ed8, allocsc8e1ed8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilWriteWithoutAlignmentResponse) PassValue() (C.fil_WriteWithoutAlignmentResponse, *cgoAllocMap) {
	if x.refc8e1ed8 != nil {
		return *x.refc8e1ed8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilWriteWithoutAlignmentResponse) Deref() {
	if x.refc8e1ed8 == nil {
		return
	}
	x.StatusCode = (FilFCPResponseStatus)(x.refc8e1ed8.status_code)
	x.ErrorMsg = *NewFilBytesRef(unsafe.Pointer(&x.refc8e1ed8.error_msg))
	x.Value = *NewFilWriteWithoutAlignmentRef(unsafe.Pointer(&x.refc8e1ed8.value))
}

// allocFilResultByteArray32Memory allocates memory for type C.fil_Result_ByteArray32 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilResultByteArray32Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilResultByteArray32Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilResultByteArray32Value = unsafe.Sizeof([1]C.fil_Result_ByteArray32{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilResultByteArray32) Ref() *C.fil_Result_ByteArray32 {
	if x == nil {
		return nil
	}
	return x.ref951fc2ba
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilResultByteArray32) Free() {
	if x != nil && x.allocs951fc2ba != nil {
		x.allocs951fc2ba.(*cgoAllocMap).Free()
		x.ref951fc2ba = nil
	}
}

// NewFilResultByteArray32Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilResultByteArray32Ref(ref unsafe.Pointer) *FilResultByteArray32 {
	if ref == nil {
		return nil
	}
	obj := new(FilResultByteArray32)
	obj.ref951fc2ba = (*C.fil_Result_ByteArray32)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilResultByteArray32) PassRef() (*C.fil_Result_ByteArray32, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref951fc2ba != nil {
		return x.ref951fc2ba, nil
	}
	mem951fc2ba := allocFilResultByteArray32Memory(1)
	ref951fc2ba := (*C.fil_Result_ByteArray32)(mem951fc2ba)
	allocs951fc2ba := new(cgoAllocMap)
	allocs951fc2ba.Add(mem951fc2ba)

	var cstatus_code_allocs *cgoAllocMap
	ref951fc2ba.status_code, cstatus_code_allocs = (C.fil_FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocs951fc2ba.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref951fc2ba.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocs951fc2ba.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	ref951fc2ba.value, cvalue_allocs = x.Value.PassValue()
	allocs951fc2ba.Borrow(cvalue_allocs)

	x.ref951fc2ba = ref951fc2ba
	x.allocs951fc2ba = allocs951fc2ba
	return ref951fc2ba, allocs951fc2ba

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilResultByteArray32) PassValue() (C.fil_Result_ByteArray32, *cgoAllocMap) {
	if x.ref951fc2ba != nil {
		return *x.ref951fc2ba, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilResultByteArray32) Deref() {
	if x.ref951fc2ba == nil {
		return
	}
	x.StatusCode = (FilFCPResponseStatus)(x.ref951fc2ba.status_code)
	x.ErrorMsg = *NewFilBytesRef(unsafe.Pointer(&x.ref951fc2ba.error_msg))
	x.Value = *NewFilByteArray32Ref(unsafe.Pointer(&x.ref951fc2ba.value))
}

// allocFilFauxRepResponseMemory allocates memory for type C.fil_FauxRepResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilFauxRepResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilFauxRepResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilFauxRepResponseValue = unsafe.Sizeof([1]C.fil_FauxRepResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilFauxRepResponse) Ref() *C.fil_FauxRepResponse {
	if x == nil {
		return nil
	}
	return x.refaa003f71
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilFauxRepResponse) Free() {
	if x != nil && x.allocsaa003f71 != nil {
		x.allocsaa003f71.(*cgoAllocMap).Free()
		x.refaa003f71 = nil
	}
}

// NewFilFauxRepResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilFauxRepResponseRef(ref unsafe.Pointer) *FilFauxRepResponse {
	if ref == nil {
		return nil
	}
	obj := new(FilFauxRepResponse)
	obj.refaa003f71 = (*C.fil_FauxRepResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilFauxRepResponse) PassRef() (*C.fil_FauxRepResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refaa003f71 != nil {
		return x.refaa003f71, nil
	}
	memaa003f71 := allocFilFauxRepResponseMemory(1)
	refaa003f71 := (*C.fil_FauxRepResponse)(memaa003f71)
	allocsaa003f71 := new(cgoAllocMap)
	allocsaa003f71.Add(memaa003f71)

	var cstatus_code_allocs *cgoAllocMap
	refaa003f71.status_code, cstatus_code_allocs = (C.fil_FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocsaa003f71.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	refaa003f71.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocsaa003f71.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	refaa003f71.value, cvalue_allocs = x.Value.PassValue()
	allocsaa003f71.Borrow(cvalue_allocs)

	x.refaa003f71 = refaa003f71
	x.allocsaa003f71 = allocsaa003f71
	return refaa003f71, allocsaa003f71

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilFauxRepResponse) PassValue() (C.fil_FauxRepResponse, *cgoAllocMap) {
	if x.refaa003f71 != nil {
		return *x.refaa003f71, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilFauxRepResponse) Deref() {
	if x.refaa003f71 == nil {
		return
	}
	x.StatusCode = (FilFCPResponseStatus)(x.refaa003f71.status_code)
	x.ErrorMsg = *NewFilBytesRef(unsafe.Pointer(&x.refaa003f71.error_msg))
	x.Value = *NewFilByteArray32Ref(unsafe.Pointer(&x.refaa003f71.value))
}

// allocFilResultBytesMemory allocates memory for type C.fil_Result_Bytes in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilResultBytesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilResultBytesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilResultBytesValue = unsafe.Sizeof([1]C.fil_Result_Bytes{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilResultBytes) Ref() *C.fil_Result_Bytes {
	if x == nil {
		return nil
	}
	return x.refb8bd272b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilResultBytes) Free() {
	if x != nil && x.allocsb8bd272b != nil {
		x.allocsb8bd272b.(*cgoAllocMap).Free()
		x.refb8bd272b = nil
	}
}

// NewFilResultBytesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilResultBytesRef(ref unsafe.Pointer) *FilResultBytes {
	if ref == nil {
		return nil
	}
	obj := new(FilResultBytes)
	obj.refb8bd272b = (*C.fil_Result_Bytes)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilResultBytes) PassRef() (*C.fil_Result_Bytes, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb8bd272b != nil {
		return x.refb8bd272b, nil
	}
	memb8bd272b := allocFilResultBytesMemory(1)
	refb8bd272b := (*C.fil_Result_Bytes)(memb8bd272b)
	allocsb8bd272b := new(cgoAllocMap)
	allocsb8bd272b.Add(memb8bd272b)

	var cstatus_code_allocs *cgoAllocMap
	refb8bd272b.status_code, cstatus_code_allocs = (C.fil_FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocsb8bd272b.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	refb8bd272b.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocsb8bd272b.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	refb8bd272b.value, cvalue_allocs = x.Value.PassValue()
	allocsb8bd272b.Borrow(cvalue_allocs)

	x.refb8bd272b = refb8bd272b
	x.allocsb8bd272b = allocsb8bd272b
	return refb8bd272b, allocsb8bd272b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilResultBytes) PassValue() (C.fil_Result_Bytes, *cgoAllocMap) {
	if x.refb8bd272b != nil {
		return *x.refb8bd272b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilResultBytes) Deref() {
	if x.refb8bd272b == nil {
		return
	}
	x.StatusCode = (FilFCPResponseStatus)(x.refb8bd272b.status_code)
	x.ErrorMsg = *NewFilBytesRef(unsafe.Pointer(&x.refb8bd272b.error_msg))
	x.Value = *NewFilBytesRef(unsafe.Pointer(&x.refb8bd272b.value))
}

// allocFilSealPreCommitPhase1ResponseMemory allocates memory for type C.fil_SealPreCommitPhase1Response in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilSealPreCommitPhase1ResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilSealPreCommitPhase1ResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilSealPreCommitPhase1ResponseValue = unsafe.Sizeof([1]C.fil_SealPreCommitPhase1Response{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilSealPreCommitPhase1Response) Ref() *C.fil_SealPreCommitPhase1Response {
	if x == nil {
		return nil
	}
	return x.ref132bbfd8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilSealPreCommitPhase1Response) Free() {
	if x != nil && x.allocs132bbfd8 != nil {
		x.allocs132bbfd8.(*cgoAllocMap).Free()
		x.ref132bbfd8 = nil
	}
}

// NewFilSealPreCommitPhase1ResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilSealPreCommitPhase1ResponseRef(ref unsafe.Pointer) *FilSealPreCommitPhase1Response {
	if ref == nil {
		return nil
	}
	obj := new(FilSealPreCommitPhase1Response)
	obj.ref132bbfd8 = (*C.fil_SealPreCommitPhase1Response)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilSealPreCommitPhase1Response) PassRef() (*C.fil_SealPreCommitPhase1Response, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref132bbfd8 != nil {
		return x.ref132bbfd8, nil
	}
	mem132bbfd8 := allocFilSealPreCommitPhase1ResponseMemory(1)
	ref132bbfd8 := (*C.fil_SealPreCommitPhase1Response)(mem132bbfd8)
	allocs132bbfd8 := new(cgoAllocMap)
	allocs132bbfd8.Add(mem132bbfd8)

	var cstatus_code_allocs *cgoAllocMap
	ref132bbfd8.status_code, cstatus_code_allocs = (C.fil_FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocs132bbfd8.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref132bbfd8.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocs132bbfd8.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	ref132bbfd8.value, cvalue_allocs = x.Value.PassValue()
	allocs132bbfd8.Borrow(cvalue_allocs)

	x.ref132bbfd8 = ref132bbfd8
	x.allocs132bbfd8 = allocs132bbfd8
	return ref132bbfd8, allocs132bbfd8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilSealPreCommitPhase1Response) PassValue() (C.fil_SealPreCommitPhase1Response, *cgoAllocMap) {
	if x.ref132bbfd8 != nil {
		return *x.ref132bbfd8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilSealPreCommitPhase1Response) Deref() {
	if x.ref132bbfd8 == nil {
		return
	}
	x.StatusCode = (FilFCPResponseStatus)(x.ref132bbfd8.status_code)
	x.ErrorMsg = *NewFilBytesRef(unsafe.Pointer(&x.ref132bbfd8.error_msg))
	x.Value = *NewFilBytesRef(unsafe.Pointer(&x.ref132bbfd8.value))
}

// allocFilPublicPieceInfoMemory allocates memory for type C.fil_PublicPieceInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilPublicPieceInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilPublicPieceInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilPublicPieceInfoValue = unsafe.Sizeof([1]C.fil_PublicPieceInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilPublicPieceInfo) Ref() *C.fil_PublicPieceInfo {
	if x == nil {
		return nil
	}
	return x.refd00025ac
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilPublicPieceInfo) Free() {
	if x != nil && x.allocsd00025ac != nil {
		x.allocsd00025ac.(*cgoAllocMap).Free()
		x.refd00025ac = nil
	}
}

// NewFilPublicPieceInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilPublicPieceInfoRef(ref unsafe.Pointer) *FilPublicPieceInfo {
	if ref == nil {
		return nil
	}
	obj := new(FilPublicPieceInfo)
	obj.refd00025ac = (*C.fil_PublicPieceInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilPublicPieceInfo) PassRef() (*C.fil_PublicPieceInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd00025ac != nil {
		return x.refd00025ac, nil
	}
	memd00025ac := allocFilPublicPieceInfoMemory(1)
	refd00025ac := (*C.fil_PublicPieceInfo)(memd00025ac)
	allocsd00025ac := new(cgoAllocMap)
	allocsd00025ac.Add(memd00025ac)

	var cnum_bytes_allocs *cgoAllocMap
	refd00025ac.num_bytes, cnum_bytes_allocs = (C.uint64_t)(x.NumBytes), cgoAllocsUnknown
	allocsd00025ac.Borrow(cnum_bytes_allocs)

	var ccomm_p_allocs *cgoAllocMap
	refd00025ac.comm_p, ccomm_p_allocs = *(*[32]C.uint8_t)(unsafe.Pointer(&x.CommP)), cgoAllocsUnknown
	allocsd00025ac.Borrow(ccomm_p_allocs)

	x.refd00025ac = refd00025ac
	x.allocsd00025ac = allocsd00025ac
	return refd00025ac, allocsd00025ac

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilPublicPieceInfo) PassValue() (C.fil_PublicPieceInfo, *cgoAllocMap) {
	if x.refd00025ac != nil {
		return *x.refd00025ac, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilPublicPieceInfo) Deref() {
	if x.refd00025ac == nil {
		return
	}
	x.NumBytes = (uint64)(x.refd00025ac.num_bytes)
	x.CommP = *(*[32]byte)(unsafe.Pointer(&x.refd00025ac.comm_p))
}

// allocFilArrayPublicPieceInfoMemory allocates memory for type C.fil_Array_PublicPieceInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilArrayPublicPieceInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilArrayPublicPieceInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilArrayPublicPieceInfoValue = unsafe.Sizeof([1]C.fil_Array_PublicPieceInfo{})

// allocPStructFilPublicPieceInfoMemory allocates memory for type *C.struct_fil_PublicPieceInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPStructFilPublicPieceInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPStructFilPublicPieceInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPStructFilPublicPieceInfoValue = unsafe.Sizeof([1]*C.struct_fil_PublicPieceInfo{})

// allocStructFilPublicPieceInfoMemory allocates memory for type C.struct_fil_PublicPieceInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructFilPublicPieceInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructFilPublicPieceInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStructFilPublicPieceInfoValue = unsafe.Sizeof([1]C.struct_fil_PublicPieceInfo{})

// unpackSSFilPublicPieceInfo transforms a sliced Go data structure into plain C format.
func unpackSSFilPublicPieceInfo(x [][]FilPublicPieceInfo) (unpacked **C.struct_fil_PublicPieceInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPStructFilPublicPieceInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.struct_fil_PublicPieceInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocStructFilPublicPieceInfoMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.struct_fil_PublicPieceInfo)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.struct_fil_PublicPieceInfo)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.struct_fil_PublicPieceInfo)(h.Data)
	return
}

// packSSFilPublicPieceInfo reads sliced Go data structure out from plain C format.
func packSSFilPublicPieceInfo(v [][]FilPublicPieceInfo, ptr0 **C.struct_fil_PublicPieceInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.struct_fil_PublicPieceInfo)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfStructFilPublicPieceInfoValue]C.struct_fil_PublicPieceInfo)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewFilPublicPieceInfoRef(unsafe.Pointer(&ptr2))
		}
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilArrayPublicPieceInfo) Ref() *C.fil_Array_PublicPieceInfo {
	if x == nil {
		return nil
	}
	return x.refd0678e8c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilArrayPublicPieceInfo) Free() {
	if x != nil && x.allocsd0678e8c != nil {
		x.allocsd0678e8c.(*cgoAllocMap).Free()
		x.refd0678e8c = nil
	}
}

// NewFilArrayPublicPieceInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilArrayPublicPieceInfoRef(ref unsafe.Pointer) *FilArrayPublicPieceInfo {
	if ref == nil {
		return nil
	}
	obj := new(FilArrayPublicPieceInfo)
	obj.refd0678e8c = (*C.fil_Array_PublicPieceInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilArrayPublicPieceInfo) PassRef() (*C.fil_Array_PublicPieceInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd0678e8c != nil {
		return x.refd0678e8c, nil
	}
	memd0678e8c := allocFilArrayPublicPieceInfoMemory(1)
	refd0678e8c := (*C.fil_Array_PublicPieceInfo)(memd0678e8c)
	allocsd0678e8c := new(cgoAllocMap)
	allocsd0678e8c.Add(memd0678e8c)

	var cptr_allocs *cgoAllocMap
	refd0678e8c.ptr, cptr_allocs = unpackSSFilPublicPieceInfo(x.Ptr)
	allocsd0678e8c.Borrow(cptr_allocs)

	var clen_allocs *cgoAllocMap
	refd0678e8c.len, clen_allocs = (C.uintptr_t)(x.Len), cgoAllocsUnknown
	allocsd0678e8c.Borrow(clen_allocs)

	x.refd0678e8c = refd0678e8c
	x.allocsd0678e8c = allocsd0678e8c
	return refd0678e8c, allocsd0678e8c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilArrayPublicPieceInfo) PassValue() (C.fil_Array_PublicPieceInfo, *cgoAllocMap) {
	if x.refd0678e8c != nil {
		return *x.refd0678e8c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilArrayPublicPieceInfo) Deref() {
	if x.refd0678e8c == nil {
		return
	}
	packSSFilPublicPieceInfo(x.Ptr, x.refd0678e8c.ptr)
	x.Len = (uint64)(x.refd0678e8c.len)
}

// allocFilSealPreCommitPhase2Memory allocates memory for type C.fil_SealPreCommitPhase2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilSealPreCommitPhase2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilSealPreCommitPhase2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilSealPreCommitPhase2Value = unsafe.Sizeof([1]C.fil_SealPreCommitPhase2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilSealPreCommitPhase2) Ref() *C.fil_SealPreCommitPhase2 {
	if x == nil {
		return nil
	}
	return x.reff1ee731e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilSealPreCommitPhase2) Free() {
	if x != nil && x.allocsf1ee731e != nil {
		x.allocsf1ee731e.(*cgoAllocMap).Free()
		x.reff1ee731e = nil
	}
}

// NewFilSealPreCommitPhase2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilSealPreCommitPhase2Ref(ref unsafe.Pointer) *FilSealPreCommitPhase2 {
	if ref == nil {
		return nil
	}
	obj := new(FilSealPreCommitPhase2)
	obj.reff1ee731e = (*C.fil_SealPreCommitPhase2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilSealPreCommitPhase2) PassRef() (*C.fil_SealPreCommitPhase2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff1ee731e != nil {
		return x.reff1ee731e, nil
	}
	memf1ee731e := allocFilSealPreCommitPhase2Memory(1)
	reff1ee731e := (*C.fil_SealPreCommitPhase2)(memf1ee731e)
	allocsf1ee731e := new(cgoAllocMap)
	allocsf1ee731e.Add(memf1ee731e)

	var cregistered_proof_allocs *cgoAllocMap
	reff1ee731e.registered_proof, cregistered_proof_allocs = (C.fil_RegisteredSealProof)(x.RegisteredProof), cgoAllocsUnknown
	allocsf1ee731e.Borrow(cregistered_proof_allocs)

	var ccomm_d_allocs *cgoAllocMap
	reff1ee731e.comm_d, ccomm_d_allocs = *(*[32]C.uint8_t)(unsafe.Pointer(&x.CommD)), cgoAllocsUnknown
	allocsf1ee731e.Borrow(ccomm_d_allocs)

	var ccomm_r_allocs *cgoAllocMap
	reff1ee731e.comm_r, ccomm_r_allocs = *(*[32]C.uint8_t)(unsafe.Pointer(&x.CommR)), cgoAllocsUnknown
	allocsf1ee731e.Borrow(ccomm_r_allocs)

	x.reff1ee731e = reff1ee731e
	x.allocsf1ee731e = allocsf1ee731e
	return reff1ee731e, allocsf1ee731e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilSealPreCommitPhase2) PassValue() (C.fil_SealPreCommitPhase2, *cgoAllocMap) {
	if x.reff1ee731e != nil {
		return *x.reff1ee731e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilSealPreCommitPhase2) Deref() {
	if x.reff1ee731e == nil {
		return
	}
	x.RegisteredProof = (FilRegisteredSealProof)(x.reff1ee731e.registered_proof)
	x.CommD = *(*[32]byte)(unsafe.Pointer(&x.reff1ee731e.comm_d))
	x.CommR = *(*[32]byte)(unsafe.Pointer(&x.reff1ee731e.comm_r))
}

// allocFilResultSealPreCommitPhase2Memory allocates memory for type C.fil_Result_SealPreCommitPhase2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilResultSealPreCommitPhase2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilResultSealPreCommitPhase2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilResultSealPreCommitPhase2Value = unsafe.Sizeof([1]C.fil_Result_SealPreCommitPhase2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilResultSealPreCommitPhase2) Ref() *C.fil_Result_SealPreCommitPhase2 {
	if x == nil {
		return nil
	}
	return x.refa12302ad
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilResultSealPreCommitPhase2) Free() {
	if x != nil && x.allocsa12302ad != nil {
		x.allocsa12302ad.(*cgoAllocMap).Free()
		x.refa12302ad = nil
	}
}

// NewFilResultSealPreCommitPhase2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilResultSealPreCommitPhase2Ref(ref unsafe.Pointer) *FilResultSealPreCommitPhase2 {
	if ref == nil {
		return nil
	}
	obj := new(FilResultSealPreCommitPhase2)
	obj.refa12302ad = (*C.fil_Result_SealPreCommitPhase2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilResultSealPreCommitPhase2) PassRef() (*C.fil_Result_SealPreCommitPhase2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa12302ad != nil {
		return x.refa12302ad, nil
	}
	mema12302ad := allocFilResultSealPreCommitPhase2Memory(1)
	refa12302ad := (*C.fil_Result_SealPreCommitPhase2)(mema12302ad)
	allocsa12302ad := new(cgoAllocMap)
	allocsa12302ad.Add(mema12302ad)

	var cstatus_code_allocs *cgoAllocMap
	refa12302ad.status_code, cstatus_code_allocs = (C.fil_FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocsa12302ad.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	refa12302ad.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocsa12302ad.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	refa12302ad.value, cvalue_allocs = x.Value.PassValue()
	allocsa12302ad.Borrow(cvalue_allocs)

	x.refa12302ad = refa12302ad
	x.allocsa12302ad = allocsa12302ad
	return refa12302ad, allocsa12302ad

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilResultSealPreCommitPhase2) PassValue() (C.fil_Result_SealPreCommitPhase2, *cgoAllocMap) {
	if x.refa12302ad != nil {
		return *x.refa12302ad, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilResultSealPreCommitPhase2) Deref() {
	if x.refa12302ad == nil {
		return
	}
	x.StatusCode = (FilFCPResponseStatus)(x.refa12302ad.status_code)
	x.ErrorMsg = *NewFilBytesRef(unsafe.Pointer(&x.refa12302ad.error_msg))
	x.Value = *NewFilSealPreCommitPhase2Ref(unsafe.Pointer(&x.refa12302ad.value))
}

// allocFilSealPreCommitPhase2ResponseMemory allocates memory for type C.fil_SealPreCommitPhase2Response in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilSealPreCommitPhase2ResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilSealPreCommitPhase2ResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilSealPreCommitPhase2ResponseValue = unsafe.Sizeof([1]C.fil_SealPreCommitPhase2Response{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilSealPreCommitPhase2Response) Ref() *C.fil_SealPreCommitPhase2Response {
	if x == nil {
		return nil
	}
	return x.ref2aa6831d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilSealPreCommitPhase2Response) Free() {
	if x != nil && x.allocs2aa6831d != nil {
		x.allocs2aa6831d.(*cgoAllocMap).Free()
		x.ref2aa6831d = nil
	}
}

// NewFilSealPreCommitPhase2ResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilSealPreCommitPhase2ResponseRef(ref unsafe.Pointer) *FilSealPreCommitPhase2Response {
	if ref == nil {
		return nil
	}
	obj := new(FilSealPreCommitPhase2Response)
	obj.ref2aa6831d = (*C.fil_SealPreCommitPhase2Response)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilSealPreCommitPhase2Response) PassRef() (*C.fil_SealPreCommitPhase2Response, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2aa6831d != nil {
		return x.ref2aa6831d, nil
	}
	mem2aa6831d := allocFilSealPreCommitPhase2ResponseMemory(1)
	ref2aa6831d := (*C.fil_SealPreCommitPhase2Response)(mem2aa6831d)
	allocs2aa6831d := new(cgoAllocMap)
	allocs2aa6831d.Add(mem2aa6831d)

	var cstatus_code_allocs *cgoAllocMap
	ref2aa6831d.status_code, cstatus_code_allocs = (C.fil_FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocs2aa6831d.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref2aa6831d.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocs2aa6831d.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	ref2aa6831d.value, cvalue_allocs = x.Value.PassValue()
	allocs2aa6831d.Borrow(cvalue_allocs)

	x.ref2aa6831d = ref2aa6831d
	x.allocs2aa6831d = allocs2aa6831d
	return ref2aa6831d, allocs2aa6831d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilSealPreCommitPhase2Response) PassValue() (C.fil_SealPreCommitPhase2Response, *cgoAllocMap) {
	if x.ref2aa6831d != nil {
		return *x.ref2aa6831d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilSealPreCommitPhase2Response) Deref() {
	if x.ref2aa6831d == nil {
		return
	}
	x.StatusCode = (FilFCPResponseStatus)(x.ref2aa6831d.status_code)
	x.ErrorMsg = *NewFilBytesRef(unsafe.Pointer(&x.ref2aa6831d.error_msg))
	x.Value = *NewFilSealPreCommitPhase2Ref(unsafe.Pointer(&x.ref2aa6831d.value))
}

// allocFilSealCommitPhase1ResponseMemory allocates memory for type C.fil_SealCommitPhase1Response in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilSealCommitPhase1ResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilSealCommitPhase1ResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilSealCommitPhase1ResponseValue = unsafe.Sizeof([1]C.fil_SealCommitPhase1Response{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilSealCommitPhase1Response) Ref() *C.fil_SealCommitPhase1Response {
	if x == nil {
		return nil
	}
	return x.ref61ed8561
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilSealCommitPhase1Response) Free() {
	if x != nil && x.allocs61ed8561 != nil {
		x.allocs61ed8561.(*cgoAllocMap).Free()
		x.ref61ed8561 = nil
	}
}

// NewFilSealCommitPhase1ResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilSealCommitPhase1ResponseRef(ref unsafe.Pointer) *FilSealCommitPhase1Response {
	if ref == nil {
		return nil
	}
	obj := new(FilSealCommitPhase1Response)
	obj.ref61ed8561 = (*C.fil_SealCommitPhase1Response)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilSealCommitPhase1Response) PassRef() (*C.fil_SealCommitPhase1Response, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref61ed8561 != nil {
		return x.ref61ed8561, nil
	}
	mem61ed8561 := allocFilSealCommitPhase1ResponseMemory(1)
	ref61ed8561 := (*C.fil_SealCommitPhase1Response)(mem61ed8561)
	allocs61ed8561 := new(cgoAllocMap)
	allocs61ed8561.Add(mem61ed8561)

	var cstatus_code_allocs *cgoAllocMap
	ref61ed8561.status_code, cstatus_code_allocs = (C.fil_FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocs61ed8561.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref61ed8561.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocs61ed8561.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	ref61ed8561.value, cvalue_allocs = x.Value.PassValue()
	allocs61ed8561.Borrow(cvalue_allocs)

	x.ref61ed8561 = ref61ed8561
	x.allocs61ed8561 = allocs61ed8561
	return ref61ed8561, allocs61ed8561

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilSealCommitPhase1Response) PassValue() (C.fil_SealCommitPhase1Response, *cgoAllocMap) {
	if x.ref61ed8561 != nil {
		return *x.ref61ed8561, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilSealCommitPhase1Response) Deref() {
	if x.ref61ed8561 == nil {
		return
	}
	x.StatusCode = (FilFCPResponseStatus)(x.ref61ed8561.status_code)
	x.ErrorMsg = *NewFilBytesRef(unsafe.Pointer(&x.ref61ed8561.error_msg))
	x.Value = *NewFilBytesRef(unsafe.Pointer(&x.ref61ed8561.value))
}

// allocFilSealCommitPhase2Memory allocates memory for type C.fil_SealCommitPhase2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilSealCommitPhase2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilSealCommitPhase2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilSealCommitPhase2Value = unsafe.Sizeof([1]C.fil_SealCommitPhase2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilSealCommitPhase2) Ref() *C.fil_SealCommitPhase2 {
	if x == nil {
		return nil
	}
	return x.ref9f218b5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilSealCommitPhase2) Free() {
	if x != nil && x.allocs9f218b5 != nil {
		x.allocs9f218b5.(*cgoAllocMap).Free()
		x.ref9f218b5 = nil
	}
}

// NewFilSealCommitPhase2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilSealCommitPhase2Ref(ref unsafe.Pointer) *FilSealCommitPhase2 {
	if ref == nil {
		return nil
	}
	obj := new(FilSealCommitPhase2)
	obj.ref9f218b5 = (*C.fil_SealCommitPhase2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilSealCommitPhase2) PassRef() (*C.fil_SealCommitPhase2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9f218b5 != nil {
		return x.ref9f218b5, nil
	}
	mem9f218b5 := allocFilSealCommitPhase2Memory(1)
	ref9f218b5 := (*C.fil_SealCommitPhase2)(mem9f218b5)
	allocs9f218b5 := new(cgoAllocMap)
	allocs9f218b5.Add(mem9f218b5)

	var cproof_allocs *cgoAllocMap
	ref9f218b5.proof, cproof_allocs = x.Proof.PassValue()
	allocs9f218b5.Borrow(cproof_allocs)

	x.ref9f218b5 = ref9f218b5
	x.allocs9f218b5 = allocs9f218b5
	return ref9f218b5, allocs9f218b5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilSealCommitPhase2) PassValue() (C.fil_SealCommitPhase2, *cgoAllocMap) {
	if x.ref9f218b5 != nil {
		return *x.ref9f218b5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilSealCommitPhase2) Deref() {
	if x.ref9f218b5 == nil {
		return
	}
	x.Proof = *NewFilBytesRef(unsafe.Pointer(&x.ref9f218b5.proof))
}

// allocFilResultSealCommitPhase2Memory allocates memory for type C.fil_Result_SealCommitPhase2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilResultSealCommitPhase2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilResultSealCommitPhase2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilResultSealCommitPhase2Value = unsafe.Sizeof([1]C.fil_Result_SealCommitPhase2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilResultSealCommitPhase2) Ref() *C.fil_Result_SealCommitPhase2 {
	if x == nil {
		return nil
	}
	return x.refdad0c454
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilResultSealCommitPhase2) Free() {
	if x != nil && x.allocsdad0c454 != nil {
		x.allocsdad0c454.(*cgoAllocMap).Free()
		x.refdad0c454 = nil
	}
}

// NewFilResultSealCommitPhase2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilResultSealCommitPhase2Ref(ref unsafe.Pointer) *FilResultSealCommitPhase2 {
	if ref == nil {
		return nil
	}
	obj := new(FilResultSealCommitPhase2)
	obj.refdad0c454 = (*C.fil_Result_SealCommitPhase2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilResultSealCommitPhase2) PassRef() (*C.fil_Result_SealCommitPhase2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refdad0c454 != nil {
		return x.refdad0c454, nil
	}
	memdad0c454 := allocFilResultSealCommitPhase2Memory(1)
	refdad0c454 := (*C.fil_Result_SealCommitPhase2)(memdad0c454)
	allocsdad0c454 := new(cgoAllocMap)
	allocsdad0c454.Add(memdad0c454)

	var cstatus_code_allocs *cgoAllocMap
	refdad0c454.status_code, cstatus_code_allocs = (C.fil_FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocsdad0c454.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	refdad0c454.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocsdad0c454.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	refdad0c454.value, cvalue_allocs = x.Value.PassValue()
	allocsdad0c454.Borrow(cvalue_allocs)

	x.refdad0c454 = refdad0c454
	x.allocsdad0c454 = allocsdad0c454
	return refdad0c454, allocsdad0c454

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilResultSealCommitPhase2) PassValue() (C.fil_Result_SealCommitPhase2, *cgoAllocMap) {
	if x.refdad0c454 != nil {
		return *x.refdad0c454, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilResultSealCommitPhase2) Deref() {
	if x.refdad0c454 == nil {
		return
	}
	x.StatusCode = (FilFCPResponseStatus)(x.refdad0c454.status_code)
	x.ErrorMsg = *NewFilBytesRef(unsafe.Pointer(&x.refdad0c454.error_msg))
	x.Value = *NewFilSealCommitPhase2Ref(unsafe.Pointer(&x.refdad0c454.value))
}

// allocFilSealCommitPhase2ResponseMemory allocates memory for type C.fil_SealCommitPhase2Response in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilSealCommitPhase2ResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilSealCommitPhase2ResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilSealCommitPhase2ResponseValue = unsafe.Sizeof([1]C.fil_SealCommitPhase2Response{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilSealCommitPhase2Response) Ref() *C.fil_SealCommitPhase2Response {
	if x == nil {
		return nil
	}
	return x.ref5860b9a4
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilSealCommitPhase2Response) Free() {
	if x != nil && x.allocs5860b9a4 != nil {
		x.allocs5860b9a4.(*cgoAllocMap).Free()
		x.ref5860b9a4 = nil
	}
}

// NewFilSealCommitPhase2ResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilSealCommitPhase2ResponseRef(ref unsafe.Pointer) *FilSealCommitPhase2Response {
	if ref == nil {
		return nil
	}
	obj := new(FilSealCommitPhase2Response)
	obj.ref5860b9a4 = (*C.fil_SealCommitPhase2Response)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilSealCommitPhase2Response) PassRef() (*C.fil_SealCommitPhase2Response, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5860b9a4 != nil {
		return x.ref5860b9a4, nil
	}
	mem5860b9a4 := allocFilSealCommitPhase2ResponseMemory(1)
	ref5860b9a4 := (*C.fil_SealCommitPhase2Response)(mem5860b9a4)
	allocs5860b9a4 := new(cgoAllocMap)
	allocs5860b9a4.Add(mem5860b9a4)

	var cstatus_code_allocs *cgoAllocMap
	ref5860b9a4.status_code, cstatus_code_allocs = (C.fil_FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocs5860b9a4.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref5860b9a4.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocs5860b9a4.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	ref5860b9a4.value, cvalue_allocs = x.Value.PassValue()
	allocs5860b9a4.Borrow(cvalue_allocs)

	x.ref5860b9a4 = ref5860b9a4
	x.allocs5860b9a4 = allocs5860b9a4
	return ref5860b9a4, allocs5860b9a4

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilSealCommitPhase2Response) PassValue() (C.fil_SealCommitPhase2Response, *cgoAllocMap) {
	if x.ref5860b9a4 != nil {
		return *x.ref5860b9a4, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilSealCommitPhase2Response) Deref() {
	if x.ref5860b9a4 == nil {
		return
	}
	x.StatusCode = (FilFCPResponseStatus)(x.ref5860b9a4.status_code)
	x.ErrorMsg = *NewFilBytesRef(unsafe.Pointer(&x.ref5860b9a4.error_msg))
	x.Value = *NewFilSealCommitPhase2Ref(unsafe.Pointer(&x.ref5860b9a4.value))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilVanillaProof) Ref() *C.fil_Bytes {
	if x == nil {
		return nil
	}
	return x.ref1605074
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilVanillaProof) Free() {
	if x != nil && x.allocs1605074 != nil {
		x.allocs1605074.(*cgoAllocMap).Free()
		x.ref1605074 = nil
	}
}

// NewFilVanillaProofRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilVanillaProofRef(ref unsafe.Pointer) *FilVanillaProof {
	if ref == nil {
		return nil
	}
	obj := new(FilVanillaProof)
	obj.ref1605074 = (*C.fil_Bytes)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilVanillaProof) PassRef() (*C.fil_Bytes, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1605074 != nil {
		return x.ref1605074, nil
	}
	mem1605074 := allocFilBytesMemory(1)
	ref1605074 := (*C.fil_Bytes)(mem1605074)
	allocs1605074 := new(cgoAllocMap)
	allocs1605074.Add(mem1605074)

	var cptr_allocs *cgoAllocMap
	ref1605074.ptr, cptr_allocs = unpackSSByte(x.Ptr)
	allocs1605074.Borrow(cptr_allocs)

	var clen_allocs *cgoAllocMap
	ref1605074.len, clen_allocs = (C.uintptr_t)(x.Len), cgoAllocsUnknown
	allocs1605074.Borrow(clen_allocs)

	x.ref1605074 = ref1605074
	x.allocs1605074 = allocs1605074
	return ref1605074, allocs1605074

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilVanillaProof) PassValue() (C.fil_Bytes, *cgoAllocMap) {
	if x.ref1605074 != nil {
		return *x.ref1605074, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilVanillaProof) Deref() {
	if x.ref1605074 == nil {
		return
	}
	packSSByte(x.Ptr, x.ref1605074.ptr)
	x.Len = (uint64)(x.ref1605074.len)
}

// allocFilResultVanillaProofMemory allocates memory for type C.fil_Result_VanillaProof in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilResultVanillaProofMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilResultVanillaProofValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilResultVanillaProofValue = unsafe.Sizeof([1]C.fil_Result_VanillaProof{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilResultVanillaProof) Ref() *C.fil_Result_VanillaProof {
	if x == nil {
		return nil
	}
	return x.ref61427d53
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilResultVanillaProof) Free() {
	if x != nil && x.allocs61427d53 != nil {
		x.allocs61427d53.(*cgoAllocMap).Free()
		x.ref61427d53 = nil
	}
}

// NewFilResultVanillaProofRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilResultVanillaProofRef(ref unsafe.Pointer) *FilResultVanillaProof {
	if ref == nil {
		return nil
	}
	obj := new(FilResultVanillaProof)
	obj.ref61427d53 = (*C.fil_Result_VanillaProof)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilResultVanillaProof) PassRef() (*C.fil_Result_VanillaProof, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref61427d53 != nil {
		return x.ref61427d53, nil
	}
	mem61427d53 := allocFilResultVanillaProofMemory(1)
	ref61427d53 := (*C.fil_Result_VanillaProof)(mem61427d53)
	allocs61427d53 := new(cgoAllocMap)
	allocs61427d53.Add(mem61427d53)

	var cstatus_code_allocs *cgoAllocMap
	ref61427d53.status_code, cstatus_code_allocs = (C.fil_FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocs61427d53.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref61427d53.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocs61427d53.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	ref61427d53.value, cvalue_allocs = x.Value.PassValue()
	allocs61427d53.Borrow(cvalue_allocs)

	x.ref61427d53 = ref61427d53
	x.allocs61427d53 = allocs61427d53
	return ref61427d53, allocs61427d53

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilResultVanillaProof) PassValue() (C.fil_Result_VanillaProof, *cgoAllocMap) {
	if x.ref61427d53 != nil {
		return *x.ref61427d53, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilResultVanillaProof) Deref() {
	if x.ref61427d53 == nil {
		return
	}
	x.StatusCode = (FilFCPResponseStatus)(x.ref61427d53.status_code)
	x.ErrorMsg = *NewFilBytesRef(unsafe.Pointer(&x.ref61427d53.error_msg))
	x.Value = *NewFilVanillaProofRef(unsafe.Pointer(&x.ref61427d53.value))
}

// allocFilAggregateProofMemory allocates memory for type C.fil_AggregateProof in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilAggregateProofMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilAggregateProofValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilAggregateProofValue = unsafe.Sizeof([1]C.fil_AggregateProof{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilAggregateProof) Ref() *C.fil_AggregateProof {
	if x == nil {
		return nil
	}
	return x.ref22b6c4f6
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilAggregateProof) Free() {
	if x != nil && x.allocs22b6c4f6 != nil {
		x.allocs22b6c4f6.(*cgoAllocMap).Free()
		x.ref22b6c4f6 = nil
	}
}

// NewFilAggregateProofRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilAggregateProofRef(ref unsafe.Pointer) *FilAggregateProof {
	if ref == nil {
		return nil
	}
	obj := new(FilAggregateProof)
	obj.ref22b6c4f6 = (*C.fil_AggregateProof)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilAggregateProof) PassRef() (*C.fil_AggregateProof, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref22b6c4f6 != nil {
		return x.ref22b6c4f6, nil
	}
	mem22b6c4f6 := allocFilAggregateProofMemory(1)
	ref22b6c4f6 := (*C.fil_AggregateProof)(mem22b6c4f6)
	allocs22b6c4f6 := new(cgoAllocMap)
	allocs22b6c4f6.Add(mem22b6c4f6)

	var cstatus_code_allocs *cgoAllocMap
	ref22b6c4f6.status_code, cstatus_code_allocs = (C.fil_FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocs22b6c4f6.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref22b6c4f6.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocs22b6c4f6.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	ref22b6c4f6.value, cvalue_allocs = x.Value.PassValue()
	allocs22b6c4f6.Borrow(cvalue_allocs)

	x.ref22b6c4f6 = ref22b6c4f6
	x.allocs22b6c4f6 = allocs22b6c4f6
	return ref22b6c4f6, allocs22b6c4f6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilAggregateProof) PassValue() (C.fil_AggregateProof, *cgoAllocMap) {
	if x.ref22b6c4f6 != nil {
		return *x.ref22b6c4f6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilAggregateProof) Deref() {
	if x.ref22b6c4f6 == nil {
		return
	}
	x.StatusCode = (FilFCPResponseStatus)(x.ref22b6c4f6.status_code)
	x.ErrorMsg = *NewFilBytesRef(unsafe.Pointer(&x.ref22b6c4f6.error_msg))
	x.Value = *NewFilVanillaProofRef(unsafe.Pointer(&x.ref22b6c4f6.value))
}

// allocFilArrayByteArray32Memory allocates memory for type C.fil_Array_ByteArray32 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilArrayByteArray32Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilArrayByteArray32Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilArrayByteArray32Value = unsafe.Sizeof([1]C.fil_Array_ByteArray32{})

// allocPStructFilByteArray32Memory allocates memory for type *C.struct_fil_ByteArray32 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPStructFilByteArray32Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPStructFilByteArray32Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPStructFilByteArray32Value = unsafe.Sizeof([1]*C.struct_fil_ByteArray32{})

// allocStructFilByteArray32Memory allocates memory for type C.struct_fil_ByteArray32 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructFilByteArray32Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructFilByteArray32Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStructFilByteArray32Value = unsafe.Sizeof([1]C.struct_fil_ByteArray32{})

// unpackSSFilByteArray32 transforms a sliced Go data structure into plain C format.
func unpackSSFilByteArray32(x [][]FilByteArray32) (unpacked **C.struct_fil_ByteArray32, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPStructFilByteArray32Memory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.struct_fil_ByteArray32)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocStructFilByteArray32Memory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.struct_fil_ByteArray32)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.struct_fil_ByteArray32)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.struct_fil_ByteArray32)(h.Data)
	return
}

// packSSFilByteArray32 reads sliced Go data structure out from plain C format.
func packSSFilByteArray32(v [][]FilByteArray32, ptr0 **C.struct_fil_ByteArray32) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.struct_fil_ByteArray32)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfStructFilByteArray32Value]C.struct_fil_ByteArray32)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewFilByteArray32Ref(unsafe.Pointer(&ptr2))
		}
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilArrayByteArray32) Ref() *C.fil_Array_ByteArray32 {
	if x == nil {
		return nil
	}
	return x.refd6a29da3
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilArrayByteArray32) Free() {
	if x != nil && x.allocsd6a29da3 != nil {
		x.allocsd6a29da3.(*cgoAllocMap).Free()
		x.refd6a29da3 = nil
	}
}

// NewFilArrayByteArray32Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilArrayByteArray32Ref(ref unsafe.Pointer) *FilArrayByteArray32 {
	if ref == nil {
		return nil
	}
	obj := new(FilArrayByteArray32)
	obj.refd6a29da3 = (*C.fil_Array_ByteArray32)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilArrayByteArray32) PassRef() (*C.fil_Array_ByteArray32, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd6a29da3 != nil {
		return x.refd6a29da3, nil
	}
	memd6a29da3 := allocFilArrayByteArray32Memory(1)
	refd6a29da3 := (*C.fil_Array_ByteArray32)(memd6a29da3)
	allocsd6a29da3 := new(cgoAllocMap)
	allocsd6a29da3.Add(memd6a29da3)

	var cptr_allocs *cgoAllocMap
	refd6a29da3.ptr, cptr_allocs = unpackSSFilByteArray32(x.Ptr)
	allocsd6a29da3.Borrow(cptr_allocs)

	var clen_allocs *cgoAllocMap
	refd6a29da3.len, clen_allocs = (C.uintptr_t)(x.Len), cgoAllocsUnknown
	allocsd6a29da3.Borrow(clen_allocs)

	x.refd6a29da3 = refd6a29da3
	x.allocsd6a29da3 = allocsd6a29da3
	return refd6a29da3, allocsd6a29da3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilArrayByteArray32) PassValue() (C.fil_Array_ByteArray32, *cgoAllocMap) {
	if x.refd6a29da3 != nil {
		return *x.refd6a29da3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilArrayByteArray32) Deref() {
	if x.refd6a29da3 == nil {
		return
	}
	packSSFilByteArray32(x.Ptr, x.refd6a29da3.ptr)
	x.Len = (uint64)(x.refd6a29da3.len)
}

// allocFilArraySealCommitPhase2Memory allocates memory for type C.fil_Array_SealCommitPhase2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilArraySealCommitPhase2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilArraySealCommitPhase2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilArraySealCommitPhase2Value = unsafe.Sizeof([1]C.fil_Array_SealCommitPhase2{})

// allocPStructFilSealCommitPhase2Memory allocates memory for type *C.struct_fil_SealCommitPhase2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPStructFilSealCommitPhase2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPStructFilSealCommitPhase2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPStructFilSealCommitPhase2Value = unsafe.Sizeof([1]*C.struct_fil_SealCommitPhase2{})

// allocStructFilSealCommitPhase2Memory allocates memory for type C.struct_fil_SealCommitPhase2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructFilSealCommitPhase2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructFilSealCommitPhase2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStructFilSealCommitPhase2Value = unsafe.Sizeof([1]C.struct_fil_SealCommitPhase2{})

// unpackSSFilSealCommitPhase2 transforms a sliced Go data structure into plain C format.
func unpackSSFilSealCommitPhase2(x [][]FilSealCommitPhase2) (unpacked **C.struct_fil_SealCommitPhase2, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPStructFilSealCommitPhase2Memory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.struct_fil_SealCommitPhase2)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocStructFilSealCommitPhase2Memory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.struct_fil_SealCommitPhase2)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.struct_fil_SealCommitPhase2)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.struct_fil_SealCommitPhase2)(h.Data)
	return
}

// packSSFilSealCommitPhase2 reads sliced Go data structure out from plain C format.
func packSSFilSealCommitPhase2(v [][]FilSealCommitPhase2, ptr0 **C.struct_fil_SealCommitPhase2) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.struct_fil_SealCommitPhase2)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfStructFilSealCommitPhase2Value]C.struct_fil_SealCommitPhase2)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewFilSealCommitPhase2Ref(unsafe.Pointer(&ptr2))
		}
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilArraySealCommitPhase2) Ref() *C.fil_Array_SealCommitPhase2 {
	if x == nil {
		return nil
	}
	return x.ref329c5fd6
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilArraySealCommitPhase2) Free() {
	if x != nil && x.allocs329c5fd6 != nil {
		x.allocs329c5fd6.(*cgoAllocMap).Free()
		x.ref329c5fd6 = nil
	}
}

// NewFilArraySealCommitPhase2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilArraySealCommitPhase2Ref(ref unsafe.Pointer) *FilArraySealCommitPhase2 {
	if ref == nil {
		return nil
	}
	obj := new(FilArraySealCommitPhase2)
	obj.ref329c5fd6 = (*C.fil_Array_SealCommitPhase2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilArraySealCommitPhase2) PassRef() (*C.fil_Array_SealCommitPhase2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref329c5fd6 != nil {
		return x.ref329c5fd6, nil
	}
	mem329c5fd6 := allocFilArraySealCommitPhase2Memory(1)
	ref329c5fd6 := (*C.fil_Array_SealCommitPhase2)(mem329c5fd6)
	allocs329c5fd6 := new(cgoAllocMap)
	allocs329c5fd6.Add(mem329c5fd6)

	var cptr_allocs *cgoAllocMap
	ref329c5fd6.ptr, cptr_allocs = unpackSSFilSealCommitPhase2(x.Ptr)
	allocs329c5fd6.Borrow(cptr_allocs)

	var clen_allocs *cgoAllocMap
	ref329c5fd6.len, clen_allocs = (C.uintptr_t)(x.Len), cgoAllocsUnknown
	allocs329c5fd6.Borrow(clen_allocs)

	x.ref329c5fd6 = ref329c5fd6
	x.allocs329c5fd6 = allocs329c5fd6
	return ref329c5fd6, allocs329c5fd6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilArraySealCommitPhase2) PassValue() (C.fil_Array_SealCommitPhase2, *cgoAllocMap) {
	if x.ref329c5fd6 != nil {
		return *x.ref329c5fd6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilArraySealCommitPhase2) Deref() {
	if x.ref329c5fd6 == nil {
		return
	}
	packSSFilSealCommitPhase2(x.Ptr, x.ref329c5fd6.ptr)
	x.Len = (uint64)(x.ref329c5fd6.len)
}

// allocFilResultBoolMemory allocates memory for type C.fil_Result_bool in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilResultBoolMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilResultBoolValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilResultBoolValue = unsafe.Sizeof([1]C.fil_Result_bool{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilResultBool) Ref() *C.fil_Result_bool {
	if x == nil {
		return nil
	}
	return x.ref679b57a0
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilResultBool) Free() {
	if x != nil && x.allocs679b57a0 != nil {
		x.allocs679b57a0.(*cgoAllocMap).Free()
		x.ref679b57a0 = nil
	}
}

// NewFilResultBoolRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilResultBoolRef(ref unsafe.Pointer) *FilResultBool {
	if ref == nil {
		return nil
	}
	obj := new(FilResultBool)
	obj.ref679b57a0 = (*C.fil_Result_bool)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilResultBool) PassRef() (*C.fil_Result_bool, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref679b57a0 != nil {
		return x.ref679b57a0, nil
	}
	mem679b57a0 := allocFilResultBoolMemory(1)
	ref679b57a0 := (*C.fil_Result_bool)(mem679b57a0)
	allocs679b57a0 := new(cgoAllocMap)
	allocs679b57a0.Add(mem679b57a0)

	var cstatus_code_allocs *cgoAllocMap
	ref679b57a0.status_code, cstatus_code_allocs = (C.fil_FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocs679b57a0.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref679b57a0.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocs679b57a0.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	ref679b57a0.value, cvalue_allocs = (C._Bool)(x.Value), cgoAllocsUnknown
	allocs679b57a0.Borrow(cvalue_allocs)

	x.ref679b57a0 = ref679b57a0
	x.allocs679b57a0 = allocs679b57a0
	return ref679b57a0, allocs679b57a0

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilResultBool) PassValue() (C.fil_Result_bool, *cgoAllocMap) {
	if x.ref679b57a0 != nil {
		return *x.ref679b57a0, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilResultBool) Deref() {
	if x.ref679b57a0 == nil {
		return
	}
	x.StatusCode = (FilFCPResponseStatus)(x.ref679b57a0.status_code)
	x.ErrorMsg = *NewFilBytesRef(unsafe.Pointer(&x.ref679b57a0.error_msg))
	x.Value = (bool)(x.ref679b57a0.value)
}

// allocFilVerifyAggregateSealProofResponseMemory allocates memory for type C.fil_VerifyAggregateSealProofResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilVerifyAggregateSealProofResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilVerifyAggregateSealProofResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilVerifyAggregateSealProofResponseValue = unsafe.Sizeof([1]C.fil_VerifyAggregateSealProofResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilVerifyAggregateSealProofResponse) Ref() *C.fil_VerifyAggregateSealProofResponse {
	if x == nil {
		return nil
	}
	return x.ref66180e0
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilVerifyAggregateSealProofResponse) Free() {
	if x != nil && x.allocs66180e0 != nil {
		x.allocs66180e0.(*cgoAllocMap).Free()
		x.ref66180e0 = nil
	}
}

// NewFilVerifyAggregateSealProofResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilVerifyAggregateSealProofResponseRef(ref unsafe.Pointer) *FilVerifyAggregateSealProofResponse {
	if ref == nil {
		return nil
	}
	obj := new(FilVerifyAggregateSealProofResponse)
	obj.ref66180e0 = (*C.fil_VerifyAggregateSealProofResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilVerifyAggregateSealProofResponse) PassRef() (*C.fil_VerifyAggregateSealProofResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref66180e0 != nil {
		return x.ref66180e0, nil
	}
	mem66180e0 := allocFilVerifyAggregateSealProofResponseMemory(1)
	ref66180e0 := (*C.fil_VerifyAggregateSealProofResponse)(mem66180e0)
	allocs66180e0 := new(cgoAllocMap)
	allocs66180e0.Add(mem66180e0)

	var cstatus_code_allocs *cgoAllocMap
	ref66180e0.status_code, cstatus_code_allocs = (C.fil_FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocs66180e0.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref66180e0.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocs66180e0.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	ref66180e0.value, cvalue_allocs = (C._Bool)(x.Value), cgoAllocsUnknown
	allocs66180e0.Borrow(cvalue_allocs)

	x.ref66180e0 = ref66180e0
	x.allocs66180e0 = allocs66180e0
	return ref66180e0, allocs66180e0

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilVerifyAggregateSealProofResponse) PassValue() (C.fil_VerifyAggregateSealProofResponse, *cgoAllocMap) {
	if x.ref66180e0 != nil {
		return *x.ref66180e0, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilVerifyAggregateSealProofResponse) Deref() {
	if x.ref66180e0 == nil {
		return
	}
	x.StatusCode = (FilFCPResponseStatus)(x.ref66180e0.status_code)
	x.ErrorMsg = *NewFilBytesRef(unsafe.Pointer(&x.ref66180e0.error_msg))
	x.Value = (bool)(x.ref66180e0.value)
}

// allocFilAggregationInputsMemory allocates memory for type C.fil_AggregationInputs in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilAggregationInputsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilAggregationInputsValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilAggregationInputsValue = unsafe.Sizeof([1]C.fil_AggregationInputs{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilAggregationInputs) Ref() *C.fil_AggregationInputs {
	if x == nil {
		return nil
	}
	return x.ref90b967c9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilAggregationInputs) Free() {
	if x != nil && x.allocs90b967c9 != nil {
		x.allocs90b967c9.(*cgoAllocMap).Free()
		x.ref90b967c9 = nil
	}
}

// NewFilAggregationInputsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilAggregationInputsRef(ref unsafe.Pointer) *FilAggregationInputs {
	if ref == nil {
		return nil
	}
	obj := new(FilAggregationInputs)
	obj.ref90b967c9 = (*C.fil_AggregationInputs)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilAggregationInputs) PassRef() (*C.fil_AggregationInputs, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref90b967c9 != nil {
		return x.ref90b967c9, nil
	}
	mem90b967c9 := allocFilAggregationInputsMemory(1)
	ref90b967c9 := (*C.fil_AggregationInputs)(mem90b967c9)
	allocs90b967c9 := new(cgoAllocMap)
	allocs90b967c9.Add(mem90b967c9)

	var ccomm_r_allocs *cgoAllocMap
	ref90b967c9.comm_r, ccomm_r_allocs = x.CommR.PassValue()
	allocs90b967c9.Borrow(ccomm_r_allocs)

	var ccomm_d_allocs *cgoAllocMap
	ref90b967c9.comm_d, ccomm_d_allocs = x.CommD.PassValue()
	allocs90b967c9.Borrow(ccomm_d_allocs)

	var csector_id_allocs *cgoAllocMap
	ref90b967c9.sector_id, csector_id_allocs = (C.uint64_t)(x.SectorId), cgoAllocsUnknown
	allocs90b967c9.Borrow(csector_id_allocs)

	var cticket_allocs *cgoAllocMap
	ref90b967c9.ticket, cticket_allocs = x.Ticket.PassValue()
	allocs90b967c9.Borrow(cticket_allocs)

	var cseed_allocs *cgoAllocMap
	ref90b967c9.seed, cseed_allocs = x.Seed.PassValue()
	allocs90b967c9.Borrow(cseed_allocs)

	x.ref90b967c9 = ref90b967c9
	x.allocs90b967c9 = allocs90b967c9
	return ref90b967c9, allocs90b967c9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilAggregationInputs) PassValue() (C.fil_AggregationInputs, *cgoAllocMap) {
	if x.ref90b967c9 != nil {
		return *x.ref90b967c9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilAggregationInputs) Deref() {
	if x.ref90b967c9 == nil {
		return
	}
	x.CommR = *NewFilByteArray32Ref(unsafe.Pointer(&x.ref90b967c9.comm_r))
	x.CommD = *NewFilByteArray32Ref(unsafe.Pointer(&x.ref90b967c9.comm_d))
	x.SectorId = (uint64)(x.ref90b967c9.sector_id)
	x.Ticket = *NewFilByteArray32Ref(unsafe.Pointer(&x.ref90b967c9.ticket))
	x.Seed = *NewFilByteArray32Ref(unsafe.Pointer(&x.ref90b967c9.seed))
}

// allocFilArrayAggregationInputsMemory allocates memory for type C.fil_Array_AggregationInputs in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilArrayAggregationInputsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilArrayAggregationInputsValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilArrayAggregationInputsValue = unsafe.Sizeof([1]C.fil_Array_AggregationInputs{})

// allocPStructFilAggregationInputsMemory allocates memory for type *C.struct_fil_AggregationInputs in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPStructFilAggregationInputsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPStructFilAggregationInputsValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPStructFilAggregationInputsValue = unsafe.Sizeof([1]*C.struct_fil_AggregationInputs{})

// allocStructFilAggregationInputsMemory allocates memory for type C.struct_fil_AggregationInputs in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructFilAggregationInputsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructFilAggregationInputsValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStructFilAggregationInputsValue = unsafe.Sizeof([1]C.struct_fil_AggregationInputs{})

// unpackSSFilAggregationInputs transforms a sliced Go data structure into plain C format.
func unpackSSFilAggregationInputs(x [][]FilAggregationInputs) (unpacked **C.struct_fil_AggregationInputs, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPStructFilAggregationInputsMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.struct_fil_AggregationInputs)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocStructFilAggregationInputsMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.struct_fil_AggregationInputs)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.struct_fil_AggregationInputs)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.struct_fil_AggregationInputs)(h.Data)
	return
}

// packSSFilAggregationInputs reads sliced Go data structure out from plain C format.
func packSSFilAggregationInputs(v [][]FilAggregationInputs, ptr0 **C.struct_fil_AggregationInputs) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.struct_fil_AggregationInputs)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfStructFilAggregationInputsValue]C.struct_fil_AggregationInputs)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewFilAggregationInputsRef(unsafe.Pointer(&ptr2))
		}
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilArrayAggregationInputs) Ref() *C.fil_Array_AggregationInputs {
	if x == nil {
		return nil
	}
	return x.ref4439396c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilArrayAggregationInputs) Free() {
	if x != nil && x.allocs4439396c != nil {
		x.allocs4439396c.(*cgoAllocMap).Free()
		x.ref4439396c = nil
	}
}

// NewFilArrayAggregationInputsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilArrayAggregationInputsRef(ref unsafe.Pointer) *FilArrayAggregationInputs {
	if ref == nil {
		return nil
	}
	obj := new(FilArrayAggregationInputs)
	obj.ref4439396c = (*C.fil_Array_AggregationInputs)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilArrayAggregationInputs) PassRef() (*C.fil_Array_AggregationInputs, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4439396c != nil {
		return x.ref4439396c, nil
	}
	mem4439396c := allocFilArrayAggregationInputsMemory(1)
	ref4439396c := (*C.fil_Array_AggregationInputs)(mem4439396c)
	allocs4439396c := new(cgoAllocMap)
	allocs4439396c.Add(mem4439396c)

	var cptr_allocs *cgoAllocMap
	ref4439396c.ptr, cptr_allocs = unpackSSFilAggregationInputs(x.Ptr)
	allocs4439396c.Borrow(cptr_allocs)

	var clen_allocs *cgoAllocMap
	ref4439396c.len, clen_allocs = (C.uintptr_t)(x.Len), cgoAllocsUnknown
	allocs4439396c.Borrow(clen_allocs)

	x.ref4439396c = ref4439396c
	x.allocs4439396c = allocs4439396c
	return ref4439396c, allocs4439396c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilArrayAggregationInputs) PassValue() (C.fil_Array_AggregationInputs, *cgoAllocMap) {
	if x.ref4439396c != nil {
		return *x.ref4439396c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilArrayAggregationInputs) Deref() {
	if x.ref4439396c == nil {
		return
	}
	packSSFilAggregationInputs(x.Ptr, x.ref4439396c.ptr)
	x.Len = (uint64)(x.ref4439396c.len)
}

// allocFilResultCVoidMemory allocates memory for type C.fil_Result_c_void in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilResultCVoidMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilResultCVoidValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilResultCVoidValue = unsafe.Sizeof([1]C.fil_Result_c_void{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilResultCVoid) Ref() *C.fil_Result_c_void {
	if x == nil {
		return nil
	}
	return x.refa11bb51a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilResultCVoid) Free() {
	if x != nil && x.allocsa11bb51a != nil {
		x.allocsa11bb51a.(*cgoAllocMap).Free()
		x.refa11bb51a = nil
	}
}

// NewFilResultCVoidRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilResultCVoidRef(ref unsafe.Pointer) *FilResultCVoid {
	if ref == nil {
		return nil
	}
	obj := new(FilResultCVoid)
	obj.refa11bb51a = (*C.fil_Result_c_void)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilResultCVoid) PassRef() (*C.fil_Result_c_void, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa11bb51a != nil {
		return x.refa11bb51a, nil
	}
	mema11bb51a := allocFilResultCVoidMemory(1)
	refa11bb51a := (*C.fil_Result_c_void)(mema11bb51a)
	allocsa11bb51a := new(cgoAllocMap)
	allocsa11bb51a.Add(mema11bb51a)

	var cstatus_code_allocs *cgoAllocMap
	refa11bb51a.status_code, cstatus_code_allocs = (C.fil_FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocsa11bb51a.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	refa11bb51a.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocsa11bb51a.Borrow(cerror_msg_allocs)

	x.refa11bb51a = refa11bb51a
	x.allocsa11bb51a = allocsa11bb51a
	return refa11bb51a, allocsa11bb51a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilResultCVoid) PassValue() (C.fil_Result_c_void, *cgoAllocMap) {
	if x.refa11bb51a != nil {
		return *x.refa11bb51a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilResultCVoid) Deref() {
	if x.refa11bb51a == nil {
		return
	}
	x.StatusCode = (FilFCPResponseStatus)(x.refa11bb51a.status_code)
	x.ErrorMsg = *NewFilBytesRef(unsafe.Pointer(&x.refa11bb51a.error_msg))
}

// allocFilUnsealRangeResponseMemory allocates memory for type C.fil_UnsealRangeResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilUnsealRangeResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilUnsealRangeResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilUnsealRangeResponseValue = unsafe.Sizeof([1]C.fil_UnsealRangeResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilUnsealRangeResponse) Ref() *C.fil_UnsealRangeResponse {
	if x == nil {
		return nil
	}
	return x.ref61e219c9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilUnsealRangeResponse) Free() {
	if x != nil && x.allocs61e219c9 != nil {
		x.allocs61e219c9.(*cgoAllocMap).Free()
		x.ref61e219c9 = nil
	}
}

// NewFilUnsealRangeResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilUnsealRangeResponseRef(ref unsafe.Pointer) *FilUnsealRangeResponse {
	if ref == nil {
		return nil
	}
	obj := new(FilUnsealRangeResponse)
	obj.ref61e219c9 = (*C.fil_UnsealRangeResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilUnsealRangeResponse) PassRef() (*C.fil_UnsealRangeResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref61e219c9 != nil {
		return x.ref61e219c9, nil
	}
	mem61e219c9 := allocFilUnsealRangeResponseMemory(1)
	ref61e219c9 := (*C.fil_UnsealRangeResponse)(mem61e219c9)
	allocs61e219c9 := new(cgoAllocMap)
	allocs61e219c9.Add(mem61e219c9)

	var cstatus_code_allocs *cgoAllocMap
	ref61e219c9.status_code, cstatus_code_allocs = (C.fil_FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocs61e219c9.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref61e219c9.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocs61e219c9.Borrow(cerror_msg_allocs)

	x.ref61e219c9 = ref61e219c9
	x.allocs61e219c9 = allocs61e219c9
	return ref61e219c9, allocs61e219c9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilUnsealRangeResponse) PassValue() (C.fil_UnsealRangeResponse, *cgoAllocMap) {
	if x.ref61e219c9 != nil {
		return *x.ref61e219c9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilUnsealRangeResponse) Deref() {
	if x.ref61e219c9 == nil {
		return
	}
	x.StatusCode = (FilFCPResponseStatus)(x.ref61e219c9.status_code)
	x.ErrorMsg = *NewFilBytesRef(unsafe.Pointer(&x.ref61e219c9.error_msg))
}

// allocFilVerifySealResponseMemory allocates memory for type C.fil_VerifySealResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilVerifySealResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilVerifySealResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilVerifySealResponseValue = unsafe.Sizeof([1]C.fil_VerifySealResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilVerifySealResponse) Ref() *C.fil_VerifySealResponse {
	if x == nil {
		return nil
	}
	return x.refd4397079
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilVerifySealResponse) Free() {
	if x != nil && x.allocsd4397079 != nil {
		x.allocsd4397079.(*cgoAllocMap).Free()
		x.refd4397079 = nil
	}
}

// NewFilVerifySealResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilVerifySealResponseRef(ref unsafe.Pointer) *FilVerifySealResponse {
	if ref == nil {
		return nil
	}
	obj := new(FilVerifySealResponse)
	obj.refd4397079 = (*C.fil_VerifySealResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilVerifySealResponse) PassRef() (*C.fil_VerifySealResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd4397079 != nil {
		return x.refd4397079, nil
	}
	memd4397079 := allocFilVerifySealResponseMemory(1)
	refd4397079 := (*C.fil_VerifySealResponse)(memd4397079)
	allocsd4397079 := new(cgoAllocMap)
	allocsd4397079.Add(memd4397079)

	var cstatus_code_allocs *cgoAllocMap
	refd4397079.status_code, cstatus_code_allocs = (C.fil_FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocsd4397079.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	refd4397079.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocsd4397079.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	refd4397079.value, cvalue_allocs = (C._Bool)(x.Value), cgoAllocsUnknown
	allocsd4397079.Borrow(cvalue_allocs)

	x.refd4397079 = refd4397079
	x.allocsd4397079 = allocsd4397079
	return refd4397079, allocsd4397079

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilVerifySealResponse) PassValue() (C.fil_VerifySealResponse, *cgoAllocMap) {
	if x.refd4397079 != nil {
		return *x.refd4397079, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilVerifySealResponse) Deref() {
	if x.refd4397079 == nil {
		return
	}
	x.StatusCode = (FilFCPResponseStatus)(x.refd4397079.status_code)
	x.ErrorMsg = *NewFilBytesRef(unsafe.Pointer(&x.refd4397079.error_msg))
	x.Value = (bool)(x.refd4397079.value)
}

// allocFilResultArrayU64Memory allocates memory for type C.fil_Result_Array_u64 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilResultArrayU64Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilResultArrayU64Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilResultArrayU64Value = unsafe.Sizeof([1]C.fil_Result_Array_u64{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilResultArrayU64) Ref() *C.fil_Result_Array_u64 {
	if x == nil {
		return nil
	}
	return x.ref404ed39c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilResultArrayU64) Free() {
	if x != nil && x.allocs404ed39c != nil {
		x.allocs404ed39c.(*cgoAllocMap).Free()
		x.ref404ed39c = nil
	}
}

// NewFilResultArrayU64Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilResultArrayU64Ref(ref unsafe.Pointer) *FilResultArrayU64 {
	if ref == nil {
		return nil
	}
	obj := new(FilResultArrayU64)
	obj.ref404ed39c = (*C.fil_Result_Array_u64)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilResultArrayU64) PassRef() (*C.fil_Result_Array_u64, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref404ed39c != nil {
		return x.ref404ed39c, nil
	}
	mem404ed39c := allocFilResultArrayU64Memory(1)
	ref404ed39c := (*C.fil_Result_Array_u64)(mem404ed39c)
	allocs404ed39c := new(cgoAllocMap)
	allocs404ed39c.Add(mem404ed39c)

	var cstatus_code_allocs *cgoAllocMap
	ref404ed39c.status_code, cstatus_code_allocs = (C.fil_FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocs404ed39c.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref404ed39c.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocs404ed39c.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	ref404ed39c.value, cvalue_allocs = x.Value.PassValue()
	allocs404ed39c.Borrow(cvalue_allocs)

	x.ref404ed39c = ref404ed39c
	x.allocs404ed39c = allocs404ed39c
	return ref404ed39c, allocs404ed39c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilResultArrayU64) PassValue() (C.fil_Result_Array_u64, *cgoAllocMap) {
	if x.ref404ed39c != nil {
		return *x.ref404ed39c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilResultArrayU64) Deref() {
	if x.ref404ed39c == nil {
		return
	}
	x.StatusCode = (FilFCPResponseStatus)(x.ref404ed39c.status_code)
	x.ErrorMsg = *NewFilBytesRef(unsafe.Pointer(&x.ref404ed39c.error_msg))
	x.Value = *NewFilArrayU64Ref(unsafe.Pointer(&x.ref404ed39c.value))
}

// allocFilGenerateWinningPoStSectorChallengeMemory allocates memory for type C.fil_GenerateWinningPoStSectorChallenge in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilGenerateWinningPoStSectorChallengeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilGenerateWinningPoStSectorChallengeValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilGenerateWinningPoStSectorChallengeValue = unsafe.Sizeof([1]C.fil_GenerateWinningPoStSectorChallenge{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilGenerateWinningPoStSectorChallenge) Ref() *C.fil_GenerateWinningPoStSectorChallenge {
	if x == nil {
		return nil
	}
	return x.ref69d2a405
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilGenerateWinningPoStSectorChallenge) Free() {
	if x != nil && x.allocs69d2a405 != nil {
		x.allocs69d2a405.(*cgoAllocMap).Free()
		x.ref69d2a405 = nil
	}
}

// NewFilGenerateWinningPoStSectorChallengeRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilGenerateWinningPoStSectorChallengeRef(ref unsafe.Pointer) *FilGenerateWinningPoStSectorChallenge {
	if ref == nil {
		return nil
	}
	obj := new(FilGenerateWinningPoStSectorChallenge)
	obj.ref69d2a405 = (*C.fil_GenerateWinningPoStSectorChallenge)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilGenerateWinningPoStSectorChallenge) PassRef() (*C.fil_GenerateWinningPoStSectorChallenge, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref69d2a405 != nil {
		return x.ref69d2a405, nil
	}
	mem69d2a405 := allocFilGenerateWinningPoStSectorChallengeMemory(1)
	ref69d2a405 := (*C.fil_GenerateWinningPoStSectorChallenge)(mem69d2a405)
	allocs69d2a405 := new(cgoAllocMap)
	allocs69d2a405.Add(mem69d2a405)

	var cstatus_code_allocs *cgoAllocMap
	ref69d2a405.status_code, cstatus_code_allocs = (C.fil_FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocs69d2a405.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref69d2a405.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocs69d2a405.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	ref69d2a405.value, cvalue_allocs = x.Value.PassValue()
	allocs69d2a405.Borrow(cvalue_allocs)

	x.ref69d2a405 = ref69d2a405
	x.allocs69d2a405 = allocs69d2a405
	return ref69d2a405, allocs69d2a405

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilGenerateWinningPoStSectorChallenge) PassValue() (C.fil_GenerateWinningPoStSectorChallenge, *cgoAllocMap) {
	if x.ref69d2a405 != nil {
		return *x.ref69d2a405, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilGenerateWinningPoStSectorChallenge) Deref() {
	if x.ref69d2a405 == nil {
		return
	}
	x.StatusCode = (FilFCPResponseStatus)(x.ref69d2a405.status_code)
	x.ErrorMsg = *NewFilBytesRef(unsafe.Pointer(&x.ref69d2a405.error_msg))
	x.Value = *NewFilArrayU64Ref(unsafe.Pointer(&x.ref69d2a405.value))
}

// allocFilGenerateFallbackSectorChallengesMemory allocates memory for type C.fil_GenerateFallbackSectorChallenges in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilGenerateFallbackSectorChallengesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilGenerateFallbackSectorChallengesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilGenerateFallbackSectorChallengesValue = unsafe.Sizeof([1]C.fil_GenerateFallbackSectorChallenges{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilGenerateFallbackSectorChallenges) Ref() *C.fil_GenerateFallbackSectorChallenges {
	if x == nil {
		return nil
	}
	return x.ref4e86db4
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilGenerateFallbackSectorChallenges) Free() {
	if x != nil && x.allocs4e86db4 != nil {
		x.allocs4e86db4.(*cgoAllocMap).Free()
		x.ref4e86db4 = nil
	}
}

// NewFilGenerateFallbackSectorChallengesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilGenerateFallbackSectorChallengesRef(ref unsafe.Pointer) *FilGenerateFallbackSectorChallenges {
	if ref == nil {
		return nil
	}
	obj := new(FilGenerateFallbackSectorChallenges)
	obj.ref4e86db4 = (*C.fil_GenerateFallbackSectorChallenges)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilGenerateFallbackSectorChallenges) PassRef() (*C.fil_GenerateFallbackSectorChallenges, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4e86db4 != nil {
		return x.ref4e86db4, nil
	}
	mem4e86db4 := allocFilGenerateFallbackSectorChallengesMemory(1)
	ref4e86db4 := (*C.fil_GenerateFallbackSectorChallenges)(mem4e86db4)
	allocs4e86db4 := new(cgoAllocMap)
	allocs4e86db4.Add(mem4e86db4)

	var cids_allocs *cgoAllocMap
	ref4e86db4.ids, cids_allocs = x.Ids.PassValue()
	allocs4e86db4.Borrow(cids_allocs)

	var cchallenges_allocs *cgoAllocMap
	ref4e86db4.challenges, cchallenges_allocs = x.Challenges.PassValue()
	allocs4e86db4.Borrow(cchallenges_allocs)

	var cchallenges_stride_allocs *cgoAllocMap
	ref4e86db4.challenges_stride, cchallenges_stride_allocs = (C.size_t)(x.ChallengesStride), cgoAllocsUnknown
	allocs4e86db4.Borrow(cchallenges_stride_allocs)

	x.ref4e86db4 = ref4e86db4
	x.allocs4e86db4 = allocs4e86db4
	return ref4e86db4, allocs4e86db4

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilGenerateFallbackSectorChallenges) PassValue() (C.fil_GenerateFallbackSectorChallenges, *cgoAllocMap) {
	if x.ref4e86db4 != nil {
		return *x.ref4e86db4, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilGenerateFallbackSectorChallenges) Deref() {
	if x.ref4e86db4 == nil {
		return
	}
	x.Ids = *NewFilArrayU64Ref(unsafe.Pointer(&x.ref4e86db4.ids))
	x.Challenges = *NewFilArrayU64Ref(unsafe.Pointer(&x.ref4e86db4.challenges))
	x.ChallengesStride = (uint)(x.ref4e86db4.challenges_stride)
}

// allocFilResultGenerateFallbackSectorChallengesMemory allocates memory for type C.fil_Result_GenerateFallbackSectorChallenges in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilResultGenerateFallbackSectorChallengesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilResultGenerateFallbackSectorChallengesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilResultGenerateFallbackSectorChallengesValue = unsafe.Sizeof([1]C.fil_Result_GenerateFallbackSectorChallenges{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilResultGenerateFallbackSectorChallenges) Ref() *C.fil_Result_GenerateFallbackSectorChallenges {
	if x == nil {
		return nil
	}
	return x.ref72f7e3e6
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilResultGenerateFallbackSectorChallenges) Free() {
	if x != nil && x.allocs72f7e3e6 != nil {
		x.allocs72f7e3e6.(*cgoAllocMap).Free()
		x.ref72f7e3e6 = nil
	}
}

// NewFilResultGenerateFallbackSectorChallengesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilResultGenerateFallbackSectorChallengesRef(ref unsafe.Pointer) *FilResultGenerateFallbackSectorChallenges {
	if ref == nil {
		return nil
	}
	obj := new(FilResultGenerateFallbackSectorChallenges)
	obj.ref72f7e3e6 = (*C.fil_Result_GenerateFallbackSectorChallenges)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilResultGenerateFallbackSectorChallenges) PassRef() (*C.fil_Result_GenerateFallbackSectorChallenges, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref72f7e3e6 != nil {
		return x.ref72f7e3e6, nil
	}
	mem72f7e3e6 := allocFilResultGenerateFallbackSectorChallengesMemory(1)
	ref72f7e3e6 := (*C.fil_Result_GenerateFallbackSectorChallenges)(mem72f7e3e6)
	allocs72f7e3e6 := new(cgoAllocMap)
	allocs72f7e3e6.Add(mem72f7e3e6)

	var cstatus_code_allocs *cgoAllocMap
	ref72f7e3e6.status_code, cstatus_code_allocs = (C.fil_FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocs72f7e3e6.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref72f7e3e6.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocs72f7e3e6.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	ref72f7e3e6.value, cvalue_allocs = x.Value.PassValue()
	allocs72f7e3e6.Borrow(cvalue_allocs)

	x.ref72f7e3e6 = ref72f7e3e6
	x.allocs72f7e3e6 = allocs72f7e3e6
	return ref72f7e3e6, allocs72f7e3e6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilResultGenerateFallbackSectorChallenges) PassValue() (C.fil_Result_GenerateFallbackSectorChallenges, *cgoAllocMap) {
	if x.ref72f7e3e6 != nil {
		return *x.ref72f7e3e6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilResultGenerateFallbackSectorChallenges) Deref() {
	if x.ref72f7e3e6 == nil {
		return
	}
	x.StatusCode = (FilFCPResponseStatus)(x.ref72f7e3e6.status_code)
	x.ErrorMsg = *NewFilBytesRef(unsafe.Pointer(&x.ref72f7e3e6.error_msg))
	x.Value = *NewFilGenerateFallbackSectorChallengesRef(unsafe.Pointer(&x.ref72f7e3e6.value))
}

// allocFilGenerateFallbackSectorChallengesResponseMemory allocates memory for type C.fil_GenerateFallbackSectorChallengesResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilGenerateFallbackSectorChallengesResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilGenerateFallbackSectorChallengesResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilGenerateFallbackSectorChallengesResponseValue = unsafe.Sizeof([1]C.fil_GenerateFallbackSectorChallengesResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilGenerateFallbackSectorChallengesResponse) Ref() *C.fil_GenerateFallbackSectorChallengesResponse {
	if x == nil {
		return nil
	}
	return x.ref7047a3fa
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilGenerateFallbackSectorChallengesResponse) Free() {
	if x != nil && x.allocs7047a3fa != nil {
		x.allocs7047a3fa.(*cgoAllocMap).Free()
		x.ref7047a3fa = nil
	}
}

// NewFilGenerateFallbackSectorChallengesResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilGenerateFallbackSectorChallengesResponseRef(ref unsafe.Pointer) *FilGenerateFallbackSectorChallengesResponse {
	if ref == nil {
		return nil
	}
	obj := new(FilGenerateFallbackSectorChallengesResponse)
	obj.ref7047a3fa = (*C.fil_GenerateFallbackSectorChallengesResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilGenerateFallbackSectorChallengesResponse) PassRef() (*C.fil_GenerateFallbackSectorChallengesResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7047a3fa != nil {
		return x.ref7047a3fa, nil
	}
	mem7047a3fa := allocFilGenerateFallbackSectorChallengesResponseMemory(1)
	ref7047a3fa := (*C.fil_GenerateFallbackSectorChallengesResponse)(mem7047a3fa)
	allocs7047a3fa := new(cgoAllocMap)
	allocs7047a3fa.Add(mem7047a3fa)

	var cstatus_code_allocs *cgoAllocMap
	ref7047a3fa.status_code, cstatus_code_allocs = (C.fil_FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocs7047a3fa.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref7047a3fa.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocs7047a3fa.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	ref7047a3fa.value, cvalue_allocs = x.Value.PassValue()
	allocs7047a3fa.Borrow(cvalue_allocs)

	x.ref7047a3fa = ref7047a3fa
	x.allocs7047a3fa = allocs7047a3fa
	return ref7047a3fa, allocs7047a3fa

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilGenerateFallbackSectorChallengesResponse) PassValue() (C.fil_GenerateFallbackSectorChallengesResponse, *cgoAllocMap) {
	if x.ref7047a3fa != nil {
		return *x.ref7047a3fa, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilGenerateFallbackSectorChallengesResponse) Deref() {
	if x.ref7047a3fa == nil {
		return
	}
	x.StatusCode = (FilFCPResponseStatus)(x.ref7047a3fa.status_code)
	x.ErrorMsg = *NewFilBytesRef(unsafe.Pointer(&x.ref7047a3fa.error_msg))
	x.Value = *NewFilGenerateFallbackSectorChallengesRef(unsafe.Pointer(&x.ref7047a3fa.value))
}

// allocFilGenerateSingleVanillaProofResponseMemory allocates memory for type C.fil_GenerateSingleVanillaProofResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilGenerateSingleVanillaProofResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilGenerateSingleVanillaProofResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilGenerateSingleVanillaProofResponseValue = unsafe.Sizeof([1]C.fil_GenerateSingleVanillaProofResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilGenerateSingleVanillaProofResponse) Ref() *C.fil_GenerateSingleVanillaProofResponse {
	if x == nil {
		return nil
	}
	return x.reff9d21b04
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilGenerateSingleVanillaProofResponse) Free() {
	if x != nil && x.allocsf9d21b04 != nil {
		x.allocsf9d21b04.(*cgoAllocMap).Free()
		x.reff9d21b04 = nil
	}
}

// NewFilGenerateSingleVanillaProofResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilGenerateSingleVanillaProofResponseRef(ref unsafe.Pointer) *FilGenerateSingleVanillaProofResponse {
	if ref == nil {
		return nil
	}
	obj := new(FilGenerateSingleVanillaProofResponse)
	obj.reff9d21b04 = (*C.fil_GenerateSingleVanillaProofResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilGenerateSingleVanillaProofResponse) PassRef() (*C.fil_GenerateSingleVanillaProofResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff9d21b04 != nil {
		return x.reff9d21b04, nil
	}
	memf9d21b04 := allocFilGenerateSingleVanillaProofResponseMemory(1)
	reff9d21b04 := (*C.fil_GenerateSingleVanillaProofResponse)(memf9d21b04)
	allocsf9d21b04 := new(cgoAllocMap)
	allocsf9d21b04.Add(memf9d21b04)

	var cstatus_code_allocs *cgoAllocMap
	reff9d21b04.status_code, cstatus_code_allocs = (C.fil_FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocsf9d21b04.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	reff9d21b04.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocsf9d21b04.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	reff9d21b04.value, cvalue_allocs = x.Value.PassValue()
	allocsf9d21b04.Borrow(cvalue_allocs)

	x.reff9d21b04 = reff9d21b04
	x.allocsf9d21b04 = allocsf9d21b04
	return reff9d21b04, allocsf9d21b04

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilGenerateSingleVanillaProofResponse) PassValue() (C.fil_GenerateSingleVanillaProofResponse, *cgoAllocMap) {
	if x.reff9d21b04 != nil {
		return *x.reff9d21b04, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilGenerateSingleVanillaProofResponse) Deref() {
	if x.reff9d21b04 == nil {
		return
	}
	x.StatusCode = (FilFCPResponseStatus)(x.reff9d21b04.status_code)
	x.ErrorMsg = *NewFilBytesRef(unsafe.Pointer(&x.reff9d21b04.error_msg))
	x.Value = *NewFilVanillaProofRef(unsafe.Pointer(&x.reff9d21b04.value))
}

// allocFilPrivateReplicaInfoMemory allocates memory for type C.fil_PrivateReplicaInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilPrivateReplicaInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilPrivateReplicaInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilPrivateReplicaInfoValue = unsafe.Sizeof([1]C.fil_PrivateReplicaInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilPrivateReplicaInfo) Ref() *C.fil_PrivateReplicaInfo {
	if x == nil {
		return nil
	}
	return x.ref81a31e9b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilPrivateReplicaInfo) Free() {
	if x != nil && x.allocs81a31e9b != nil {
		x.allocs81a31e9b.(*cgoAllocMap).Free()
		x.ref81a31e9b = nil
	}
}

// NewFilPrivateReplicaInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilPrivateReplicaInfoRef(ref unsafe.Pointer) *FilPrivateReplicaInfo {
	if ref == nil {
		return nil
	}
	obj := new(FilPrivateReplicaInfo)
	obj.ref81a31e9b = (*C.fil_PrivateReplicaInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilPrivateReplicaInfo) PassRef() (*C.fil_PrivateReplicaInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref81a31e9b != nil {
		return x.ref81a31e9b, nil
	}
	mem81a31e9b := allocFilPrivateReplicaInfoMemory(1)
	ref81a31e9b := (*C.fil_PrivateReplicaInfo)(mem81a31e9b)
	allocs81a31e9b := new(cgoAllocMap)
	allocs81a31e9b.Add(mem81a31e9b)

	var cregistered_proof_allocs *cgoAllocMap
	ref81a31e9b.registered_proof, cregistered_proof_allocs = (C.fil_RegisteredPoStProof)(x.RegisteredProof), cgoAllocsUnknown
	allocs81a31e9b.Borrow(cregistered_proof_allocs)

	var ccache_dir_path_allocs *cgoAllocMap
	ref81a31e9b.cache_dir_path, ccache_dir_path_allocs = x.CacheDirPath.PassValue()
	allocs81a31e9b.Borrow(ccache_dir_path_allocs)

	var ccomm_r_allocs *cgoAllocMap
	ref81a31e9b.comm_r, ccomm_r_allocs = *(*[32]C.uint8_t)(unsafe.Pointer(&x.CommR)), cgoAllocsUnknown
	allocs81a31e9b.Borrow(ccomm_r_allocs)

	var creplica_path_allocs *cgoAllocMap
	ref81a31e9b.replica_path, creplica_path_allocs = x.ReplicaPath.PassValue()
	allocs81a31e9b.Borrow(creplica_path_allocs)

	var csector_id_allocs *cgoAllocMap
	ref81a31e9b.sector_id, csector_id_allocs = (C.uint64_t)(x.SectorId), cgoAllocsUnknown
	allocs81a31e9b.Borrow(csector_id_allocs)

	x.ref81a31e9b = ref81a31e9b
	x.allocs81a31e9b = allocs81a31e9b
	return ref81a31e9b, allocs81a31e9b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilPrivateReplicaInfo) PassValue() (C.fil_PrivateReplicaInfo, *cgoAllocMap) {
	if x.ref81a31e9b != nil {
		return *x.ref81a31e9b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilPrivateReplicaInfo) Deref() {
	if x.ref81a31e9b == nil {
		return
	}
	x.RegisteredProof = (FilRegisteredPoStProof)(x.ref81a31e9b.registered_proof)
	x.CacheDirPath = *NewFilBytesRef(unsafe.Pointer(&x.ref81a31e9b.cache_dir_path))
	x.CommR = *(*[32]byte)(unsafe.Pointer(&x.ref81a31e9b.comm_r))
	x.ReplicaPath = *NewFilBytesRef(unsafe.Pointer(&x.ref81a31e9b.replica_path))
	x.SectorId = (uint64)(x.ref81a31e9b.sector_id)
}

// allocFilPoStProofMemory allocates memory for type C.fil_PoStProof in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilPoStProofMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilPoStProofValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilPoStProofValue = unsafe.Sizeof([1]C.fil_PoStProof{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilPoStProof) Ref() *C.fil_PoStProof {
	if x == nil {
		return nil
	}
	return x.ref3451bfa
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilPoStProof) Free() {
	if x != nil && x.allocs3451bfa != nil {
		x.allocs3451bfa.(*cgoAllocMap).Free()
		x.ref3451bfa = nil
	}
}

// NewFilPoStProofRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilPoStProofRef(ref unsafe.Pointer) *FilPoStProof {
	if ref == nil {
		return nil
	}
	obj := new(FilPoStProof)
	obj.ref3451bfa = (*C.fil_PoStProof)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilPoStProof) PassRef() (*C.fil_PoStProof, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3451bfa != nil {
		return x.ref3451bfa, nil
	}
	mem3451bfa := allocFilPoStProofMemory(1)
	ref3451bfa := (*C.fil_PoStProof)(mem3451bfa)
	allocs3451bfa := new(cgoAllocMap)
	allocs3451bfa.Add(mem3451bfa)

	var cregistered_proof_allocs *cgoAllocMap
	ref3451bfa.registered_proof, cregistered_proof_allocs = (C.fil_RegisteredPoStProof)(x.RegisteredProof), cgoAllocsUnknown
	allocs3451bfa.Borrow(cregistered_proof_allocs)

	var cproof_allocs *cgoAllocMap
	ref3451bfa.proof, cproof_allocs = x.Proof.PassValue()
	allocs3451bfa.Borrow(cproof_allocs)

	x.ref3451bfa = ref3451bfa
	x.allocs3451bfa = allocs3451bfa
	return ref3451bfa, allocs3451bfa

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilPoStProof) PassValue() (C.fil_PoStProof, *cgoAllocMap) {
	if x.ref3451bfa != nil {
		return *x.ref3451bfa, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilPoStProof) Deref() {
	if x.ref3451bfa == nil {
		return
	}
	x.RegisteredProof = (FilRegisteredPoStProof)(x.ref3451bfa.registered_proof)
	x.Proof = *NewFilBytesRef(unsafe.Pointer(&x.ref3451bfa.proof))
}

// allocFilArrayPoStProofMemory allocates memory for type C.fil_Array_PoStProof in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilArrayPoStProofMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilArrayPoStProofValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilArrayPoStProofValue = unsafe.Sizeof([1]C.fil_Array_PoStProof{})

// allocPStructFilPoStProofMemory allocates memory for type *C.struct_fil_PoStProof in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPStructFilPoStProofMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPStructFilPoStProofValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPStructFilPoStProofValue = unsafe.Sizeof([1]*C.struct_fil_PoStProof{})

// allocStructFilPoStProofMemory allocates memory for type C.struct_fil_PoStProof in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructFilPoStProofMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructFilPoStProofValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStructFilPoStProofValue = unsafe.Sizeof([1]C.struct_fil_PoStProof{})

// unpackSSFilPoStProof transforms a sliced Go data structure into plain C format.
func unpackSSFilPoStProof(x [][]FilPoStProof) (unpacked **C.struct_fil_PoStProof, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPStructFilPoStProofMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.struct_fil_PoStProof)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocStructFilPoStProofMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.struct_fil_PoStProof)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.struct_fil_PoStProof)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.struct_fil_PoStProof)(h.Data)
	return
}

// packSSFilPoStProof reads sliced Go data structure out from plain C format.
func packSSFilPoStProof(v [][]FilPoStProof, ptr0 **C.struct_fil_PoStProof) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.struct_fil_PoStProof)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfStructFilPoStProofValue]C.struct_fil_PoStProof)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewFilPoStProofRef(unsafe.Pointer(&ptr2))
		}
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilArrayPoStProof) Ref() *C.fil_Array_PoStProof {
	if x == nil {
		return nil
	}
	return x.ref4afd40c2
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilArrayPoStProof) Free() {
	if x != nil && x.allocs4afd40c2 != nil {
		x.allocs4afd40c2.(*cgoAllocMap).Free()
		x.ref4afd40c2 = nil
	}
}

// NewFilArrayPoStProofRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilArrayPoStProofRef(ref unsafe.Pointer) *FilArrayPoStProof {
	if ref == nil {
		return nil
	}
	obj := new(FilArrayPoStProof)
	obj.ref4afd40c2 = (*C.fil_Array_PoStProof)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilArrayPoStProof) PassRef() (*C.fil_Array_PoStProof, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4afd40c2 != nil {
		return x.ref4afd40c2, nil
	}
	mem4afd40c2 := allocFilArrayPoStProofMemory(1)
	ref4afd40c2 := (*C.fil_Array_PoStProof)(mem4afd40c2)
	allocs4afd40c2 := new(cgoAllocMap)
	allocs4afd40c2.Add(mem4afd40c2)

	var cptr_allocs *cgoAllocMap
	ref4afd40c2.ptr, cptr_allocs = unpackSSFilPoStProof(x.Ptr)
	allocs4afd40c2.Borrow(cptr_allocs)

	var clen_allocs *cgoAllocMap
	ref4afd40c2.len, clen_allocs = (C.uintptr_t)(x.Len), cgoAllocsUnknown
	allocs4afd40c2.Borrow(clen_allocs)

	x.ref4afd40c2 = ref4afd40c2
	x.allocs4afd40c2 = allocs4afd40c2
	return ref4afd40c2, allocs4afd40c2

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilArrayPoStProof) PassValue() (C.fil_Array_PoStProof, *cgoAllocMap) {
	if x.ref4afd40c2 != nil {
		return *x.ref4afd40c2, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilArrayPoStProof) Deref() {
	if x.ref4afd40c2 == nil {
		return
	}
	packSSFilPoStProof(x.Ptr, x.ref4afd40c2.ptr)
	x.Len = (uint64)(x.ref4afd40c2.len)
}

// allocFilResultArrayPoStProofMemory allocates memory for type C.fil_Result_Array_PoStProof in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilResultArrayPoStProofMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilResultArrayPoStProofValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilResultArrayPoStProofValue = unsafe.Sizeof([1]C.fil_Result_Array_PoStProof{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilResultArrayPoStProof) Ref() *C.fil_Result_Array_PoStProof {
	if x == nil {
		return nil
	}
	return x.refbed55aa5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilResultArrayPoStProof) Free() {
	if x != nil && x.allocsbed55aa5 != nil {
		x.allocsbed55aa5.(*cgoAllocMap).Free()
		x.refbed55aa5 = nil
	}
}

// NewFilResultArrayPoStProofRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilResultArrayPoStProofRef(ref unsafe.Pointer) *FilResultArrayPoStProof {
	if ref == nil {
		return nil
	}
	obj := new(FilResultArrayPoStProof)
	obj.refbed55aa5 = (*C.fil_Result_Array_PoStProof)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilResultArrayPoStProof) PassRef() (*C.fil_Result_Array_PoStProof, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refbed55aa5 != nil {
		return x.refbed55aa5, nil
	}
	membed55aa5 := allocFilResultArrayPoStProofMemory(1)
	refbed55aa5 := (*C.fil_Result_Array_PoStProof)(membed55aa5)
	allocsbed55aa5 := new(cgoAllocMap)
	allocsbed55aa5.Add(membed55aa5)

	var cstatus_code_allocs *cgoAllocMap
	refbed55aa5.status_code, cstatus_code_allocs = (C.fil_FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocsbed55aa5.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	refbed55aa5.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocsbed55aa5.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	refbed55aa5.value, cvalue_allocs = x.Value.PassValue()
	allocsbed55aa5.Borrow(cvalue_allocs)

	x.refbed55aa5 = refbed55aa5
	x.allocsbed55aa5 = allocsbed55aa5
	return refbed55aa5, allocsbed55aa5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilResultArrayPoStProof) PassValue() (C.fil_Result_Array_PoStProof, *cgoAllocMap) {
	if x.refbed55aa5 != nil {
		return *x.refbed55aa5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilResultArrayPoStProof) Deref() {
	if x.refbed55aa5 == nil {
		return
	}
	x.StatusCode = (FilFCPResponseStatus)(x.refbed55aa5.status_code)
	x.ErrorMsg = *NewFilBytesRef(unsafe.Pointer(&x.refbed55aa5.error_msg))
	x.Value = *NewFilArrayPoStProofRef(unsafe.Pointer(&x.refbed55aa5.value))
}

// allocFilGenerateWinningPoStResponseMemory allocates memory for type C.fil_GenerateWinningPoStResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilGenerateWinningPoStResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilGenerateWinningPoStResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilGenerateWinningPoStResponseValue = unsafe.Sizeof([1]C.fil_GenerateWinningPoStResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilGenerateWinningPoStResponse) Ref() *C.fil_GenerateWinningPoStResponse {
	if x == nil {
		return nil
	}
	return x.ref1405b8ec
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilGenerateWinningPoStResponse) Free() {
	if x != nil && x.allocs1405b8ec != nil {
		x.allocs1405b8ec.(*cgoAllocMap).Free()
		x.ref1405b8ec = nil
	}
}

// NewFilGenerateWinningPoStResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilGenerateWinningPoStResponseRef(ref unsafe.Pointer) *FilGenerateWinningPoStResponse {
	if ref == nil {
		return nil
	}
	obj := new(FilGenerateWinningPoStResponse)
	obj.ref1405b8ec = (*C.fil_GenerateWinningPoStResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilGenerateWinningPoStResponse) PassRef() (*C.fil_GenerateWinningPoStResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1405b8ec != nil {
		return x.ref1405b8ec, nil
	}
	mem1405b8ec := allocFilGenerateWinningPoStResponseMemory(1)
	ref1405b8ec := (*C.fil_GenerateWinningPoStResponse)(mem1405b8ec)
	allocs1405b8ec := new(cgoAllocMap)
	allocs1405b8ec.Add(mem1405b8ec)

	var cstatus_code_allocs *cgoAllocMap
	ref1405b8ec.status_code, cstatus_code_allocs = (C.fil_FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocs1405b8ec.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref1405b8ec.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocs1405b8ec.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	ref1405b8ec.value, cvalue_allocs = x.Value.PassValue()
	allocs1405b8ec.Borrow(cvalue_allocs)

	x.ref1405b8ec = ref1405b8ec
	x.allocs1405b8ec = allocs1405b8ec
	return ref1405b8ec, allocs1405b8ec

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilGenerateWinningPoStResponse) PassValue() (C.fil_GenerateWinningPoStResponse, *cgoAllocMap) {
	if x.ref1405b8ec != nil {
		return *x.ref1405b8ec, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilGenerateWinningPoStResponse) Deref() {
	if x.ref1405b8ec == nil {
		return
	}
	x.StatusCode = (FilFCPResponseStatus)(x.ref1405b8ec.status_code)
	x.ErrorMsg = *NewFilBytesRef(unsafe.Pointer(&x.ref1405b8ec.error_msg))
	x.Value = *NewFilArrayPoStProofRef(unsafe.Pointer(&x.ref1405b8ec.value))
}

// allocFilArrayVanillaProofMemory allocates memory for type C.fil_Array_VanillaProof in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilArrayVanillaProofMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilArrayVanillaProofValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilArrayVanillaProofValue = unsafe.Sizeof([1]C.fil_Array_VanillaProof{})

// allocPFilVanillaProofMemory allocates memory for type *C.fil_VanillaProof in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPFilVanillaProofMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPFilVanillaProofValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPFilVanillaProofValue = unsafe.Sizeof([1]*C.fil_VanillaProof{})

// allocFilVanillaProofMemory allocates memory for type C.fil_VanillaProof in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilVanillaProofMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilVanillaProofValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilVanillaProofValue = unsafe.Sizeof([1]C.fil_VanillaProof{})

// unpackSSFilVanillaProof transforms a sliced Go data structure into plain C format.
func unpackSSFilVanillaProof(x [][]FilVanillaProof) (unpacked **C.fil_VanillaProof, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPFilVanillaProofMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.fil_VanillaProof)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocFilVanillaProofMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.fil_VanillaProof)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.fil_VanillaProof)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.fil_VanillaProof)(h.Data)
	return
}

// packSSFilVanillaProof reads sliced Go data structure out from plain C format.
func packSSFilVanillaProof(v [][]FilVanillaProof, ptr0 **C.fil_VanillaProof) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.fil_VanillaProof)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfFilVanillaProofValue]C.fil_VanillaProof)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewFilVanillaProofRef(unsafe.Pointer(&ptr2))
		}
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilArrayVanillaProof) Ref() *C.fil_Array_VanillaProof {
	if x == nil {
		return nil
	}
	return x.ref56a68cc
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilArrayVanillaProof) Free() {
	if x != nil && x.allocs56a68cc != nil {
		x.allocs56a68cc.(*cgoAllocMap).Free()
		x.ref56a68cc = nil
	}
}

// NewFilArrayVanillaProofRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilArrayVanillaProofRef(ref unsafe.Pointer) *FilArrayVanillaProof {
	if ref == nil {
		return nil
	}
	obj := new(FilArrayVanillaProof)
	obj.ref56a68cc = (*C.fil_Array_VanillaProof)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilArrayVanillaProof) PassRef() (*C.fil_Array_VanillaProof, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref56a68cc != nil {
		return x.ref56a68cc, nil
	}
	mem56a68cc := allocFilArrayVanillaProofMemory(1)
	ref56a68cc := (*C.fil_Array_VanillaProof)(mem56a68cc)
	allocs56a68cc := new(cgoAllocMap)
	allocs56a68cc.Add(mem56a68cc)

	var cptr_allocs *cgoAllocMap
	ref56a68cc.ptr, cptr_allocs = unpackSSFilVanillaProof(x.Ptr)
	allocs56a68cc.Borrow(cptr_allocs)

	var clen_allocs *cgoAllocMap
	ref56a68cc.len, clen_allocs = (C.uintptr_t)(x.Len), cgoAllocsUnknown
	allocs56a68cc.Borrow(clen_allocs)

	x.ref56a68cc = ref56a68cc
	x.allocs56a68cc = allocs56a68cc
	return ref56a68cc, allocs56a68cc

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilArrayVanillaProof) PassValue() (C.fil_Array_VanillaProof, *cgoAllocMap) {
	if x.ref56a68cc != nil {
		return *x.ref56a68cc, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilArrayVanillaProof) Deref() {
	if x.ref56a68cc == nil {
		return
	}
	packSSFilVanillaProof(x.Ptr, x.ref56a68cc.ptr)
	x.Len = (uint64)(x.ref56a68cc.len)
}

// allocFilArrayPrivateReplicaInfoMemory allocates memory for type C.fil_Array_PrivateReplicaInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilArrayPrivateReplicaInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilArrayPrivateReplicaInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilArrayPrivateReplicaInfoValue = unsafe.Sizeof([1]C.fil_Array_PrivateReplicaInfo{})

// allocPStructFilPrivateReplicaInfoMemory allocates memory for type *C.struct_fil_PrivateReplicaInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPStructFilPrivateReplicaInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPStructFilPrivateReplicaInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPStructFilPrivateReplicaInfoValue = unsafe.Sizeof([1]*C.struct_fil_PrivateReplicaInfo{})

// allocStructFilPrivateReplicaInfoMemory allocates memory for type C.struct_fil_PrivateReplicaInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructFilPrivateReplicaInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructFilPrivateReplicaInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStructFilPrivateReplicaInfoValue = unsafe.Sizeof([1]C.struct_fil_PrivateReplicaInfo{})

// unpackSSFilPrivateReplicaInfo transforms a sliced Go data structure into plain C format.
func unpackSSFilPrivateReplicaInfo(x [][]FilPrivateReplicaInfo) (unpacked **C.struct_fil_PrivateReplicaInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPStructFilPrivateReplicaInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.struct_fil_PrivateReplicaInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocStructFilPrivateReplicaInfoMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.struct_fil_PrivateReplicaInfo)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.struct_fil_PrivateReplicaInfo)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.struct_fil_PrivateReplicaInfo)(h.Data)
	return
}

// packSSFilPrivateReplicaInfo reads sliced Go data structure out from plain C format.
func packSSFilPrivateReplicaInfo(v [][]FilPrivateReplicaInfo, ptr0 **C.struct_fil_PrivateReplicaInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.struct_fil_PrivateReplicaInfo)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfStructFilPrivateReplicaInfoValue]C.struct_fil_PrivateReplicaInfo)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewFilPrivateReplicaInfoRef(unsafe.Pointer(&ptr2))
		}
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilArrayPrivateReplicaInfo) Ref() *C.fil_Array_PrivateReplicaInfo {
	if x == nil {
		return nil
	}
	return x.ref27cbc9a2
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilArrayPrivateReplicaInfo) Free() {
	if x != nil && x.allocs27cbc9a2 != nil {
		x.allocs27cbc9a2.(*cgoAllocMap).Free()
		x.ref27cbc9a2 = nil
	}
}

// NewFilArrayPrivateReplicaInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilArrayPrivateReplicaInfoRef(ref unsafe.Pointer) *FilArrayPrivateReplicaInfo {
	if ref == nil {
		return nil
	}
	obj := new(FilArrayPrivateReplicaInfo)
	obj.ref27cbc9a2 = (*C.fil_Array_PrivateReplicaInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilArrayPrivateReplicaInfo) PassRef() (*C.fil_Array_PrivateReplicaInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref27cbc9a2 != nil {
		return x.ref27cbc9a2, nil
	}
	mem27cbc9a2 := allocFilArrayPrivateReplicaInfoMemory(1)
	ref27cbc9a2 := (*C.fil_Array_PrivateReplicaInfo)(mem27cbc9a2)
	allocs27cbc9a2 := new(cgoAllocMap)
	allocs27cbc9a2.Add(mem27cbc9a2)

	var cptr_allocs *cgoAllocMap
	ref27cbc9a2.ptr, cptr_allocs = unpackSSFilPrivateReplicaInfo(x.Ptr)
	allocs27cbc9a2.Borrow(cptr_allocs)

	var clen_allocs *cgoAllocMap
	ref27cbc9a2.len, clen_allocs = (C.uintptr_t)(x.Len), cgoAllocsUnknown
	allocs27cbc9a2.Borrow(clen_allocs)

	x.ref27cbc9a2 = ref27cbc9a2
	x.allocs27cbc9a2 = allocs27cbc9a2
	return ref27cbc9a2, allocs27cbc9a2

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilArrayPrivateReplicaInfo) PassValue() (C.fil_Array_PrivateReplicaInfo, *cgoAllocMap) {
	if x.ref27cbc9a2 != nil {
		return *x.ref27cbc9a2, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilArrayPrivateReplicaInfo) Deref() {
	if x.ref27cbc9a2 == nil {
		return
	}
	packSSFilPrivateReplicaInfo(x.Ptr, x.ref27cbc9a2.ptr)
	x.Len = (uint64)(x.ref27cbc9a2.len)
}

// allocFilVerifyWinningPoStResponseMemory allocates memory for type C.fil_VerifyWinningPoStResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilVerifyWinningPoStResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilVerifyWinningPoStResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilVerifyWinningPoStResponseValue = unsafe.Sizeof([1]C.fil_VerifyWinningPoStResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilVerifyWinningPoStResponse) Ref() *C.fil_VerifyWinningPoStResponse {
	if x == nil {
		return nil
	}
	return x.refaca6860c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilVerifyWinningPoStResponse) Free() {
	if x != nil && x.allocsaca6860c != nil {
		x.allocsaca6860c.(*cgoAllocMap).Free()
		x.refaca6860c = nil
	}
}

// NewFilVerifyWinningPoStResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilVerifyWinningPoStResponseRef(ref unsafe.Pointer) *FilVerifyWinningPoStResponse {
	if ref == nil {
		return nil
	}
	obj := new(FilVerifyWinningPoStResponse)
	obj.refaca6860c = (*C.fil_VerifyWinningPoStResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilVerifyWinningPoStResponse) PassRef() (*C.fil_VerifyWinningPoStResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refaca6860c != nil {
		return x.refaca6860c, nil
	}
	memaca6860c := allocFilVerifyWinningPoStResponseMemory(1)
	refaca6860c := (*C.fil_VerifyWinningPoStResponse)(memaca6860c)
	allocsaca6860c := new(cgoAllocMap)
	allocsaca6860c.Add(memaca6860c)

	var cstatus_code_allocs *cgoAllocMap
	refaca6860c.status_code, cstatus_code_allocs = (C.fil_FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocsaca6860c.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	refaca6860c.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocsaca6860c.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	refaca6860c.value, cvalue_allocs = (C._Bool)(x.Value), cgoAllocsUnknown
	allocsaca6860c.Borrow(cvalue_allocs)

	x.refaca6860c = refaca6860c
	x.allocsaca6860c = allocsaca6860c
	return refaca6860c, allocsaca6860c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilVerifyWinningPoStResponse) PassValue() (C.fil_VerifyWinningPoStResponse, *cgoAllocMap) {
	if x.refaca6860c != nil {
		return *x.refaca6860c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilVerifyWinningPoStResponse) Deref() {
	if x.refaca6860c == nil {
		return
	}
	x.StatusCode = (FilFCPResponseStatus)(x.refaca6860c.status_code)
	x.ErrorMsg = *NewFilBytesRef(unsafe.Pointer(&x.refaca6860c.error_msg))
	x.Value = (bool)(x.refaca6860c.value)
}

// allocFilPublicReplicaInfoMemory allocates memory for type C.fil_PublicReplicaInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilPublicReplicaInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilPublicReplicaInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilPublicReplicaInfoValue = unsafe.Sizeof([1]C.fil_PublicReplicaInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilPublicReplicaInfo) Ref() *C.fil_PublicReplicaInfo {
	if x == nil {
		return nil
	}
	return x.ref81b617c2
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilPublicReplicaInfo) Free() {
	if x != nil && x.allocs81b617c2 != nil {
		x.allocs81b617c2.(*cgoAllocMap).Free()
		x.ref81b617c2 = nil
	}
}

// NewFilPublicReplicaInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilPublicReplicaInfoRef(ref unsafe.Pointer) *FilPublicReplicaInfo {
	if ref == nil {
		return nil
	}
	obj := new(FilPublicReplicaInfo)
	obj.ref81b617c2 = (*C.fil_PublicReplicaInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilPublicReplicaInfo) PassRef() (*C.fil_PublicReplicaInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref81b617c2 != nil {
		return x.ref81b617c2, nil
	}
	mem81b617c2 := allocFilPublicReplicaInfoMemory(1)
	ref81b617c2 := (*C.fil_PublicReplicaInfo)(mem81b617c2)
	allocs81b617c2 := new(cgoAllocMap)
	allocs81b617c2.Add(mem81b617c2)

	var cregistered_proof_allocs *cgoAllocMap
	ref81b617c2.registered_proof, cregistered_proof_allocs = (C.fil_RegisteredPoStProof)(x.RegisteredProof), cgoAllocsUnknown
	allocs81b617c2.Borrow(cregistered_proof_allocs)

	var ccomm_r_allocs *cgoAllocMap
	ref81b617c2.comm_r, ccomm_r_allocs = *(*[32]C.uint8_t)(unsafe.Pointer(&x.CommR)), cgoAllocsUnknown
	allocs81b617c2.Borrow(ccomm_r_allocs)

	var csector_id_allocs *cgoAllocMap
	ref81b617c2.sector_id, csector_id_allocs = (C.uint64_t)(x.SectorId), cgoAllocsUnknown
	allocs81b617c2.Borrow(csector_id_allocs)

	x.ref81b617c2 = ref81b617c2
	x.allocs81b617c2 = allocs81b617c2
	return ref81b617c2, allocs81b617c2

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilPublicReplicaInfo) PassValue() (C.fil_PublicReplicaInfo, *cgoAllocMap) {
	if x.ref81b617c2 != nil {
		return *x.ref81b617c2, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilPublicReplicaInfo) Deref() {
	if x.ref81b617c2 == nil {
		return
	}
	x.RegisteredProof = (FilRegisteredPoStProof)(x.ref81b617c2.registered_proof)
	x.CommR = *(*[32]byte)(unsafe.Pointer(&x.ref81b617c2.comm_r))
	x.SectorId = (uint64)(x.ref81b617c2.sector_id)
}

// allocFilArrayPublicReplicaInfoMemory allocates memory for type C.fil_Array_PublicReplicaInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilArrayPublicReplicaInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilArrayPublicReplicaInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilArrayPublicReplicaInfoValue = unsafe.Sizeof([1]C.fil_Array_PublicReplicaInfo{})

// allocPStructFilPublicReplicaInfoMemory allocates memory for type *C.struct_fil_PublicReplicaInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPStructFilPublicReplicaInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPStructFilPublicReplicaInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPStructFilPublicReplicaInfoValue = unsafe.Sizeof([1]*C.struct_fil_PublicReplicaInfo{})

// allocStructFilPublicReplicaInfoMemory allocates memory for type C.struct_fil_PublicReplicaInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructFilPublicReplicaInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructFilPublicReplicaInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStructFilPublicReplicaInfoValue = unsafe.Sizeof([1]C.struct_fil_PublicReplicaInfo{})

// unpackSSFilPublicReplicaInfo transforms a sliced Go data structure into plain C format.
func unpackSSFilPublicReplicaInfo(x [][]FilPublicReplicaInfo) (unpacked **C.struct_fil_PublicReplicaInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPStructFilPublicReplicaInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.struct_fil_PublicReplicaInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocStructFilPublicReplicaInfoMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.struct_fil_PublicReplicaInfo)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.struct_fil_PublicReplicaInfo)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.struct_fil_PublicReplicaInfo)(h.Data)
	return
}

// packSSFilPublicReplicaInfo reads sliced Go data structure out from plain C format.
func packSSFilPublicReplicaInfo(v [][]FilPublicReplicaInfo, ptr0 **C.struct_fil_PublicReplicaInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.struct_fil_PublicReplicaInfo)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfStructFilPublicReplicaInfoValue]C.struct_fil_PublicReplicaInfo)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewFilPublicReplicaInfoRef(unsafe.Pointer(&ptr2))
		}
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilArrayPublicReplicaInfo) Ref() *C.fil_Array_PublicReplicaInfo {
	if x == nil {
		return nil
	}
	return x.ref55364967
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilArrayPublicReplicaInfo) Free() {
	if x != nil && x.allocs55364967 != nil {
		x.allocs55364967.(*cgoAllocMap).Free()
		x.ref55364967 = nil
	}
}

// NewFilArrayPublicReplicaInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilArrayPublicReplicaInfoRef(ref unsafe.Pointer) *FilArrayPublicReplicaInfo {
	if ref == nil {
		return nil
	}
	obj := new(FilArrayPublicReplicaInfo)
	obj.ref55364967 = (*C.fil_Array_PublicReplicaInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilArrayPublicReplicaInfo) PassRef() (*C.fil_Array_PublicReplicaInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref55364967 != nil {
		return x.ref55364967, nil
	}
	mem55364967 := allocFilArrayPublicReplicaInfoMemory(1)
	ref55364967 := (*C.fil_Array_PublicReplicaInfo)(mem55364967)
	allocs55364967 := new(cgoAllocMap)
	allocs55364967.Add(mem55364967)

	var cptr_allocs *cgoAllocMap
	ref55364967.ptr, cptr_allocs = unpackSSFilPublicReplicaInfo(x.Ptr)
	allocs55364967.Borrow(cptr_allocs)

	var clen_allocs *cgoAllocMap
	ref55364967.len, clen_allocs = (C.uintptr_t)(x.Len), cgoAllocsUnknown
	allocs55364967.Borrow(clen_allocs)

	x.ref55364967 = ref55364967
	x.allocs55364967 = allocs55364967
	return ref55364967, allocs55364967

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilArrayPublicReplicaInfo) PassValue() (C.fil_Array_PublicReplicaInfo, *cgoAllocMap) {
	if x.ref55364967 != nil {
		return *x.ref55364967, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilArrayPublicReplicaInfo) Deref() {
	if x.ref55364967 == nil {
		return
	}
	packSSFilPublicReplicaInfo(x.Ptr, x.ref55364967.ptr)
	x.Len = (uint64)(x.ref55364967.len)
}

// allocFilGenerateWindowPoStMemory allocates memory for type C.fil_GenerateWindowPoSt in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilGenerateWindowPoStMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilGenerateWindowPoStValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilGenerateWindowPoStValue = unsafe.Sizeof([1]C.fil_GenerateWindowPoSt{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilGenerateWindowPoSt) Ref() *C.fil_GenerateWindowPoSt {
	if x == nil {
		return nil
	}
	return x.ref276e4853
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilGenerateWindowPoSt) Free() {
	if x != nil && x.allocs276e4853 != nil {
		x.allocs276e4853.(*cgoAllocMap).Free()
		x.ref276e4853 = nil
	}
}

// NewFilGenerateWindowPoStRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilGenerateWindowPoStRef(ref unsafe.Pointer) *FilGenerateWindowPoSt {
	if ref == nil {
		return nil
	}
	obj := new(FilGenerateWindowPoSt)
	obj.ref276e4853 = (*C.fil_GenerateWindowPoSt)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilGenerateWindowPoSt) PassRef() (*C.fil_GenerateWindowPoSt, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref276e4853 != nil {
		return x.ref276e4853, nil
	}
	mem276e4853 := allocFilGenerateWindowPoStMemory(1)
	ref276e4853 := (*C.fil_GenerateWindowPoSt)(mem276e4853)
	allocs276e4853 := new(cgoAllocMap)
	allocs276e4853.Add(mem276e4853)

	var cproofs_allocs *cgoAllocMap
	ref276e4853.proofs, cproofs_allocs = x.Proofs.PassValue()
	allocs276e4853.Borrow(cproofs_allocs)

	var cfaulty_sectors_allocs *cgoAllocMap
	ref276e4853.faulty_sectors, cfaulty_sectors_allocs = x.FaultySectors.PassValue()
	allocs276e4853.Borrow(cfaulty_sectors_allocs)

	x.ref276e4853 = ref276e4853
	x.allocs276e4853 = allocs276e4853
	return ref276e4853, allocs276e4853

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilGenerateWindowPoSt) PassValue() (C.fil_GenerateWindowPoSt, *cgoAllocMap) {
	if x.ref276e4853 != nil {
		return *x.ref276e4853, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilGenerateWindowPoSt) Deref() {
	if x.ref276e4853 == nil {
		return
	}
	x.Proofs = *NewFilArrayPoStProofRef(unsafe.Pointer(&x.ref276e4853.proofs))
	x.FaultySectors = *NewFilArrayU64Ref(unsafe.Pointer(&x.ref276e4853.faulty_sectors))
}

// allocFilResultGenerateWindowPoStMemory allocates memory for type C.fil_Result_GenerateWindowPoSt in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilResultGenerateWindowPoStMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilResultGenerateWindowPoStValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilResultGenerateWindowPoStValue = unsafe.Sizeof([1]C.fil_Result_GenerateWindowPoSt{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilResultGenerateWindowPoSt) Ref() *C.fil_Result_GenerateWindowPoSt {
	if x == nil {
		return nil
	}
	return x.refef6ec723
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilResultGenerateWindowPoSt) Free() {
	if x != nil && x.allocsef6ec723 != nil {
		x.allocsef6ec723.(*cgoAllocMap).Free()
		x.refef6ec723 = nil
	}
}

// NewFilResultGenerateWindowPoStRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilResultGenerateWindowPoStRef(ref unsafe.Pointer) *FilResultGenerateWindowPoSt {
	if ref == nil {
		return nil
	}
	obj := new(FilResultGenerateWindowPoSt)
	obj.refef6ec723 = (*C.fil_Result_GenerateWindowPoSt)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilResultGenerateWindowPoSt) PassRef() (*C.fil_Result_GenerateWindowPoSt, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refef6ec723 != nil {
		return x.refef6ec723, nil
	}
	memef6ec723 := allocFilResultGenerateWindowPoStMemory(1)
	refef6ec723 := (*C.fil_Result_GenerateWindowPoSt)(memef6ec723)
	allocsef6ec723 := new(cgoAllocMap)
	allocsef6ec723.Add(memef6ec723)

	var cstatus_code_allocs *cgoAllocMap
	refef6ec723.status_code, cstatus_code_allocs = (C.fil_FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocsef6ec723.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	refef6ec723.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocsef6ec723.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	refef6ec723.value, cvalue_allocs = x.Value.PassValue()
	allocsef6ec723.Borrow(cvalue_allocs)

	x.refef6ec723 = refef6ec723
	x.allocsef6ec723 = allocsef6ec723
	return refef6ec723, allocsef6ec723

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilResultGenerateWindowPoSt) PassValue() (C.fil_Result_GenerateWindowPoSt, *cgoAllocMap) {
	if x.refef6ec723 != nil {
		return *x.refef6ec723, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilResultGenerateWindowPoSt) Deref() {
	if x.refef6ec723 == nil {
		return
	}
	x.StatusCode = (FilFCPResponseStatus)(x.refef6ec723.status_code)
	x.ErrorMsg = *NewFilBytesRef(unsafe.Pointer(&x.refef6ec723.error_msg))
	x.Value = *NewFilGenerateWindowPoStRef(unsafe.Pointer(&x.refef6ec723.value))
}

// allocFilGenerateWindowPoStResponseMemory allocates memory for type C.fil_GenerateWindowPoStResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilGenerateWindowPoStResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilGenerateWindowPoStResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilGenerateWindowPoStResponseValue = unsafe.Sizeof([1]C.fil_GenerateWindowPoStResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilGenerateWindowPoStResponse) Ref() *C.fil_GenerateWindowPoStResponse {
	if x == nil {
		return nil
	}
	return x.ref2a5f3ba8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilGenerateWindowPoStResponse) Free() {
	if x != nil && x.allocs2a5f3ba8 != nil {
		x.allocs2a5f3ba8.(*cgoAllocMap).Free()
		x.ref2a5f3ba8 = nil
	}
}

// NewFilGenerateWindowPoStResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilGenerateWindowPoStResponseRef(ref unsafe.Pointer) *FilGenerateWindowPoStResponse {
	if ref == nil {
		return nil
	}
	obj := new(FilGenerateWindowPoStResponse)
	obj.ref2a5f3ba8 = (*C.fil_GenerateWindowPoStResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilGenerateWindowPoStResponse) PassRef() (*C.fil_GenerateWindowPoStResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2a5f3ba8 != nil {
		return x.ref2a5f3ba8, nil
	}
	mem2a5f3ba8 := allocFilGenerateWindowPoStResponseMemory(1)
	ref2a5f3ba8 := (*C.fil_GenerateWindowPoStResponse)(mem2a5f3ba8)
	allocs2a5f3ba8 := new(cgoAllocMap)
	allocs2a5f3ba8.Add(mem2a5f3ba8)

	var cstatus_code_allocs *cgoAllocMap
	ref2a5f3ba8.status_code, cstatus_code_allocs = (C.fil_FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocs2a5f3ba8.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref2a5f3ba8.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocs2a5f3ba8.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	ref2a5f3ba8.value, cvalue_allocs = x.Value.PassValue()
	allocs2a5f3ba8.Borrow(cvalue_allocs)

	x.ref2a5f3ba8 = ref2a5f3ba8
	x.allocs2a5f3ba8 = allocs2a5f3ba8
	return ref2a5f3ba8, allocs2a5f3ba8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilGenerateWindowPoStResponse) PassValue() (C.fil_GenerateWindowPoStResponse, *cgoAllocMap) {
	if x.ref2a5f3ba8 != nil {
		return *x.ref2a5f3ba8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilGenerateWindowPoStResponse) Deref() {
	if x.ref2a5f3ba8 == nil {
		return
	}
	x.StatusCode = (FilFCPResponseStatus)(x.ref2a5f3ba8.status_code)
	x.ErrorMsg = *NewFilBytesRef(unsafe.Pointer(&x.ref2a5f3ba8.error_msg))
	x.Value = *NewFilGenerateWindowPoStRef(unsafe.Pointer(&x.ref2a5f3ba8.value))
}

// allocFilVerifyWindowPoStResponseMemory allocates memory for type C.fil_VerifyWindowPoStResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilVerifyWindowPoStResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilVerifyWindowPoStResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilVerifyWindowPoStResponseValue = unsafe.Sizeof([1]C.fil_VerifyWindowPoStResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilVerifyWindowPoStResponse) Ref() *C.fil_VerifyWindowPoStResponse {
	if x == nil {
		return nil
	}
	return x.ref34c4d49f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilVerifyWindowPoStResponse) Free() {
	if x != nil && x.allocs34c4d49f != nil {
		x.allocs34c4d49f.(*cgoAllocMap).Free()
		x.ref34c4d49f = nil
	}
}

// NewFilVerifyWindowPoStResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilVerifyWindowPoStResponseRef(ref unsafe.Pointer) *FilVerifyWindowPoStResponse {
	if ref == nil {
		return nil
	}
	obj := new(FilVerifyWindowPoStResponse)
	obj.ref34c4d49f = (*C.fil_VerifyWindowPoStResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilVerifyWindowPoStResponse) PassRef() (*C.fil_VerifyWindowPoStResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref34c4d49f != nil {
		return x.ref34c4d49f, nil
	}
	mem34c4d49f := allocFilVerifyWindowPoStResponseMemory(1)
	ref34c4d49f := (*C.fil_VerifyWindowPoStResponse)(mem34c4d49f)
	allocs34c4d49f := new(cgoAllocMap)
	allocs34c4d49f.Add(mem34c4d49f)

	var cstatus_code_allocs *cgoAllocMap
	ref34c4d49f.status_code, cstatus_code_allocs = (C.fil_FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocs34c4d49f.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref34c4d49f.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocs34c4d49f.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	ref34c4d49f.value, cvalue_allocs = (C._Bool)(x.Value), cgoAllocsUnknown
	allocs34c4d49f.Borrow(cvalue_allocs)

	x.ref34c4d49f = ref34c4d49f
	x.allocs34c4d49f = allocs34c4d49f
	return ref34c4d49f, allocs34c4d49f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilVerifyWindowPoStResponse) PassValue() (C.fil_VerifyWindowPoStResponse, *cgoAllocMap) {
	if x.ref34c4d49f != nil {
		return *x.ref34c4d49f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilVerifyWindowPoStResponse) Deref() {
	if x.ref34c4d49f == nil {
		return
	}
	x.StatusCode = (FilFCPResponseStatus)(x.ref34c4d49f.status_code)
	x.ErrorMsg = *NewFilBytesRef(unsafe.Pointer(&x.ref34c4d49f.error_msg))
	x.Value = (bool)(x.ref34c4d49f.value)
}

// allocFilResultPoStProofMemory allocates memory for type C.fil_Result_PoStProof in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilResultPoStProofMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilResultPoStProofValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilResultPoStProofValue = unsafe.Sizeof([1]C.fil_Result_PoStProof{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilResultPoStProof) Ref() *C.fil_Result_PoStProof {
	if x == nil {
		return nil
	}
	return x.ref47becaa1
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilResultPoStProof) Free() {
	if x != nil && x.allocs47becaa1 != nil {
		x.allocs47becaa1.(*cgoAllocMap).Free()
		x.ref47becaa1 = nil
	}
}

// NewFilResultPoStProofRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilResultPoStProofRef(ref unsafe.Pointer) *FilResultPoStProof {
	if ref == nil {
		return nil
	}
	obj := new(FilResultPoStProof)
	obj.ref47becaa1 = (*C.fil_Result_PoStProof)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilResultPoStProof) PassRef() (*C.fil_Result_PoStProof, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref47becaa1 != nil {
		return x.ref47becaa1, nil
	}
	mem47becaa1 := allocFilResultPoStProofMemory(1)
	ref47becaa1 := (*C.fil_Result_PoStProof)(mem47becaa1)
	allocs47becaa1 := new(cgoAllocMap)
	allocs47becaa1.Add(mem47becaa1)

	var cstatus_code_allocs *cgoAllocMap
	ref47becaa1.status_code, cstatus_code_allocs = (C.fil_FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocs47becaa1.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref47becaa1.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocs47becaa1.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	ref47becaa1.value, cvalue_allocs = x.Value.PassValue()
	allocs47becaa1.Borrow(cvalue_allocs)

	x.ref47becaa1 = ref47becaa1
	x.allocs47becaa1 = allocs47becaa1
	return ref47becaa1, allocs47becaa1

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilResultPoStProof) PassValue() (C.fil_Result_PoStProof, *cgoAllocMap) {
	if x.ref47becaa1 != nil {
		return *x.ref47becaa1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilResultPoStProof) Deref() {
	if x.ref47becaa1 == nil {
		return
	}
	x.StatusCode = (FilFCPResponseStatus)(x.ref47becaa1.status_code)
	x.ErrorMsg = *NewFilBytesRef(unsafe.Pointer(&x.ref47becaa1.error_msg))
	x.Value = *NewFilPoStProofRef(unsafe.Pointer(&x.ref47becaa1.value))
}

// allocFilMergeWindowPoStPartitionProofsResponseMemory allocates memory for type C.fil_MergeWindowPoStPartitionProofsResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilMergeWindowPoStPartitionProofsResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilMergeWindowPoStPartitionProofsResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilMergeWindowPoStPartitionProofsResponseValue = unsafe.Sizeof([1]C.fil_MergeWindowPoStPartitionProofsResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilMergeWindowPoStPartitionProofsResponse) Ref() *C.fil_MergeWindowPoStPartitionProofsResponse {
	if x == nil {
		return nil
	}
	return x.ref3369154e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilMergeWindowPoStPartitionProofsResponse) Free() {
	if x != nil && x.allocs3369154e != nil {
		x.allocs3369154e.(*cgoAllocMap).Free()
		x.ref3369154e = nil
	}
}

// NewFilMergeWindowPoStPartitionProofsResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilMergeWindowPoStPartitionProofsResponseRef(ref unsafe.Pointer) *FilMergeWindowPoStPartitionProofsResponse {
	if ref == nil {
		return nil
	}
	obj := new(FilMergeWindowPoStPartitionProofsResponse)
	obj.ref3369154e = (*C.fil_MergeWindowPoStPartitionProofsResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilMergeWindowPoStPartitionProofsResponse) PassRef() (*C.fil_MergeWindowPoStPartitionProofsResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3369154e != nil {
		return x.ref3369154e, nil
	}
	mem3369154e := allocFilMergeWindowPoStPartitionProofsResponseMemory(1)
	ref3369154e := (*C.fil_MergeWindowPoStPartitionProofsResponse)(mem3369154e)
	allocs3369154e := new(cgoAllocMap)
	allocs3369154e.Add(mem3369154e)

	var cstatus_code_allocs *cgoAllocMap
	ref3369154e.status_code, cstatus_code_allocs = (C.fil_FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocs3369154e.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref3369154e.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocs3369154e.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	ref3369154e.value, cvalue_allocs = x.Value.PassValue()
	allocs3369154e.Borrow(cvalue_allocs)

	x.ref3369154e = ref3369154e
	x.allocs3369154e = allocs3369154e
	return ref3369154e, allocs3369154e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilMergeWindowPoStPartitionProofsResponse) PassValue() (C.fil_MergeWindowPoStPartitionProofsResponse, *cgoAllocMap) {
	if x.ref3369154e != nil {
		return *x.ref3369154e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilMergeWindowPoStPartitionProofsResponse) Deref() {
	if x.ref3369154e == nil {
		return
	}
	x.StatusCode = (FilFCPResponseStatus)(x.ref3369154e.status_code)
	x.ErrorMsg = *NewFilBytesRef(unsafe.Pointer(&x.ref3369154e.error_msg))
	x.Value = *NewFilPoStProofRef(unsafe.Pointer(&x.ref3369154e.value))
}

// allocFilPartitionSnarkProofMemory allocates memory for type C.fil_PartitionSnarkProof in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilPartitionSnarkProofMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilPartitionSnarkProofValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilPartitionSnarkProofValue = unsafe.Sizeof([1]C.fil_PartitionSnarkProof{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilPartitionSnarkProof) Ref() *C.fil_PartitionSnarkProof {
	if x == nil {
		return nil
	}
	return x.ref4de03739
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilPartitionSnarkProof) Free() {
	if x != nil && x.allocs4de03739 != nil {
		x.allocs4de03739.(*cgoAllocMap).Free()
		x.ref4de03739 = nil
	}
}

// NewFilPartitionSnarkProofRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilPartitionSnarkProofRef(ref unsafe.Pointer) *FilPartitionSnarkProof {
	if ref == nil {
		return nil
	}
	obj := new(FilPartitionSnarkProof)
	obj.ref4de03739 = (*C.fil_PartitionSnarkProof)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilPartitionSnarkProof) PassRef() (*C.fil_PartitionSnarkProof, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4de03739 != nil {
		return x.ref4de03739, nil
	}
	mem4de03739 := allocFilPartitionSnarkProofMemory(1)
	ref4de03739 := (*C.fil_PartitionSnarkProof)(mem4de03739)
	allocs4de03739 := new(cgoAllocMap)
	allocs4de03739.Add(mem4de03739)

	var cregistered_proof_allocs *cgoAllocMap
	ref4de03739.registered_proof, cregistered_proof_allocs = (C.fil_RegisteredPoStProof)(x.RegisteredProof), cgoAllocsUnknown
	allocs4de03739.Borrow(cregistered_proof_allocs)

	var cproof_allocs *cgoAllocMap
	ref4de03739.proof, cproof_allocs = x.Proof.PassValue()
	allocs4de03739.Borrow(cproof_allocs)

	x.ref4de03739 = ref4de03739
	x.allocs4de03739 = allocs4de03739
	return ref4de03739, allocs4de03739

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilPartitionSnarkProof) PassValue() (C.fil_PartitionSnarkProof, *cgoAllocMap) {
	if x.ref4de03739 != nil {
		return *x.ref4de03739, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilPartitionSnarkProof) Deref() {
	if x.ref4de03739 == nil {
		return
	}
	x.RegisteredProof = (FilRegisteredPoStProof)(x.ref4de03739.registered_proof)
	x.Proof = *NewFilBytesRef(unsafe.Pointer(&x.ref4de03739.proof))
}

// allocFilArrayPartitionSnarkProofMemory allocates memory for type C.fil_Array_PartitionSnarkProof in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilArrayPartitionSnarkProofMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilArrayPartitionSnarkProofValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilArrayPartitionSnarkProofValue = unsafe.Sizeof([1]C.fil_Array_PartitionSnarkProof{})

// allocPStructFilPartitionSnarkProofMemory allocates memory for type *C.struct_fil_PartitionSnarkProof in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPStructFilPartitionSnarkProofMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPStructFilPartitionSnarkProofValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPStructFilPartitionSnarkProofValue = unsafe.Sizeof([1]*C.struct_fil_PartitionSnarkProof{})

// allocStructFilPartitionSnarkProofMemory allocates memory for type C.struct_fil_PartitionSnarkProof in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructFilPartitionSnarkProofMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructFilPartitionSnarkProofValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStructFilPartitionSnarkProofValue = unsafe.Sizeof([1]C.struct_fil_PartitionSnarkProof{})

// unpackSSFilPartitionSnarkProof transforms a sliced Go data structure into plain C format.
func unpackSSFilPartitionSnarkProof(x [][]FilPartitionSnarkProof) (unpacked **C.struct_fil_PartitionSnarkProof, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPStructFilPartitionSnarkProofMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.struct_fil_PartitionSnarkProof)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocStructFilPartitionSnarkProofMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.struct_fil_PartitionSnarkProof)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.struct_fil_PartitionSnarkProof)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.struct_fil_PartitionSnarkProof)(h.Data)
	return
}

// packSSFilPartitionSnarkProof reads sliced Go data structure out from plain C format.
func packSSFilPartitionSnarkProof(v [][]FilPartitionSnarkProof, ptr0 **C.struct_fil_PartitionSnarkProof) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.struct_fil_PartitionSnarkProof)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfStructFilPartitionSnarkProofValue]C.struct_fil_PartitionSnarkProof)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewFilPartitionSnarkProofRef(unsafe.Pointer(&ptr2))
		}
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilArrayPartitionSnarkProof) Ref() *C.fil_Array_PartitionSnarkProof {
	if x == nil {
		return nil
	}
	return x.ref1243d7e6
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilArrayPartitionSnarkProof) Free() {
	if x != nil && x.allocs1243d7e6 != nil {
		x.allocs1243d7e6.(*cgoAllocMap).Free()
		x.ref1243d7e6 = nil
	}
}

// NewFilArrayPartitionSnarkProofRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilArrayPartitionSnarkProofRef(ref unsafe.Pointer) *FilArrayPartitionSnarkProof {
	if ref == nil {
		return nil
	}
	obj := new(FilArrayPartitionSnarkProof)
	obj.ref1243d7e6 = (*C.fil_Array_PartitionSnarkProof)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilArrayPartitionSnarkProof) PassRef() (*C.fil_Array_PartitionSnarkProof, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1243d7e6 != nil {
		return x.ref1243d7e6, nil
	}
	mem1243d7e6 := allocFilArrayPartitionSnarkProofMemory(1)
	ref1243d7e6 := (*C.fil_Array_PartitionSnarkProof)(mem1243d7e6)
	allocs1243d7e6 := new(cgoAllocMap)
	allocs1243d7e6.Add(mem1243d7e6)

	var cptr_allocs *cgoAllocMap
	ref1243d7e6.ptr, cptr_allocs = unpackSSFilPartitionSnarkProof(x.Ptr)
	allocs1243d7e6.Borrow(cptr_allocs)

	var clen_allocs *cgoAllocMap
	ref1243d7e6.len, clen_allocs = (C.uintptr_t)(x.Len), cgoAllocsUnknown
	allocs1243d7e6.Borrow(clen_allocs)

	x.ref1243d7e6 = ref1243d7e6
	x.allocs1243d7e6 = allocs1243d7e6
	return ref1243d7e6, allocs1243d7e6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilArrayPartitionSnarkProof) PassValue() (C.fil_Array_PartitionSnarkProof, *cgoAllocMap) {
	if x.ref1243d7e6 != nil {
		return *x.ref1243d7e6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilArrayPartitionSnarkProof) Deref() {
	if x.ref1243d7e6 == nil {
		return
	}
	packSSFilPartitionSnarkProof(x.Ptr, x.ref1243d7e6.ptr)
	x.Len = (uint64)(x.ref1243d7e6.len)
}

// allocFilResultSizeTMemory allocates memory for type C.fil_Result_size_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilResultSizeTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilResultSizeTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilResultSizeTValue = unsafe.Sizeof([1]C.fil_Result_size_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilResultSizeT) Ref() *C.fil_Result_size_t {
	if x == nil {
		return nil
	}
	return x.ref5f4641d8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilResultSizeT) Free() {
	if x != nil && x.allocs5f4641d8 != nil {
		x.allocs5f4641d8.(*cgoAllocMap).Free()
		x.ref5f4641d8 = nil
	}
}

// NewFilResultSizeTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilResultSizeTRef(ref unsafe.Pointer) *FilResultSizeT {
	if ref == nil {
		return nil
	}
	obj := new(FilResultSizeT)
	obj.ref5f4641d8 = (*C.fil_Result_size_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilResultSizeT) PassRef() (*C.fil_Result_size_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5f4641d8 != nil {
		return x.ref5f4641d8, nil
	}
	mem5f4641d8 := allocFilResultSizeTMemory(1)
	ref5f4641d8 := (*C.fil_Result_size_t)(mem5f4641d8)
	allocs5f4641d8 := new(cgoAllocMap)
	allocs5f4641d8.Add(mem5f4641d8)

	var cstatus_code_allocs *cgoAllocMap
	ref5f4641d8.status_code, cstatus_code_allocs = (C.fil_FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocs5f4641d8.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref5f4641d8.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocs5f4641d8.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	ref5f4641d8.value, cvalue_allocs = (C.size_t)(x.Value), cgoAllocsUnknown
	allocs5f4641d8.Borrow(cvalue_allocs)

	x.ref5f4641d8 = ref5f4641d8
	x.allocs5f4641d8 = allocs5f4641d8
	return ref5f4641d8, allocs5f4641d8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilResultSizeT) PassValue() (C.fil_Result_size_t, *cgoAllocMap) {
	if x.ref5f4641d8 != nil {
		return *x.ref5f4641d8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilResultSizeT) Deref() {
	if x.ref5f4641d8 == nil {
		return
	}
	x.StatusCode = (FilFCPResponseStatus)(x.ref5f4641d8.status_code)
	x.ErrorMsg = *NewFilBytesRef(unsafe.Pointer(&x.ref5f4641d8.error_msg))
	x.Value = (uint)(x.ref5f4641d8.value)
}

// allocFilGetNumPartitionForFallbackPoStResponseMemory allocates memory for type C.fil_GetNumPartitionForFallbackPoStResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilGetNumPartitionForFallbackPoStResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilGetNumPartitionForFallbackPoStResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilGetNumPartitionForFallbackPoStResponseValue = unsafe.Sizeof([1]C.fil_GetNumPartitionForFallbackPoStResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilGetNumPartitionForFallbackPoStResponse) Ref() *C.fil_GetNumPartitionForFallbackPoStResponse {
	if x == nil {
		return nil
	}
	return x.refc0084478
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilGetNumPartitionForFallbackPoStResponse) Free() {
	if x != nil && x.allocsc0084478 != nil {
		x.allocsc0084478.(*cgoAllocMap).Free()
		x.refc0084478 = nil
	}
}

// NewFilGetNumPartitionForFallbackPoStResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilGetNumPartitionForFallbackPoStResponseRef(ref unsafe.Pointer) *FilGetNumPartitionForFallbackPoStResponse {
	if ref == nil {
		return nil
	}
	obj := new(FilGetNumPartitionForFallbackPoStResponse)
	obj.refc0084478 = (*C.fil_GetNumPartitionForFallbackPoStResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilGetNumPartitionForFallbackPoStResponse) PassRef() (*C.fil_GetNumPartitionForFallbackPoStResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc0084478 != nil {
		return x.refc0084478, nil
	}
	memc0084478 := allocFilGetNumPartitionForFallbackPoStResponseMemory(1)
	refc0084478 := (*C.fil_GetNumPartitionForFallbackPoStResponse)(memc0084478)
	allocsc0084478 := new(cgoAllocMap)
	allocsc0084478.Add(memc0084478)

	var cstatus_code_allocs *cgoAllocMap
	refc0084478.status_code, cstatus_code_allocs = (C.fil_FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocsc0084478.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	refc0084478.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocsc0084478.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	refc0084478.value, cvalue_allocs = (C.size_t)(x.Value), cgoAllocsUnknown
	allocsc0084478.Borrow(cvalue_allocs)

	x.refc0084478 = refc0084478
	x.allocsc0084478 = allocsc0084478
	return refc0084478, allocsc0084478

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilGetNumPartitionForFallbackPoStResponse) PassValue() (C.fil_GetNumPartitionForFallbackPoStResponse, *cgoAllocMap) {
	if x.refc0084478 != nil {
		return *x.refc0084478, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilGetNumPartitionForFallbackPoStResponse) Deref() {
	if x.refc0084478 == nil {
		return
	}
	x.StatusCode = (FilFCPResponseStatus)(x.refc0084478.status_code)
	x.ErrorMsg = *NewFilBytesRef(unsafe.Pointer(&x.refc0084478.error_msg))
	x.Value = (uint)(x.refc0084478.value)
}

// allocFilGenerateSingleWindowPoStWithVanillaMemory allocates memory for type C.fil_GenerateSingleWindowPoStWithVanilla in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilGenerateSingleWindowPoStWithVanillaMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilGenerateSingleWindowPoStWithVanillaValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilGenerateSingleWindowPoStWithVanillaValue = unsafe.Sizeof([1]C.fil_GenerateSingleWindowPoStWithVanilla{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilGenerateSingleWindowPoStWithVanilla) Ref() *C.fil_GenerateSingleWindowPoStWithVanilla {
	if x == nil {
		return nil
	}
	return x.ref50dfbbfc
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilGenerateSingleWindowPoStWithVanilla) Free() {
	if x != nil && x.allocs50dfbbfc != nil {
		x.allocs50dfbbfc.(*cgoAllocMap).Free()
		x.ref50dfbbfc = nil
	}
}

// NewFilGenerateSingleWindowPoStWithVanillaRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilGenerateSingleWindowPoStWithVanillaRef(ref unsafe.Pointer) *FilGenerateSingleWindowPoStWithVanilla {
	if ref == nil {
		return nil
	}
	obj := new(FilGenerateSingleWindowPoStWithVanilla)
	obj.ref50dfbbfc = (*C.fil_GenerateSingleWindowPoStWithVanilla)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilGenerateSingleWindowPoStWithVanilla) PassRef() (*C.fil_GenerateSingleWindowPoStWithVanilla, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref50dfbbfc != nil {
		return x.ref50dfbbfc, nil
	}
	mem50dfbbfc := allocFilGenerateSingleWindowPoStWithVanillaMemory(1)
	ref50dfbbfc := (*C.fil_GenerateSingleWindowPoStWithVanilla)(mem50dfbbfc)
	allocs50dfbbfc := new(cgoAllocMap)
	allocs50dfbbfc.Add(mem50dfbbfc)

	var cpartition_proof_allocs *cgoAllocMap
	ref50dfbbfc.partition_proof, cpartition_proof_allocs = x.PartitionProof.PassValue()
	allocs50dfbbfc.Borrow(cpartition_proof_allocs)

	var cfaulty_sectors_allocs *cgoAllocMap
	ref50dfbbfc.faulty_sectors, cfaulty_sectors_allocs = x.FaultySectors.PassValue()
	allocs50dfbbfc.Borrow(cfaulty_sectors_allocs)

	x.ref50dfbbfc = ref50dfbbfc
	x.allocs50dfbbfc = allocs50dfbbfc
	return ref50dfbbfc, allocs50dfbbfc

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilGenerateSingleWindowPoStWithVanilla) PassValue() (C.fil_GenerateSingleWindowPoStWithVanilla, *cgoAllocMap) {
	if x.ref50dfbbfc != nil {
		return *x.ref50dfbbfc, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilGenerateSingleWindowPoStWithVanilla) Deref() {
	if x.ref50dfbbfc == nil {
		return
	}
	x.PartitionProof = *NewFilPartitionSnarkProofRef(unsafe.Pointer(&x.ref50dfbbfc.partition_proof))
	x.FaultySectors = *NewFilArrayU64Ref(unsafe.Pointer(&x.ref50dfbbfc.faulty_sectors))
}

// allocFilResultGenerateSingleWindowPoStWithVanillaMemory allocates memory for type C.fil_Result_GenerateSingleWindowPoStWithVanilla in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilResultGenerateSingleWindowPoStWithVanillaMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilResultGenerateSingleWindowPoStWithVanillaValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilResultGenerateSingleWindowPoStWithVanillaValue = unsafe.Sizeof([1]C.fil_Result_GenerateSingleWindowPoStWithVanilla{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilResultGenerateSingleWindowPoStWithVanilla) Ref() *C.fil_Result_GenerateSingleWindowPoStWithVanilla {
	if x == nil {
		return nil
	}
	return x.ref17eff964
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilResultGenerateSingleWindowPoStWithVanilla) Free() {
	if x != nil && x.allocs17eff964 != nil {
		x.allocs17eff964.(*cgoAllocMap).Free()
		x.ref17eff964 = nil
	}
}

// NewFilResultGenerateSingleWindowPoStWithVanillaRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilResultGenerateSingleWindowPoStWithVanillaRef(ref unsafe.Pointer) *FilResultGenerateSingleWindowPoStWithVanilla {
	if ref == nil {
		return nil
	}
	obj := new(FilResultGenerateSingleWindowPoStWithVanilla)
	obj.ref17eff964 = (*C.fil_Result_GenerateSingleWindowPoStWithVanilla)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilResultGenerateSingleWindowPoStWithVanilla) PassRef() (*C.fil_Result_GenerateSingleWindowPoStWithVanilla, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref17eff964 != nil {
		return x.ref17eff964, nil
	}
	mem17eff964 := allocFilResultGenerateSingleWindowPoStWithVanillaMemory(1)
	ref17eff964 := (*C.fil_Result_GenerateSingleWindowPoStWithVanilla)(mem17eff964)
	allocs17eff964 := new(cgoAllocMap)
	allocs17eff964.Add(mem17eff964)

	var cstatus_code_allocs *cgoAllocMap
	ref17eff964.status_code, cstatus_code_allocs = (C.fil_FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocs17eff964.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref17eff964.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocs17eff964.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	ref17eff964.value, cvalue_allocs = x.Value.PassValue()
	allocs17eff964.Borrow(cvalue_allocs)

	x.ref17eff964 = ref17eff964
	x.allocs17eff964 = allocs17eff964
	return ref17eff964, allocs17eff964

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilResultGenerateSingleWindowPoStWithVanilla) PassValue() (C.fil_Result_GenerateSingleWindowPoStWithVanilla, *cgoAllocMap) {
	if x.ref17eff964 != nil {
		return *x.ref17eff964, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilResultGenerateSingleWindowPoStWithVanilla) Deref() {
	if x.ref17eff964 == nil {
		return
	}
	x.StatusCode = (FilFCPResponseStatus)(x.ref17eff964.status_code)
	x.ErrorMsg = *NewFilBytesRef(unsafe.Pointer(&x.ref17eff964.error_msg))
	x.Value = *NewFilGenerateSingleWindowPoStWithVanillaRef(unsafe.Pointer(&x.ref17eff964.value))
}

// allocFilGenerateSingleWindowPoStWithVanillaResponseMemory allocates memory for type C.fil_GenerateSingleWindowPoStWithVanillaResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilGenerateSingleWindowPoStWithVanillaResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilGenerateSingleWindowPoStWithVanillaResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilGenerateSingleWindowPoStWithVanillaResponseValue = unsafe.Sizeof([1]C.fil_GenerateSingleWindowPoStWithVanillaResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilGenerateSingleWindowPoStWithVanillaResponse) Ref() *C.fil_GenerateSingleWindowPoStWithVanillaResponse {
	if x == nil {
		return nil
	}
	return x.ref96c012c3
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilGenerateSingleWindowPoStWithVanillaResponse) Free() {
	if x != nil && x.allocs96c012c3 != nil {
		x.allocs96c012c3.(*cgoAllocMap).Free()
		x.ref96c012c3 = nil
	}
}

// NewFilGenerateSingleWindowPoStWithVanillaResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilGenerateSingleWindowPoStWithVanillaResponseRef(ref unsafe.Pointer) *FilGenerateSingleWindowPoStWithVanillaResponse {
	if ref == nil {
		return nil
	}
	obj := new(FilGenerateSingleWindowPoStWithVanillaResponse)
	obj.ref96c012c3 = (*C.fil_GenerateSingleWindowPoStWithVanillaResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilGenerateSingleWindowPoStWithVanillaResponse) PassRef() (*C.fil_GenerateSingleWindowPoStWithVanillaResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref96c012c3 != nil {
		return x.ref96c012c3, nil
	}
	mem96c012c3 := allocFilGenerateSingleWindowPoStWithVanillaResponseMemory(1)
	ref96c012c3 := (*C.fil_GenerateSingleWindowPoStWithVanillaResponse)(mem96c012c3)
	allocs96c012c3 := new(cgoAllocMap)
	allocs96c012c3.Add(mem96c012c3)

	var cstatus_code_allocs *cgoAllocMap
	ref96c012c3.status_code, cstatus_code_allocs = (C.fil_FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocs96c012c3.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref96c012c3.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocs96c012c3.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	ref96c012c3.value, cvalue_allocs = x.Value.PassValue()
	allocs96c012c3.Borrow(cvalue_allocs)

	x.ref96c012c3 = ref96c012c3
	x.allocs96c012c3 = allocs96c012c3
	return ref96c012c3, allocs96c012c3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilGenerateSingleWindowPoStWithVanillaResponse) PassValue() (C.fil_GenerateSingleWindowPoStWithVanillaResponse, *cgoAllocMap) {
	if x.ref96c012c3 != nil {
		return *x.ref96c012c3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilGenerateSingleWindowPoStWithVanillaResponse) Deref() {
	if x.ref96c012c3 == nil {
		return
	}
	x.StatusCode = (FilFCPResponseStatus)(x.ref96c012c3.status_code)
	x.ErrorMsg = *NewFilBytesRef(unsafe.Pointer(&x.ref96c012c3.error_msg))
	x.Value = *NewFilGenerateSingleWindowPoStWithVanillaRef(unsafe.Pointer(&x.ref96c012c3.value))
}

// allocFilEmptySectorUpdateEncodeIntoMemory allocates memory for type C.fil_EmptySectorUpdateEncodeInto in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilEmptySectorUpdateEncodeIntoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilEmptySectorUpdateEncodeIntoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilEmptySectorUpdateEncodeIntoValue = unsafe.Sizeof([1]C.fil_EmptySectorUpdateEncodeInto{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilEmptySectorUpdateEncodeInto) Ref() *C.fil_EmptySectorUpdateEncodeInto {
	if x == nil {
		return nil
	}
	return x.ref2ded7021
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilEmptySectorUpdateEncodeInto) Free() {
	if x != nil && x.allocs2ded7021 != nil {
		x.allocs2ded7021.(*cgoAllocMap).Free()
		x.ref2ded7021 = nil
	}
}

// NewFilEmptySectorUpdateEncodeIntoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilEmptySectorUpdateEncodeIntoRef(ref unsafe.Pointer) *FilEmptySectorUpdateEncodeInto {
	if ref == nil {
		return nil
	}
	obj := new(FilEmptySectorUpdateEncodeInto)
	obj.ref2ded7021 = (*C.fil_EmptySectorUpdateEncodeInto)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilEmptySectorUpdateEncodeInto) PassRef() (*C.fil_EmptySectorUpdateEncodeInto, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2ded7021 != nil {
		return x.ref2ded7021, nil
	}
	mem2ded7021 := allocFilEmptySectorUpdateEncodeIntoMemory(1)
	ref2ded7021 := (*C.fil_EmptySectorUpdateEncodeInto)(mem2ded7021)
	allocs2ded7021 := new(cgoAllocMap)
	allocs2ded7021.Add(mem2ded7021)

	var ccomm_r_new_allocs *cgoAllocMap
	ref2ded7021.comm_r_new, ccomm_r_new_allocs = *(*[32]C.uint8_t)(unsafe.Pointer(&x.CommRNew)), cgoAllocsUnknown
	allocs2ded7021.Borrow(ccomm_r_new_allocs)

	var ccomm_r_last_new_allocs *cgoAllocMap
	ref2ded7021.comm_r_last_new, ccomm_r_last_new_allocs = *(*[32]C.uint8_t)(unsafe.Pointer(&x.CommRLastNew)), cgoAllocsUnknown
	allocs2ded7021.Borrow(ccomm_r_last_new_allocs)

	var ccomm_d_new_allocs *cgoAllocMap
	ref2ded7021.comm_d_new, ccomm_d_new_allocs = *(*[32]C.uint8_t)(unsafe.Pointer(&x.CommDNew)), cgoAllocsUnknown
	allocs2ded7021.Borrow(ccomm_d_new_allocs)

	x.ref2ded7021 = ref2ded7021
	x.allocs2ded7021 = allocs2ded7021
	return ref2ded7021, allocs2ded7021

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilEmptySectorUpdateEncodeInto) PassValue() (C.fil_EmptySectorUpdateEncodeInto, *cgoAllocMap) {
	if x.ref2ded7021 != nil {
		return *x.ref2ded7021, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilEmptySectorUpdateEncodeInto) Deref() {
	if x.ref2ded7021 == nil {
		return
	}
	x.CommRNew = *(*[32]byte)(unsafe.Pointer(&x.ref2ded7021.comm_r_new))
	x.CommRLastNew = *(*[32]byte)(unsafe.Pointer(&x.ref2ded7021.comm_r_last_new))
	x.CommDNew = *(*[32]byte)(unsafe.Pointer(&x.ref2ded7021.comm_d_new))
}

// allocFilResultEmptySectorUpdateEncodeIntoMemory allocates memory for type C.fil_Result_EmptySectorUpdateEncodeInto in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilResultEmptySectorUpdateEncodeIntoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilResultEmptySectorUpdateEncodeIntoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilResultEmptySectorUpdateEncodeIntoValue = unsafe.Sizeof([1]C.fil_Result_EmptySectorUpdateEncodeInto{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilResultEmptySectorUpdateEncodeInto) Ref() *C.fil_Result_EmptySectorUpdateEncodeInto {
	if x == nil {
		return nil
	}
	return x.refaaeeb85b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilResultEmptySectorUpdateEncodeInto) Free() {
	if x != nil && x.allocsaaeeb85b != nil {
		x.allocsaaeeb85b.(*cgoAllocMap).Free()
		x.refaaeeb85b = nil
	}
}

// NewFilResultEmptySectorUpdateEncodeIntoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilResultEmptySectorUpdateEncodeIntoRef(ref unsafe.Pointer) *FilResultEmptySectorUpdateEncodeInto {
	if ref == nil {
		return nil
	}
	obj := new(FilResultEmptySectorUpdateEncodeInto)
	obj.refaaeeb85b = (*C.fil_Result_EmptySectorUpdateEncodeInto)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilResultEmptySectorUpdateEncodeInto) PassRef() (*C.fil_Result_EmptySectorUpdateEncodeInto, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refaaeeb85b != nil {
		return x.refaaeeb85b, nil
	}
	memaaeeb85b := allocFilResultEmptySectorUpdateEncodeIntoMemory(1)
	refaaeeb85b := (*C.fil_Result_EmptySectorUpdateEncodeInto)(memaaeeb85b)
	allocsaaeeb85b := new(cgoAllocMap)
	allocsaaeeb85b.Add(memaaeeb85b)

	var cstatus_code_allocs *cgoAllocMap
	refaaeeb85b.status_code, cstatus_code_allocs = (C.fil_FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocsaaeeb85b.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	refaaeeb85b.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocsaaeeb85b.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	refaaeeb85b.value, cvalue_allocs = x.Value.PassValue()
	allocsaaeeb85b.Borrow(cvalue_allocs)

	x.refaaeeb85b = refaaeeb85b
	x.allocsaaeeb85b = allocsaaeeb85b
	return refaaeeb85b, allocsaaeeb85b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilResultEmptySectorUpdateEncodeInto) PassValue() (C.fil_Result_EmptySectorUpdateEncodeInto, *cgoAllocMap) {
	if x.refaaeeb85b != nil {
		return *x.refaaeeb85b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilResultEmptySectorUpdateEncodeInto) Deref() {
	if x.refaaeeb85b == nil {
		return
	}
	x.StatusCode = (FilFCPResponseStatus)(x.refaaeeb85b.status_code)
	x.ErrorMsg = *NewFilBytesRef(unsafe.Pointer(&x.refaaeeb85b.error_msg))
	x.Value = *NewFilEmptySectorUpdateEncodeIntoRef(unsafe.Pointer(&x.refaaeeb85b.value))
}

// allocFilEmptySectorUpdateEncodeIntoResponseMemory allocates memory for type C.fil_EmptySectorUpdateEncodeIntoResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilEmptySectorUpdateEncodeIntoResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilEmptySectorUpdateEncodeIntoResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilEmptySectorUpdateEncodeIntoResponseValue = unsafe.Sizeof([1]C.fil_EmptySectorUpdateEncodeIntoResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilEmptySectorUpdateEncodeIntoResponse) Ref() *C.fil_EmptySectorUpdateEncodeIntoResponse {
	if x == nil {
		return nil
	}
	return x.ref8d3238a7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilEmptySectorUpdateEncodeIntoResponse) Free() {
	if x != nil && x.allocs8d3238a7 != nil {
		x.allocs8d3238a7.(*cgoAllocMap).Free()
		x.ref8d3238a7 = nil
	}
}

// NewFilEmptySectorUpdateEncodeIntoResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilEmptySectorUpdateEncodeIntoResponseRef(ref unsafe.Pointer) *FilEmptySectorUpdateEncodeIntoResponse {
	if ref == nil {
		return nil
	}
	obj := new(FilEmptySectorUpdateEncodeIntoResponse)
	obj.ref8d3238a7 = (*C.fil_EmptySectorUpdateEncodeIntoResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilEmptySectorUpdateEncodeIntoResponse) PassRef() (*C.fil_EmptySectorUpdateEncodeIntoResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8d3238a7 != nil {
		return x.ref8d3238a7, nil
	}
	mem8d3238a7 := allocFilEmptySectorUpdateEncodeIntoResponseMemory(1)
	ref8d3238a7 := (*C.fil_EmptySectorUpdateEncodeIntoResponse)(mem8d3238a7)
	allocs8d3238a7 := new(cgoAllocMap)
	allocs8d3238a7.Add(mem8d3238a7)

	var cstatus_code_allocs *cgoAllocMap
	ref8d3238a7.status_code, cstatus_code_allocs = (C.fil_FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocs8d3238a7.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref8d3238a7.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocs8d3238a7.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	ref8d3238a7.value, cvalue_allocs = x.Value.PassValue()
	allocs8d3238a7.Borrow(cvalue_allocs)

	x.ref8d3238a7 = ref8d3238a7
	x.allocs8d3238a7 = allocs8d3238a7
	return ref8d3238a7, allocs8d3238a7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilEmptySectorUpdateEncodeIntoResponse) PassValue() (C.fil_EmptySectorUpdateEncodeIntoResponse, *cgoAllocMap) {
	if x.ref8d3238a7 != nil {
		return *x.ref8d3238a7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilEmptySectorUpdateEncodeIntoResponse) Deref() {
	if x.ref8d3238a7 == nil {
		return
	}
	x.StatusCode = (FilFCPResponseStatus)(x.ref8d3238a7.status_code)
	x.ErrorMsg = *NewFilBytesRef(unsafe.Pointer(&x.ref8d3238a7.error_msg))
	x.Value = *NewFilEmptySectorUpdateEncodeIntoRef(unsafe.Pointer(&x.ref8d3238a7.value))
}

// allocFilEmptySectorUpdateDecodeFromResponseMemory allocates memory for type C.fil_EmptySectorUpdateDecodeFromResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilEmptySectorUpdateDecodeFromResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilEmptySectorUpdateDecodeFromResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilEmptySectorUpdateDecodeFromResponseValue = unsafe.Sizeof([1]C.fil_EmptySectorUpdateDecodeFromResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilEmptySectorUpdateDecodeFromResponse) Ref() *C.fil_EmptySectorUpdateDecodeFromResponse {
	if x == nil {
		return nil
	}
	return x.reff02a01b8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilEmptySectorUpdateDecodeFromResponse) Free() {
	if x != nil && x.allocsf02a01b8 != nil {
		x.allocsf02a01b8.(*cgoAllocMap).Free()
		x.reff02a01b8 = nil
	}
}

// NewFilEmptySectorUpdateDecodeFromResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilEmptySectorUpdateDecodeFromResponseRef(ref unsafe.Pointer) *FilEmptySectorUpdateDecodeFromResponse {
	if ref == nil {
		return nil
	}
	obj := new(FilEmptySectorUpdateDecodeFromResponse)
	obj.reff02a01b8 = (*C.fil_EmptySectorUpdateDecodeFromResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilEmptySectorUpdateDecodeFromResponse) PassRef() (*C.fil_EmptySectorUpdateDecodeFromResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff02a01b8 != nil {
		return x.reff02a01b8, nil
	}
	memf02a01b8 := allocFilEmptySectorUpdateDecodeFromResponseMemory(1)
	reff02a01b8 := (*C.fil_EmptySectorUpdateDecodeFromResponse)(memf02a01b8)
	allocsf02a01b8 := new(cgoAllocMap)
	allocsf02a01b8.Add(memf02a01b8)

	var cstatus_code_allocs *cgoAllocMap
	reff02a01b8.status_code, cstatus_code_allocs = (C.fil_FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocsf02a01b8.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	reff02a01b8.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocsf02a01b8.Borrow(cerror_msg_allocs)

	x.reff02a01b8 = reff02a01b8
	x.allocsf02a01b8 = allocsf02a01b8
	return reff02a01b8, allocsf02a01b8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilEmptySectorUpdateDecodeFromResponse) PassValue() (C.fil_EmptySectorUpdateDecodeFromResponse, *cgoAllocMap) {
	if x.reff02a01b8 != nil {
		return *x.reff02a01b8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilEmptySectorUpdateDecodeFromResponse) Deref() {
	if x.reff02a01b8 == nil {
		return
	}
	x.StatusCode = (FilFCPResponseStatus)(x.reff02a01b8.status_code)
	x.ErrorMsg = *NewFilBytesRef(unsafe.Pointer(&x.reff02a01b8.error_msg))
}

// allocFilEmptySectorUpdateRemoveEncodedDataResponseMemory allocates memory for type C.fil_EmptySectorUpdateRemoveEncodedDataResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilEmptySectorUpdateRemoveEncodedDataResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilEmptySectorUpdateRemoveEncodedDataResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilEmptySectorUpdateRemoveEncodedDataResponseValue = unsafe.Sizeof([1]C.fil_EmptySectorUpdateRemoveEncodedDataResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilEmptySectorUpdateRemoveEncodedDataResponse) Ref() *C.fil_EmptySectorUpdateRemoveEncodedDataResponse {
	if x == nil {
		return nil
	}
	return x.ref50783b83
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilEmptySectorUpdateRemoveEncodedDataResponse) Free() {
	if x != nil && x.allocs50783b83 != nil {
		x.allocs50783b83.(*cgoAllocMap).Free()
		x.ref50783b83 = nil
	}
}

// NewFilEmptySectorUpdateRemoveEncodedDataResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilEmptySectorUpdateRemoveEncodedDataResponseRef(ref unsafe.Pointer) *FilEmptySectorUpdateRemoveEncodedDataResponse {
	if ref == nil {
		return nil
	}
	obj := new(FilEmptySectorUpdateRemoveEncodedDataResponse)
	obj.ref50783b83 = (*C.fil_EmptySectorUpdateRemoveEncodedDataResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilEmptySectorUpdateRemoveEncodedDataResponse) PassRef() (*C.fil_EmptySectorUpdateRemoveEncodedDataResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref50783b83 != nil {
		return x.ref50783b83, nil
	}
	mem50783b83 := allocFilEmptySectorUpdateRemoveEncodedDataResponseMemory(1)
	ref50783b83 := (*C.fil_EmptySectorUpdateRemoveEncodedDataResponse)(mem50783b83)
	allocs50783b83 := new(cgoAllocMap)
	allocs50783b83.Add(mem50783b83)

	var cstatus_code_allocs *cgoAllocMap
	ref50783b83.status_code, cstatus_code_allocs = (C.fil_FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocs50783b83.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref50783b83.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocs50783b83.Borrow(cerror_msg_allocs)

	x.ref50783b83 = ref50783b83
	x.allocs50783b83 = allocs50783b83
	return ref50783b83, allocs50783b83

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilEmptySectorUpdateRemoveEncodedDataResponse) PassValue() (C.fil_EmptySectorUpdateRemoveEncodedDataResponse, *cgoAllocMap) {
	if x.ref50783b83 != nil {
		return *x.ref50783b83, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilEmptySectorUpdateRemoveEncodedDataResponse) Deref() {
	if x.ref50783b83 == nil {
		return
	}
	x.StatusCode = (FilFCPResponseStatus)(x.ref50783b83.status_code)
	x.ErrorMsg = *NewFilBytesRef(unsafe.Pointer(&x.ref50783b83.error_msg))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilApiPartitionProof) Ref() *C.fil_Bytes {
	if x == nil {
		return nil
	}
	return x.ref1605074
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilApiPartitionProof) Free() {
	if x != nil && x.allocs1605074 != nil {
		x.allocs1605074.(*cgoAllocMap).Free()
		x.ref1605074 = nil
	}
}

// NewFilApiPartitionProofRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilApiPartitionProofRef(ref unsafe.Pointer) *FilApiPartitionProof {
	if ref == nil {
		return nil
	}
	obj := new(FilApiPartitionProof)
	obj.ref1605074 = (*C.fil_Bytes)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilApiPartitionProof) PassRef() (*C.fil_Bytes, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1605074 != nil {
		return x.ref1605074, nil
	}
	mem1605074 := allocFilBytesMemory(1)
	ref1605074 := (*C.fil_Bytes)(mem1605074)
	allocs1605074 := new(cgoAllocMap)
	allocs1605074.Add(mem1605074)

	var cptr_allocs *cgoAllocMap
	ref1605074.ptr, cptr_allocs = unpackSSByte(x.Ptr)
	allocs1605074.Borrow(cptr_allocs)

	var clen_allocs *cgoAllocMap
	ref1605074.len, clen_allocs = (C.uintptr_t)(x.Len), cgoAllocsUnknown
	allocs1605074.Borrow(clen_allocs)

	x.ref1605074 = ref1605074
	x.allocs1605074 = allocs1605074
	return ref1605074, allocs1605074

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilApiPartitionProof) PassValue() (C.fil_Bytes, *cgoAllocMap) {
	if x.ref1605074 != nil {
		return *x.ref1605074, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilApiPartitionProof) Deref() {
	if x.ref1605074 == nil {
		return
	}
	packSSByte(x.Ptr, x.ref1605074.ptr)
	x.Len = (uint64)(x.ref1605074.len)
}

// allocFilArrayApiPartitionProofMemory allocates memory for type C.fil_Array_ApiPartitionProof in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilArrayApiPartitionProofMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilArrayApiPartitionProofValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilArrayApiPartitionProofValue = unsafe.Sizeof([1]C.fil_Array_ApiPartitionProof{})

// allocPFilApiPartitionProofMemory allocates memory for type *C.fil_ApiPartitionProof in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPFilApiPartitionProofMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPFilApiPartitionProofValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPFilApiPartitionProofValue = unsafe.Sizeof([1]*C.fil_ApiPartitionProof{})

// allocFilApiPartitionProofMemory allocates memory for type C.fil_ApiPartitionProof in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilApiPartitionProofMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilApiPartitionProofValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilApiPartitionProofValue = unsafe.Sizeof([1]C.fil_ApiPartitionProof{})

// unpackSSFilApiPartitionProof transforms a sliced Go data structure into plain C format.
func unpackSSFilApiPartitionProof(x [][]FilApiPartitionProof) (unpacked **C.fil_ApiPartitionProof, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPFilApiPartitionProofMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.fil_ApiPartitionProof)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocFilApiPartitionProofMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.fil_ApiPartitionProof)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.fil_ApiPartitionProof)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.fil_ApiPartitionProof)(h.Data)
	return
}

// packSSFilApiPartitionProof reads sliced Go data structure out from plain C format.
func packSSFilApiPartitionProof(v [][]FilApiPartitionProof, ptr0 **C.fil_ApiPartitionProof) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.fil_ApiPartitionProof)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfFilApiPartitionProofValue]C.fil_ApiPartitionProof)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewFilApiPartitionProofRef(unsafe.Pointer(&ptr2))
		}
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilArrayApiPartitionProof) Ref() *C.fil_Array_ApiPartitionProof {
	if x == nil {
		return nil
	}
	return x.ref81119c0c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilArrayApiPartitionProof) Free() {
	if x != nil && x.allocs81119c0c != nil {
		x.allocs81119c0c.(*cgoAllocMap).Free()
		x.ref81119c0c = nil
	}
}

// NewFilArrayApiPartitionProofRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilArrayApiPartitionProofRef(ref unsafe.Pointer) *FilArrayApiPartitionProof {
	if ref == nil {
		return nil
	}
	obj := new(FilArrayApiPartitionProof)
	obj.ref81119c0c = (*C.fil_Array_ApiPartitionProof)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilArrayApiPartitionProof) PassRef() (*C.fil_Array_ApiPartitionProof, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref81119c0c != nil {
		return x.ref81119c0c, nil
	}
	mem81119c0c := allocFilArrayApiPartitionProofMemory(1)
	ref81119c0c := (*C.fil_Array_ApiPartitionProof)(mem81119c0c)
	allocs81119c0c := new(cgoAllocMap)
	allocs81119c0c.Add(mem81119c0c)

	var cptr_allocs *cgoAllocMap
	ref81119c0c.ptr, cptr_allocs = unpackSSFilApiPartitionProof(x.Ptr)
	allocs81119c0c.Borrow(cptr_allocs)

	var clen_allocs *cgoAllocMap
	ref81119c0c.len, clen_allocs = (C.uintptr_t)(x.Len), cgoAllocsUnknown
	allocs81119c0c.Borrow(clen_allocs)

	x.ref81119c0c = ref81119c0c
	x.allocs81119c0c = allocs81119c0c
	return ref81119c0c, allocs81119c0c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilArrayApiPartitionProof) PassValue() (C.fil_Array_ApiPartitionProof, *cgoAllocMap) {
	if x.ref81119c0c != nil {
		return *x.ref81119c0c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilArrayApiPartitionProof) Deref() {
	if x.ref81119c0c == nil {
		return
	}
	packSSFilApiPartitionProof(x.Ptr, x.ref81119c0c.ptr)
	x.Len = (uint64)(x.ref81119c0c.len)
}

// allocFilResultArrayApiPartitionProofMemory allocates memory for type C.fil_Result_Array_ApiPartitionProof in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilResultArrayApiPartitionProofMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilResultArrayApiPartitionProofValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilResultArrayApiPartitionProofValue = unsafe.Sizeof([1]C.fil_Result_Array_ApiPartitionProof{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilResultArrayApiPartitionProof) Ref() *C.fil_Result_Array_ApiPartitionProof {
	if x == nil {
		return nil
	}
	return x.refceda87e8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilResultArrayApiPartitionProof) Free() {
	if x != nil && x.allocsceda87e8 != nil {
		x.allocsceda87e8.(*cgoAllocMap).Free()
		x.refceda87e8 = nil
	}
}

// NewFilResultArrayApiPartitionProofRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilResultArrayApiPartitionProofRef(ref unsafe.Pointer) *FilResultArrayApiPartitionProof {
	if ref == nil {
		return nil
	}
	obj := new(FilResultArrayApiPartitionProof)
	obj.refceda87e8 = (*C.fil_Result_Array_ApiPartitionProof)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilResultArrayApiPartitionProof) PassRef() (*C.fil_Result_Array_ApiPartitionProof, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refceda87e8 != nil {
		return x.refceda87e8, nil
	}
	memceda87e8 := allocFilResultArrayApiPartitionProofMemory(1)
	refceda87e8 := (*C.fil_Result_Array_ApiPartitionProof)(memceda87e8)
	allocsceda87e8 := new(cgoAllocMap)
	allocsceda87e8.Add(memceda87e8)

	var cstatus_code_allocs *cgoAllocMap
	refceda87e8.status_code, cstatus_code_allocs = (C.fil_FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocsceda87e8.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	refceda87e8.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocsceda87e8.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	refceda87e8.value, cvalue_allocs = x.Value.PassValue()
	allocsceda87e8.Borrow(cvalue_allocs)

	x.refceda87e8 = refceda87e8
	x.allocsceda87e8 = allocsceda87e8
	return refceda87e8, allocsceda87e8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilResultArrayApiPartitionProof) PassValue() (C.fil_Result_Array_ApiPartitionProof, *cgoAllocMap) {
	if x.refceda87e8 != nil {
		return *x.refceda87e8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilResultArrayApiPartitionProof) Deref() {
	if x.refceda87e8 == nil {
		return
	}
	x.StatusCode = (FilFCPResponseStatus)(x.refceda87e8.status_code)
	x.ErrorMsg = *NewFilBytesRef(unsafe.Pointer(&x.refceda87e8.error_msg))
	x.Value = *NewFilArrayApiPartitionProofRef(unsafe.Pointer(&x.refceda87e8.value))
}

// allocFilPartitionProofResponseMemory allocates memory for type C.fil_PartitionProofResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilPartitionProofResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilPartitionProofResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilPartitionProofResponseValue = unsafe.Sizeof([1]C.fil_PartitionProofResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilPartitionProofResponse) Ref() *C.fil_PartitionProofResponse {
	if x == nil {
		return nil
	}
	return x.ref51343e7a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilPartitionProofResponse) Free() {
	if x != nil && x.allocs51343e7a != nil {
		x.allocs51343e7a.(*cgoAllocMap).Free()
		x.ref51343e7a = nil
	}
}

// NewFilPartitionProofResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilPartitionProofResponseRef(ref unsafe.Pointer) *FilPartitionProofResponse {
	if ref == nil {
		return nil
	}
	obj := new(FilPartitionProofResponse)
	obj.ref51343e7a = (*C.fil_PartitionProofResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilPartitionProofResponse) PassRef() (*C.fil_PartitionProofResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref51343e7a != nil {
		return x.ref51343e7a, nil
	}
	mem51343e7a := allocFilPartitionProofResponseMemory(1)
	ref51343e7a := (*C.fil_PartitionProofResponse)(mem51343e7a)
	allocs51343e7a := new(cgoAllocMap)
	allocs51343e7a.Add(mem51343e7a)

	var cstatus_code_allocs *cgoAllocMap
	ref51343e7a.status_code, cstatus_code_allocs = (C.fil_FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocs51343e7a.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref51343e7a.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocs51343e7a.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	ref51343e7a.value, cvalue_allocs = x.Value.PassValue()
	allocs51343e7a.Borrow(cvalue_allocs)

	x.ref51343e7a = ref51343e7a
	x.allocs51343e7a = allocs51343e7a
	return ref51343e7a, allocs51343e7a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilPartitionProofResponse) PassValue() (C.fil_PartitionProofResponse, *cgoAllocMap) {
	if x.ref51343e7a != nil {
		return *x.ref51343e7a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilPartitionProofResponse) Deref() {
	if x.ref51343e7a == nil {
		return
	}
	x.StatusCode = (FilFCPResponseStatus)(x.ref51343e7a.status_code)
	x.ErrorMsg = *NewFilBytesRef(unsafe.Pointer(&x.ref51343e7a.error_msg))
	x.Value = *NewFilArrayApiPartitionProofRef(unsafe.Pointer(&x.ref51343e7a.value))
}

// allocFilVerifyPartitionProofResponseMemory allocates memory for type C.fil_VerifyPartitionProofResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilVerifyPartitionProofResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilVerifyPartitionProofResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilVerifyPartitionProofResponseValue = unsafe.Sizeof([1]C.fil_VerifyPartitionProofResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilVerifyPartitionProofResponse) Ref() *C.fil_VerifyPartitionProofResponse {
	if x == nil {
		return nil
	}
	return x.refaed1b67
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilVerifyPartitionProofResponse) Free() {
	if x != nil && x.allocsaed1b67 != nil {
		x.allocsaed1b67.(*cgoAllocMap).Free()
		x.refaed1b67 = nil
	}
}

// NewFilVerifyPartitionProofResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilVerifyPartitionProofResponseRef(ref unsafe.Pointer) *FilVerifyPartitionProofResponse {
	if ref == nil {
		return nil
	}
	obj := new(FilVerifyPartitionProofResponse)
	obj.refaed1b67 = (*C.fil_VerifyPartitionProofResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilVerifyPartitionProofResponse) PassRef() (*C.fil_VerifyPartitionProofResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refaed1b67 != nil {
		return x.refaed1b67, nil
	}
	memaed1b67 := allocFilVerifyPartitionProofResponseMemory(1)
	refaed1b67 := (*C.fil_VerifyPartitionProofResponse)(memaed1b67)
	allocsaed1b67 := new(cgoAllocMap)
	allocsaed1b67.Add(memaed1b67)

	var cstatus_code_allocs *cgoAllocMap
	refaed1b67.status_code, cstatus_code_allocs = (C.fil_FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocsaed1b67.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	refaed1b67.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocsaed1b67.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	refaed1b67.value, cvalue_allocs = (C._Bool)(x.Value), cgoAllocsUnknown
	allocsaed1b67.Borrow(cvalue_allocs)

	x.refaed1b67 = refaed1b67
	x.allocsaed1b67 = allocsaed1b67
	return refaed1b67, allocsaed1b67

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilVerifyPartitionProofResponse) PassValue() (C.fil_VerifyPartitionProofResponse, *cgoAllocMap) {
	if x.refaed1b67 != nil {
		return *x.refaed1b67, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilVerifyPartitionProofResponse) Deref() {
	if x.refaed1b67 == nil {
		return
	}
	x.StatusCode = (FilFCPResponseStatus)(x.refaed1b67.status_code)
	x.ErrorMsg = *NewFilBytesRef(unsafe.Pointer(&x.refaed1b67.error_msg))
	x.Value = (bool)(x.refaed1b67.value)
}

// allocFilEmptySectorUpdateProofResponseMemory allocates memory for type C.fil_EmptySectorUpdateProofResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilEmptySectorUpdateProofResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilEmptySectorUpdateProofResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilEmptySectorUpdateProofResponseValue = unsafe.Sizeof([1]C.fil_EmptySectorUpdateProofResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilEmptySectorUpdateProofResponse) Ref() *C.fil_EmptySectorUpdateProofResponse {
	if x == nil {
		return nil
	}
	return x.ref5c2faef
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilEmptySectorUpdateProofResponse) Free() {
	if x != nil && x.allocs5c2faef != nil {
		x.allocs5c2faef.(*cgoAllocMap).Free()
		x.ref5c2faef = nil
	}
}

// NewFilEmptySectorUpdateProofResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilEmptySectorUpdateProofResponseRef(ref unsafe.Pointer) *FilEmptySectorUpdateProofResponse {
	if ref == nil {
		return nil
	}
	obj := new(FilEmptySectorUpdateProofResponse)
	obj.ref5c2faef = (*C.fil_EmptySectorUpdateProofResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilEmptySectorUpdateProofResponse) PassRef() (*C.fil_EmptySectorUpdateProofResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5c2faef != nil {
		return x.ref5c2faef, nil
	}
	mem5c2faef := allocFilEmptySectorUpdateProofResponseMemory(1)
	ref5c2faef := (*C.fil_EmptySectorUpdateProofResponse)(mem5c2faef)
	allocs5c2faef := new(cgoAllocMap)
	allocs5c2faef.Add(mem5c2faef)

	var cstatus_code_allocs *cgoAllocMap
	ref5c2faef.status_code, cstatus_code_allocs = (C.fil_FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocs5c2faef.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref5c2faef.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocs5c2faef.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	ref5c2faef.value, cvalue_allocs = x.Value.PassValue()
	allocs5c2faef.Borrow(cvalue_allocs)

	x.ref5c2faef = ref5c2faef
	x.allocs5c2faef = allocs5c2faef
	return ref5c2faef, allocs5c2faef

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilEmptySectorUpdateProofResponse) PassValue() (C.fil_EmptySectorUpdateProofResponse, *cgoAllocMap) {
	if x.ref5c2faef != nil {
		return *x.ref5c2faef, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilEmptySectorUpdateProofResponse) Deref() {
	if x.ref5c2faef == nil {
		return
	}
	x.StatusCode = (FilFCPResponseStatus)(x.ref5c2faef.status_code)
	x.ErrorMsg = *NewFilBytesRef(unsafe.Pointer(&x.ref5c2faef.error_msg))
	x.Value = *NewFilBytesRef(unsafe.Pointer(&x.ref5c2faef.value))
}

// allocFilVerifyEmptySectorUpdateProofResponseMemory allocates memory for type C.fil_VerifyEmptySectorUpdateProofResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilVerifyEmptySectorUpdateProofResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilVerifyEmptySectorUpdateProofResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilVerifyEmptySectorUpdateProofResponseValue = unsafe.Sizeof([1]C.fil_VerifyEmptySectorUpdateProofResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilVerifyEmptySectorUpdateProofResponse) Ref() *C.fil_VerifyEmptySectorUpdateProofResponse {
	if x == nil {
		return nil
	}
	return x.ref50b7b13
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilVerifyEmptySectorUpdateProofResponse) Free() {
	if x != nil && x.allocs50b7b13 != nil {
		x.allocs50b7b13.(*cgoAllocMap).Free()
		x.ref50b7b13 = nil
	}
}

// NewFilVerifyEmptySectorUpdateProofResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilVerifyEmptySectorUpdateProofResponseRef(ref unsafe.Pointer) *FilVerifyEmptySectorUpdateProofResponse {
	if ref == nil {
		return nil
	}
	obj := new(FilVerifyEmptySectorUpdateProofResponse)
	obj.ref50b7b13 = (*C.fil_VerifyEmptySectorUpdateProofResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilVerifyEmptySectorUpdateProofResponse) PassRef() (*C.fil_VerifyEmptySectorUpdateProofResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref50b7b13 != nil {
		return x.ref50b7b13, nil
	}
	mem50b7b13 := allocFilVerifyEmptySectorUpdateProofResponseMemory(1)
	ref50b7b13 := (*C.fil_VerifyEmptySectorUpdateProofResponse)(mem50b7b13)
	allocs50b7b13 := new(cgoAllocMap)
	allocs50b7b13.Add(mem50b7b13)

	var cstatus_code_allocs *cgoAllocMap
	ref50b7b13.status_code, cstatus_code_allocs = (C.fil_FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocs50b7b13.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref50b7b13.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocs50b7b13.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	ref50b7b13.value, cvalue_allocs = (C._Bool)(x.Value), cgoAllocsUnknown
	allocs50b7b13.Borrow(cvalue_allocs)

	x.ref50b7b13 = ref50b7b13
	x.allocs50b7b13 = allocs50b7b13
	return ref50b7b13, allocs50b7b13

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilVerifyEmptySectorUpdateProofResponse) PassValue() (C.fil_VerifyEmptySectorUpdateProofResponse, *cgoAllocMap) {
	if x.ref50b7b13 != nil {
		return *x.ref50b7b13, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilVerifyEmptySectorUpdateProofResponse) Deref() {
	if x.ref50b7b13 == nil {
		return
	}
	x.StatusCode = (FilFCPResponseStatus)(x.ref50b7b13.status_code)
	x.ErrorMsg = *NewFilBytesRef(unsafe.Pointer(&x.ref50b7b13.error_msg))
	x.Value = (bool)(x.ref50b7b13.value)
}

// allocFilGeneratePieceCommitmentMemory allocates memory for type C.fil_GeneratePieceCommitment in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilGeneratePieceCommitmentMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilGeneratePieceCommitmentValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilGeneratePieceCommitmentValue = unsafe.Sizeof([1]C.fil_GeneratePieceCommitment{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilGeneratePieceCommitment) Ref() *C.fil_GeneratePieceCommitment {
	if x == nil {
		return nil
	}
	return x.ref27f71149
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilGeneratePieceCommitment) Free() {
	if x != nil && x.allocs27f71149 != nil {
		x.allocs27f71149.(*cgoAllocMap).Free()
		x.ref27f71149 = nil
	}
}

// NewFilGeneratePieceCommitmentRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilGeneratePieceCommitmentRef(ref unsafe.Pointer) *FilGeneratePieceCommitment {
	if ref == nil {
		return nil
	}
	obj := new(FilGeneratePieceCommitment)
	obj.ref27f71149 = (*C.fil_GeneratePieceCommitment)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilGeneratePieceCommitment) PassRef() (*C.fil_GeneratePieceCommitment, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref27f71149 != nil {
		return x.ref27f71149, nil
	}
	mem27f71149 := allocFilGeneratePieceCommitmentMemory(1)
	ref27f71149 := (*C.fil_GeneratePieceCommitment)(mem27f71149)
	allocs27f71149 := new(cgoAllocMap)
	allocs27f71149.Add(mem27f71149)

	var ccomm_p_allocs *cgoAllocMap
	ref27f71149.comm_p, ccomm_p_allocs = *(*[32]C.uint8_t)(unsafe.Pointer(&x.CommP)), cgoAllocsUnknown
	allocs27f71149.Borrow(ccomm_p_allocs)

	var cnum_bytes_aligned_allocs *cgoAllocMap
	ref27f71149.num_bytes_aligned, cnum_bytes_aligned_allocs = (C.uint64_t)(x.NumBytesAligned), cgoAllocsUnknown
	allocs27f71149.Borrow(cnum_bytes_aligned_allocs)

	x.ref27f71149 = ref27f71149
	x.allocs27f71149 = allocs27f71149
	return ref27f71149, allocs27f71149

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilGeneratePieceCommitment) PassValue() (C.fil_GeneratePieceCommitment, *cgoAllocMap) {
	if x.ref27f71149 != nil {
		return *x.ref27f71149, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilGeneratePieceCommitment) Deref() {
	if x.ref27f71149 == nil {
		return
	}
	x.CommP = *(*[32]byte)(unsafe.Pointer(&x.ref27f71149.comm_p))
	x.NumBytesAligned = (uint64)(x.ref27f71149.num_bytes_aligned)
}

// allocFilResultGeneratePieceCommitmentMemory allocates memory for type C.fil_Result_GeneratePieceCommitment in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilResultGeneratePieceCommitmentMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilResultGeneratePieceCommitmentValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilResultGeneratePieceCommitmentValue = unsafe.Sizeof([1]C.fil_Result_GeneratePieceCommitment{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilResultGeneratePieceCommitment) Ref() *C.fil_Result_GeneratePieceCommitment {
	if x == nil {
		return nil
	}
	return x.ref683c0aad
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilResultGeneratePieceCommitment) Free() {
	if x != nil && x.allocs683c0aad != nil {
		x.allocs683c0aad.(*cgoAllocMap).Free()
		x.ref683c0aad = nil
	}
}

// NewFilResultGeneratePieceCommitmentRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilResultGeneratePieceCommitmentRef(ref unsafe.Pointer) *FilResultGeneratePieceCommitment {
	if ref == nil {
		return nil
	}
	obj := new(FilResultGeneratePieceCommitment)
	obj.ref683c0aad = (*C.fil_Result_GeneratePieceCommitment)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilResultGeneratePieceCommitment) PassRef() (*C.fil_Result_GeneratePieceCommitment, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref683c0aad != nil {
		return x.ref683c0aad, nil
	}
	mem683c0aad := allocFilResultGeneratePieceCommitmentMemory(1)
	ref683c0aad := (*C.fil_Result_GeneratePieceCommitment)(mem683c0aad)
	allocs683c0aad := new(cgoAllocMap)
	allocs683c0aad.Add(mem683c0aad)

	var cstatus_code_allocs *cgoAllocMap
	ref683c0aad.status_code, cstatus_code_allocs = (C.fil_FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocs683c0aad.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref683c0aad.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocs683c0aad.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	ref683c0aad.value, cvalue_allocs = x.Value.PassValue()
	allocs683c0aad.Borrow(cvalue_allocs)

	x.ref683c0aad = ref683c0aad
	x.allocs683c0aad = allocs683c0aad
	return ref683c0aad, allocs683c0aad

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilResultGeneratePieceCommitment) PassValue() (C.fil_Result_GeneratePieceCommitment, *cgoAllocMap) {
	if x.ref683c0aad != nil {
		return *x.ref683c0aad, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilResultGeneratePieceCommitment) Deref() {
	if x.ref683c0aad == nil {
		return
	}
	x.StatusCode = (FilFCPResponseStatus)(x.ref683c0aad.status_code)
	x.ErrorMsg = *NewFilBytesRef(unsafe.Pointer(&x.ref683c0aad.error_msg))
	x.Value = *NewFilGeneratePieceCommitmentRef(unsafe.Pointer(&x.ref683c0aad.value))
}

// allocFilGeneratePieceCommitmentResponseMemory allocates memory for type C.fil_GeneratePieceCommitmentResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilGeneratePieceCommitmentResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilGeneratePieceCommitmentResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilGeneratePieceCommitmentResponseValue = unsafe.Sizeof([1]C.fil_GeneratePieceCommitmentResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilGeneratePieceCommitmentResponse) Ref() *C.fil_GeneratePieceCommitmentResponse {
	if x == nil {
		return nil
	}
	return x.ref4b00fda4
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilGeneratePieceCommitmentResponse) Free() {
	if x != nil && x.allocs4b00fda4 != nil {
		x.allocs4b00fda4.(*cgoAllocMap).Free()
		x.ref4b00fda4 = nil
	}
}

// NewFilGeneratePieceCommitmentResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilGeneratePieceCommitmentResponseRef(ref unsafe.Pointer) *FilGeneratePieceCommitmentResponse {
	if ref == nil {
		return nil
	}
	obj := new(FilGeneratePieceCommitmentResponse)
	obj.ref4b00fda4 = (*C.fil_GeneratePieceCommitmentResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilGeneratePieceCommitmentResponse) PassRef() (*C.fil_GeneratePieceCommitmentResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4b00fda4 != nil {
		return x.ref4b00fda4, nil
	}
	mem4b00fda4 := allocFilGeneratePieceCommitmentResponseMemory(1)
	ref4b00fda4 := (*C.fil_GeneratePieceCommitmentResponse)(mem4b00fda4)
	allocs4b00fda4 := new(cgoAllocMap)
	allocs4b00fda4.Add(mem4b00fda4)

	var cstatus_code_allocs *cgoAllocMap
	ref4b00fda4.status_code, cstatus_code_allocs = (C.fil_FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocs4b00fda4.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref4b00fda4.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocs4b00fda4.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	ref4b00fda4.value, cvalue_allocs = x.Value.PassValue()
	allocs4b00fda4.Borrow(cvalue_allocs)

	x.ref4b00fda4 = ref4b00fda4
	x.allocs4b00fda4 = allocs4b00fda4
	return ref4b00fda4, allocs4b00fda4

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilGeneratePieceCommitmentResponse) PassValue() (C.fil_GeneratePieceCommitmentResponse, *cgoAllocMap) {
	if x.ref4b00fda4 != nil {
		return *x.ref4b00fda4, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilGeneratePieceCommitmentResponse) Deref() {
	if x.ref4b00fda4 == nil {
		return
	}
	x.StatusCode = (FilFCPResponseStatus)(x.ref4b00fda4.status_code)
	x.ErrorMsg = *NewFilBytesRef(unsafe.Pointer(&x.ref4b00fda4.error_msg))
	x.Value = *NewFilGeneratePieceCommitmentRef(unsafe.Pointer(&x.ref4b00fda4.value))
}

// allocFilGenerateDataCommitmentResponseMemory allocates memory for type C.fil_GenerateDataCommitmentResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilGenerateDataCommitmentResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilGenerateDataCommitmentResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilGenerateDataCommitmentResponseValue = unsafe.Sizeof([1]C.fil_GenerateDataCommitmentResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilGenerateDataCommitmentResponse) Ref() *C.fil_GenerateDataCommitmentResponse {
	if x == nil {
		return nil
	}
	return x.ref87da7dd9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilGenerateDataCommitmentResponse) Free() {
	if x != nil && x.allocs87da7dd9 != nil {
		x.allocs87da7dd9.(*cgoAllocMap).Free()
		x.ref87da7dd9 = nil
	}
}

// NewFilGenerateDataCommitmentResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilGenerateDataCommitmentResponseRef(ref unsafe.Pointer) *FilGenerateDataCommitmentResponse {
	if ref == nil {
		return nil
	}
	obj := new(FilGenerateDataCommitmentResponse)
	obj.ref87da7dd9 = (*C.fil_GenerateDataCommitmentResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilGenerateDataCommitmentResponse) PassRef() (*C.fil_GenerateDataCommitmentResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref87da7dd9 != nil {
		return x.ref87da7dd9, nil
	}
	mem87da7dd9 := allocFilGenerateDataCommitmentResponseMemory(1)
	ref87da7dd9 := (*C.fil_GenerateDataCommitmentResponse)(mem87da7dd9)
	allocs87da7dd9 := new(cgoAllocMap)
	allocs87da7dd9.Add(mem87da7dd9)

	var cstatus_code_allocs *cgoAllocMap
	ref87da7dd9.status_code, cstatus_code_allocs = (C.fil_FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocs87da7dd9.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref87da7dd9.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocs87da7dd9.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	ref87da7dd9.value, cvalue_allocs = x.Value.PassValue()
	allocs87da7dd9.Borrow(cvalue_allocs)

	x.ref87da7dd9 = ref87da7dd9
	x.allocs87da7dd9 = allocs87da7dd9
	return ref87da7dd9, allocs87da7dd9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilGenerateDataCommitmentResponse) PassValue() (C.fil_GenerateDataCommitmentResponse, *cgoAllocMap) {
	if x.ref87da7dd9 != nil {
		return *x.ref87da7dd9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilGenerateDataCommitmentResponse) Deref() {
	if x.ref87da7dd9 == nil {
		return
	}
	x.StatusCode = (FilFCPResponseStatus)(x.ref87da7dd9.status_code)
	x.ErrorMsg = *NewFilBytesRef(unsafe.Pointer(&x.ref87da7dd9.error_msg))
	x.Value = *NewFilByteArray32Ref(unsafe.Pointer(&x.ref87da7dd9.value))
}

// allocFilClearCacheResponseMemory allocates memory for type C.fil_ClearCacheResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilClearCacheResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilClearCacheResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilClearCacheResponseValue = unsafe.Sizeof([1]C.fil_ClearCacheResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilClearCacheResponse) Ref() *C.fil_ClearCacheResponse {
	if x == nil {
		return nil
	}
	return x.refa9a80400
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilClearCacheResponse) Free() {
	if x != nil && x.allocsa9a80400 != nil {
		x.allocsa9a80400.(*cgoAllocMap).Free()
		x.refa9a80400 = nil
	}
}

// NewFilClearCacheResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilClearCacheResponseRef(ref unsafe.Pointer) *FilClearCacheResponse {
	if ref == nil {
		return nil
	}
	obj := new(FilClearCacheResponse)
	obj.refa9a80400 = (*C.fil_ClearCacheResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilClearCacheResponse) PassRef() (*C.fil_ClearCacheResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa9a80400 != nil {
		return x.refa9a80400, nil
	}
	mema9a80400 := allocFilClearCacheResponseMemory(1)
	refa9a80400 := (*C.fil_ClearCacheResponse)(mema9a80400)
	allocsa9a80400 := new(cgoAllocMap)
	allocsa9a80400.Add(mema9a80400)

	var cstatus_code_allocs *cgoAllocMap
	refa9a80400.status_code, cstatus_code_allocs = (C.fil_FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocsa9a80400.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	refa9a80400.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocsa9a80400.Borrow(cerror_msg_allocs)

	x.refa9a80400 = refa9a80400
	x.allocsa9a80400 = allocsa9a80400
	return refa9a80400, allocsa9a80400

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilClearCacheResponse) PassValue() (C.fil_ClearCacheResponse, *cgoAllocMap) {
	if x.refa9a80400 != nil {
		return *x.refa9a80400, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilClearCacheResponse) Deref() {
	if x.refa9a80400 == nil {
		return
	}
	x.StatusCode = (FilFCPResponseStatus)(x.refa9a80400.status_code)
	x.ErrorMsg = *NewFilBytesRef(unsafe.Pointer(&x.refa9a80400.error_msg))
}

// allocFilStringResponseMemory allocates memory for type C.fil_StringResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilStringResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilStringResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilStringResponseValue = unsafe.Sizeof([1]C.fil_StringResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilStringResponse) Ref() *C.fil_StringResponse {
	if x == nil {
		return nil
	}
	return x.ref4f413043
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilStringResponse) Free() {
	if x != nil && x.allocs4f413043 != nil {
		x.allocs4f413043.(*cgoAllocMap).Free()
		x.ref4f413043 = nil
	}
}

// NewFilStringResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilStringResponseRef(ref unsafe.Pointer) *FilStringResponse {
	if ref == nil {
		return nil
	}
	obj := new(FilStringResponse)
	obj.ref4f413043 = (*C.fil_StringResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilStringResponse) PassRef() (*C.fil_StringResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4f413043 != nil {
		return x.ref4f413043, nil
	}
	mem4f413043 := allocFilStringResponseMemory(1)
	ref4f413043 := (*C.fil_StringResponse)(mem4f413043)
	allocs4f413043 := new(cgoAllocMap)
	allocs4f413043.Add(mem4f413043)

	var cstatus_code_allocs *cgoAllocMap
	ref4f413043.status_code, cstatus_code_allocs = (C.fil_FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocs4f413043.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref4f413043.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocs4f413043.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	ref4f413043.value, cvalue_allocs = x.Value.PassValue()
	allocs4f413043.Borrow(cvalue_allocs)

	x.ref4f413043 = ref4f413043
	x.allocs4f413043 = allocs4f413043
	return ref4f413043, allocs4f413043

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilStringResponse) PassValue() (C.fil_StringResponse, *cgoAllocMap) {
	if x.ref4f413043 != nil {
		return *x.ref4f413043, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilStringResponse) Deref() {
	if x.ref4f413043 == nil {
		return
	}
	x.StatusCode = (FilFCPResponseStatus)(x.ref4f413043.status_code)
	x.ErrorMsg = *NewFilBytesRef(unsafe.Pointer(&x.ref4f413043.error_msg))
	x.Value = *NewFilBytesRef(unsafe.Pointer(&x.ref4f413043.value))
}

// allocFilFinalizeTicketResponseMemory allocates memory for type C.fil_FinalizeTicketResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilFinalizeTicketResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilFinalizeTicketResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilFinalizeTicketResponseValue = unsafe.Sizeof([1]C.fil_FinalizeTicketResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilFinalizeTicketResponse) Ref() *C.fil_FinalizeTicketResponse {
	if x == nil {
		return nil
	}
	return x.refb370fa86
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilFinalizeTicketResponse) Free() {
	if x != nil && x.allocsb370fa86 != nil {
		x.allocsb370fa86.(*cgoAllocMap).Free()
		x.refb370fa86 = nil
	}
}

// NewFilFinalizeTicketResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilFinalizeTicketResponseRef(ref unsafe.Pointer) *FilFinalizeTicketResponse {
	if ref == nil {
		return nil
	}
	obj := new(FilFinalizeTicketResponse)
	obj.refb370fa86 = (*C.fil_FinalizeTicketResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilFinalizeTicketResponse) PassRef() (*C.fil_FinalizeTicketResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb370fa86 != nil {
		return x.refb370fa86, nil
	}
	memb370fa86 := allocFilFinalizeTicketResponseMemory(1)
	refb370fa86 := (*C.fil_FinalizeTicketResponse)(memb370fa86)
	allocsb370fa86 := new(cgoAllocMap)
	allocsb370fa86.Add(memb370fa86)

	var cstatus_code_allocs *cgoAllocMap
	refb370fa86.status_code, cstatus_code_allocs = (C.fil_FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocsb370fa86.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	refb370fa86.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocsb370fa86.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	refb370fa86.value, cvalue_allocs = x.Value.PassValue()
	allocsb370fa86.Borrow(cvalue_allocs)

	x.refb370fa86 = refb370fa86
	x.allocsb370fa86 = allocsb370fa86
	return refb370fa86, allocsb370fa86

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilFinalizeTicketResponse) PassValue() (C.fil_FinalizeTicketResponse, *cgoAllocMap) {
	if x.refb370fa86 != nil {
		return *x.refb370fa86, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilFinalizeTicketResponse) Deref() {
	if x.refb370fa86 == nil {
		return
	}
	x.StatusCode = (FilFCPResponseStatus)(x.refb370fa86.status_code)
	x.ErrorMsg = *NewFilBytesRef(unsafe.Pointer(&x.refb370fa86.error_msg))
	x.Value = *NewFilByteArray32Ref(unsafe.Pointer(&x.refb370fa86.value))
}

// allocFilArrayBytesMemory allocates memory for type C.fil_Array_Bytes in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilArrayBytesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilArrayBytesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilArrayBytesValue = unsafe.Sizeof([1]C.fil_Array_Bytes{})

// allocPFilBytesMemory allocates memory for type *C.fil_Bytes in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPFilBytesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPFilBytesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPFilBytesValue = unsafe.Sizeof([1]*C.fil_Bytes{})

// unpackSSFilBytes transforms a sliced Go data structure into plain C format.
func unpackSSFilBytes(x [][]FilBytes) (unpacked **C.fil_Bytes, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPFilBytesMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.fil_Bytes)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocFilBytesMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.fil_Bytes)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.fil_Bytes)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.fil_Bytes)(h.Data)
	return
}

// packSSFilBytes reads sliced Go data structure out from plain C format.
func packSSFilBytes(v [][]FilBytes, ptr0 **C.fil_Bytes) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.fil_Bytes)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfFilBytesValue]C.fil_Bytes)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewFilBytesRef(unsafe.Pointer(&ptr2))
		}
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilArrayBytes) Ref() *C.fil_Array_Bytes {
	if x == nil {
		return nil
	}
	return x.ref5a0628b6
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilArrayBytes) Free() {
	if x != nil && x.allocs5a0628b6 != nil {
		x.allocs5a0628b6.(*cgoAllocMap).Free()
		x.ref5a0628b6 = nil
	}
}

// NewFilArrayBytesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilArrayBytesRef(ref unsafe.Pointer) *FilArrayBytes {
	if ref == nil {
		return nil
	}
	obj := new(FilArrayBytes)
	obj.ref5a0628b6 = (*C.fil_Array_Bytes)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilArrayBytes) PassRef() (*C.fil_Array_Bytes, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5a0628b6 != nil {
		return x.ref5a0628b6, nil
	}
	mem5a0628b6 := allocFilArrayBytesMemory(1)
	ref5a0628b6 := (*C.fil_Array_Bytes)(mem5a0628b6)
	allocs5a0628b6 := new(cgoAllocMap)
	allocs5a0628b6.Add(mem5a0628b6)

	var cptr_allocs *cgoAllocMap
	ref5a0628b6.ptr, cptr_allocs = unpackSSFilBytes(x.Ptr)
	allocs5a0628b6.Borrow(cptr_allocs)

	var clen_allocs *cgoAllocMap
	ref5a0628b6.len, clen_allocs = (C.uintptr_t)(x.Len), cgoAllocsUnknown
	allocs5a0628b6.Borrow(clen_allocs)

	x.ref5a0628b6 = ref5a0628b6
	x.allocs5a0628b6 = allocs5a0628b6
	return ref5a0628b6, allocs5a0628b6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilArrayBytes) PassValue() (C.fil_Array_Bytes, *cgoAllocMap) {
	if x.ref5a0628b6 != nil {
		return *x.ref5a0628b6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilArrayBytes) Deref() {
	if x.ref5a0628b6 == nil {
		return
	}
	packSSFilBytes(x.Ptr, x.ref5a0628b6.ptr)
	x.Len = (uint64)(x.ref5a0628b6.len)
}

// allocFilResultArrayBytesMemory allocates memory for type C.fil_Result_Array_Bytes in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilResultArrayBytesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilResultArrayBytesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilResultArrayBytesValue = unsafe.Sizeof([1]C.fil_Result_Array_Bytes{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilResultArrayBytes) Ref() *C.fil_Result_Array_Bytes {
	if x == nil {
		return nil
	}
	return x.reff29d0a90
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilResultArrayBytes) Free() {
	if x != nil && x.allocsf29d0a90 != nil {
		x.allocsf29d0a90.(*cgoAllocMap).Free()
		x.reff29d0a90 = nil
	}
}

// NewFilResultArrayBytesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilResultArrayBytesRef(ref unsafe.Pointer) *FilResultArrayBytes {
	if ref == nil {
		return nil
	}
	obj := new(FilResultArrayBytes)
	obj.reff29d0a90 = (*C.fil_Result_Array_Bytes)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilResultArrayBytes) PassRef() (*C.fil_Result_Array_Bytes, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff29d0a90 != nil {
		return x.reff29d0a90, nil
	}
	memf29d0a90 := allocFilResultArrayBytesMemory(1)
	reff29d0a90 := (*C.fil_Result_Array_Bytes)(memf29d0a90)
	allocsf29d0a90 := new(cgoAllocMap)
	allocsf29d0a90.Add(memf29d0a90)

	var cstatus_code_allocs *cgoAllocMap
	reff29d0a90.status_code, cstatus_code_allocs = (C.fil_FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocsf29d0a90.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	reff29d0a90.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocsf29d0a90.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	reff29d0a90.value, cvalue_allocs = x.Value.PassValue()
	allocsf29d0a90.Borrow(cvalue_allocs)

	x.reff29d0a90 = reff29d0a90
	x.allocsf29d0a90 = allocsf29d0a90
	return reff29d0a90, allocsf29d0a90

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilResultArrayBytes) PassValue() (C.fil_Result_Array_Bytes, *cgoAllocMap) {
	if x.reff29d0a90 != nil {
		return *x.reff29d0a90, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilResultArrayBytes) Deref() {
	if x.reff29d0a90 == nil {
		return
	}
	x.StatusCode = (FilFCPResponseStatus)(x.reff29d0a90.status_code)
	x.ErrorMsg = *NewFilBytesRef(unsafe.Pointer(&x.reff29d0a90.error_msg))
	x.Value = *NewFilArrayBytesRef(unsafe.Pointer(&x.reff29d0a90.value))
}

// allocFilGpuDeviceResponseMemory allocates memory for type C.fil_GpuDeviceResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilGpuDeviceResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilGpuDeviceResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilGpuDeviceResponseValue = unsafe.Sizeof([1]C.fil_GpuDeviceResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilGpuDeviceResponse) Ref() *C.fil_GpuDeviceResponse {
	if x == nil {
		return nil
	}
	return x.ref58f92915
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilGpuDeviceResponse) Free() {
	if x != nil && x.allocs58f92915 != nil {
		x.allocs58f92915.(*cgoAllocMap).Free()
		x.ref58f92915 = nil
	}
}

// NewFilGpuDeviceResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilGpuDeviceResponseRef(ref unsafe.Pointer) *FilGpuDeviceResponse {
	if ref == nil {
		return nil
	}
	obj := new(FilGpuDeviceResponse)
	obj.ref58f92915 = (*C.fil_GpuDeviceResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilGpuDeviceResponse) PassRef() (*C.fil_GpuDeviceResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref58f92915 != nil {
		return x.ref58f92915, nil
	}
	mem58f92915 := allocFilGpuDeviceResponseMemory(1)
	ref58f92915 := (*C.fil_GpuDeviceResponse)(mem58f92915)
	allocs58f92915 := new(cgoAllocMap)
	allocs58f92915.Add(mem58f92915)

	var cstatus_code_allocs *cgoAllocMap
	ref58f92915.status_code, cstatus_code_allocs = (C.fil_FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocs58f92915.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref58f92915.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocs58f92915.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	ref58f92915.value, cvalue_allocs = x.Value.PassValue()
	allocs58f92915.Borrow(cvalue_allocs)

	x.ref58f92915 = ref58f92915
	x.allocs58f92915 = allocs58f92915
	return ref58f92915, allocs58f92915

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilGpuDeviceResponse) PassValue() (C.fil_GpuDeviceResponse, *cgoAllocMap) {
	if x.ref58f92915 != nil {
		return *x.ref58f92915, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilGpuDeviceResponse) Deref() {
	if x.ref58f92915 == nil {
		return
	}
	x.StatusCode = (FilFCPResponseStatus)(x.ref58f92915.status_code)
	x.ErrorMsg = *NewFilBytesRef(unsafe.Pointer(&x.ref58f92915.error_msg))
	x.Value = *NewFilArrayBytesRef(unsafe.Pointer(&x.ref58f92915.value))
}

// allocFilInitLogFdResponseMemory allocates memory for type C.fil_InitLogFdResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilInitLogFdResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilInitLogFdResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilInitLogFdResponseValue = unsafe.Sizeof([1]C.fil_InitLogFdResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilInitLogFdResponse) Ref() *C.fil_InitLogFdResponse {
	if x == nil {
		return nil
	}
	return x.ref3c1a0a08
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilInitLogFdResponse) Free() {
	if x != nil && x.allocs3c1a0a08 != nil {
		x.allocs3c1a0a08.(*cgoAllocMap).Free()
		x.ref3c1a0a08 = nil
	}
}

// NewFilInitLogFdResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilInitLogFdResponseRef(ref unsafe.Pointer) *FilInitLogFdResponse {
	if ref == nil {
		return nil
	}
	obj := new(FilInitLogFdResponse)
	obj.ref3c1a0a08 = (*C.fil_InitLogFdResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilInitLogFdResponse) PassRef() (*C.fil_InitLogFdResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3c1a0a08 != nil {
		return x.ref3c1a0a08, nil
	}
	mem3c1a0a08 := allocFilInitLogFdResponseMemory(1)
	ref3c1a0a08 := (*C.fil_InitLogFdResponse)(mem3c1a0a08)
	allocs3c1a0a08 := new(cgoAllocMap)
	allocs3c1a0a08.Add(mem3c1a0a08)

	var cstatus_code_allocs *cgoAllocMap
	ref3c1a0a08.status_code, cstatus_code_allocs = (C.fil_FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocs3c1a0a08.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref3c1a0a08.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocs3c1a0a08.Borrow(cerror_msg_allocs)

	x.ref3c1a0a08 = ref3c1a0a08
	x.allocs3c1a0a08 = allocs3c1a0a08
	return ref3c1a0a08, allocs3c1a0a08

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilInitLogFdResponse) PassValue() (C.fil_InitLogFdResponse, *cgoAllocMap) {
	if x.ref3c1a0a08 != nil {
		return *x.ref3c1a0a08, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilInitLogFdResponse) Deref() {
	if x.ref3c1a0a08 == nil {
		return
	}
	x.StatusCode = (FilFCPResponseStatus)(x.ref3c1a0a08.status_code)
	x.ErrorMsg = *NewFilBytesRef(unsafe.Pointer(&x.ref3c1a0a08.error_msg))
}
