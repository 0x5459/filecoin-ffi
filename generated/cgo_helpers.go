// WARNING: This file has automatically been generated
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package generated

/*
#cgo LDFLAGS: -L${SRCDIR}/..
#cgo pkg-config: ${SRCDIR}/../filcrypto.pc
#include "../filcrypto.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"fmt"
	"runtime"
	"sync"
	"unsafe"
)

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

// allocSliceBoxedUint8TMemory allocates memory for type C.slice_boxed_uint8_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSliceBoxedUint8TMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSliceBoxedUint8TValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSliceBoxedUint8TValue = unsafe.Sizeof([1]C.slice_boxed_uint8_t{})

// copyPUint8TBytes copies the data from Go slice as *C.uint8_t.
func copyPUint8TBytes(slice *sliceHeader) (*C.uint8_t, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfUint8TValue) * slice.Len,
		Cap:  int(sizeOfUint8TValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.uint8_t)(mem0), allocs
}

type sliceHeader struct {
	Data unsafe.Pointer
	Len  int
	Cap  int
}

// allocUint8TMemory allocates memory for type C.uint8_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUint8TMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUint8TValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfUint8TValue = unsafe.Sizeof([1]C.uint8_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SliceBoxedUint8T) Ref() *C.slice_boxed_uint8_t {
	if x == nil {
		return nil
	}
	return x.ref2156ff4c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SliceBoxedUint8T) Free() {
	if x != nil && x.allocs2156ff4c != nil {
		x.allocs2156ff4c.(*cgoAllocMap).Free()
		x.ref2156ff4c = nil
	}
}

// NewSliceBoxedUint8TRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSliceBoxedUint8TRef(ref unsafe.Pointer) *SliceBoxedUint8T {
	if ref == nil {
		return nil
	}
	obj := new(SliceBoxedUint8T)
	obj.ref2156ff4c = (*C.slice_boxed_uint8_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SliceBoxedUint8T) PassRef() (*C.slice_boxed_uint8_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2156ff4c != nil {
		return x.ref2156ff4c, nil
	}
	mem2156ff4c := allocSliceBoxedUint8TMemory(1)
	ref2156ff4c := (*C.slice_boxed_uint8_t)(mem2156ff4c)
	allocs2156ff4c := new(cgoAllocMap)
	allocs2156ff4c.Add(mem2156ff4c)

	var cptr_allocs *cgoAllocMap
	ref2156ff4c.ptr, cptr_allocs = copyPUint8TBytes((*sliceHeader)(unsafe.Pointer(&x.Ptr)))
	allocs2156ff4c.Borrow(cptr_allocs)

	var clen_allocs *cgoAllocMap
	ref2156ff4c.len, clen_allocs = (C.size_t)(x.Len), cgoAllocsUnknown
	allocs2156ff4c.Borrow(clen_allocs)

	x.ref2156ff4c = ref2156ff4c
	x.allocs2156ff4c = allocs2156ff4c
	return ref2156ff4c, allocs2156ff4c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SliceBoxedUint8T) PassValue() (C.slice_boxed_uint8_t, *cgoAllocMap) {
	if x.ref2156ff4c != nil {
		return *x.ref2156ff4c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SliceBoxedUint8T) Deref() {
	if x.ref2156ff4c == nil {
		return
	}
	hxfc4425b := (*sliceHeader)(unsafe.Pointer(&x.Ptr))
	hxfc4425b.Data = unsafe.Pointer(x.ref2156ff4c.ptr)
	hxfc4425b.Cap = 0x7fffffff
	// hxfc4425b.Len = ?

	x.Len = (SizeT)(x.ref2156ff4c.len)
}

// allocSliceBoxedSliceBoxedUint8TMemory allocates memory for type C.slice_boxed_slice_boxed_uint8_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSliceBoxedSliceBoxedUint8TMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSliceBoxedSliceBoxedUint8TValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSliceBoxedSliceBoxedUint8TValue = unsafe.Sizeof([1]C.slice_boxed_slice_boxed_uint8_t{})

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// unpackSSliceBoxedUint8T transforms a sliced Go data structure into plain C format.
func unpackSSliceBoxedUint8T(x []SliceBoxedUint8T) (unpacked *C.slice_boxed_uint8_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocSliceBoxedUint8TMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.slice_boxed_uint8_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.slice_boxed_uint8_t)(h.Data)
	return
}

// packSSliceBoxedUint8T reads sliced Go data structure out from plain C format.
func packSSliceBoxedUint8T(v []SliceBoxedUint8T, ptr0 *C.slice_boxed_uint8_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSliceBoxedUint8TValue]C.slice_boxed_uint8_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSliceBoxedUint8TRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SliceBoxedSliceBoxedUint8T) Ref() *C.slice_boxed_slice_boxed_uint8_t {
	if x == nil {
		return nil
	}
	return x.refe6bf5160
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SliceBoxedSliceBoxedUint8T) Free() {
	if x != nil && x.allocse6bf5160 != nil {
		x.allocse6bf5160.(*cgoAllocMap).Free()
		x.refe6bf5160 = nil
	}
}

// NewSliceBoxedSliceBoxedUint8TRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSliceBoxedSliceBoxedUint8TRef(ref unsafe.Pointer) *SliceBoxedSliceBoxedUint8T {
	if ref == nil {
		return nil
	}
	obj := new(SliceBoxedSliceBoxedUint8T)
	obj.refe6bf5160 = (*C.slice_boxed_slice_boxed_uint8_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SliceBoxedSliceBoxedUint8T) PassRef() (*C.slice_boxed_slice_boxed_uint8_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe6bf5160 != nil {
		return x.refe6bf5160, nil
	}
	meme6bf5160 := allocSliceBoxedSliceBoxedUint8TMemory(1)
	refe6bf5160 := (*C.slice_boxed_slice_boxed_uint8_t)(meme6bf5160)
	allocse6bf5160 := new(cgoAllocMap)
	allocse6bf5160.Add(meme6bf5160)

	var cptr_allocs *cgoAllocMap
	refe6bf5160.ptr, cptr_allocs = unpackSSliceBoxedUint8T(x.Ptr)
	allocse6bf5160.Borrow(cptr_allocs)

	var clen_allocs *cgoAllocMap
	refe6bf5160.len, clen_allocs = (C.size_t)(x.Len), cgoAllocsUnknown
	allocse6bf5160.Borrow(clen_allocs)

	x.refe6bf5160 = refe6bf5160
	x.allocse6bf5160 = allocse6bf5160
	return refe6bf5160, allocse6bf5160

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SliceBoxedSliceBoxedUint8T) PassValue() (C.slice_boxed_slice_boxed_uint8_t, *cgoAllocMap) {
	if x.refe6bf5160 != nil {
		return *x.refe6bf5160, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SliceBoxedSliceBoxedUint8T) Deref() {
	if x.refe6bf5160 == nil {
		return
	}
	packSSliceBoxedUint8T(x.Ptr, x.refe6bf5160.ptr)
	x.Len = (SizeT)(x.refe6bf5160.len)
}

// allocResultSliceBoxedSliceBoxedUint8TMemory allocates memory for type C.Result_slice_boxed_slice_boxed_uint8_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocResultSliceBoxedSliceBoxedUint8TMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfResultSliceBoxedSliceBoxedUint8TValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfResultSliceBoxedSliceBoxedUint8TValue = unsafe.Sizeof([1]C.Result_slice_boxed_slice_boxed_uint8_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ResultSliceBoxedSliceBoxedUint8T) Ref() *C.Result_slice_boxed_slice_boxed_uint8_t {
	if x == nil {
		return nil
	}
	return x.ref44f2cc9e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ResultSliceBoxedSliceBoxedUint8T) Free() {
	if x != nil && x.allocs44f2cc9e != nil {
		x.allocs44f2cc9e.(*cgoAllocMap).Free()
		x.ref44f2cc9e = nil
	}
}

// NewResultSliceBoxedSliceBoxedUint8TRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewResultSliceBoxedSliceBoxedUint8TRef(ref unsafe.Pointer) *ResultSliceBoxedSliceBoxedUint8T {
	if ref == nil {
		return nil
	}
	obj := new(ResultSliceBoxedSliceBoxedUint8T)
	obj.ref44f2cc9e = (*C.Result_slice_boxed_slice_boxed_uint8_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ResultSliceBoxedSliceBoxedUint8T) PassRef() (*C.Result_slice_boxed_slice_boxed_uint8_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref44f2cc9e != nil {
		return x.ref44f2cc9e, nil
	}
	mem44f2cc9e := allocResultSliceBoxedSliceBoxedUint8TMemory(1)
	ref44f2cc9e := (*C.Result_slice_boxed_slice_boxed_uint8_t)(mem44f2cc9e)
	allocs44f2cc9e := new(cgoAllocMap)
	allocs44f2cc9e.Add(mem44f2cc9e)

	var cstatus_code_allocs *cgoAllocMap
	ref44f2cc9e.status_code, cstatus_code_allocs = (C.FCPResponseStatus_t)(x.StatusCode), cgoAllocsUnknown
	allocs44f2cc9e.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref44f2cc9e.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocs44f2cc9e.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	ref44f2cc9e.value, cvalue_allocs = x.Value.PassValue()
	allocs44f2cc9e.Borrow(cvalue_allocs)

	x.ref44f2cc9e = ref44f2cc9e
	x.allocs44f2cc9e = allocs44f2cc9e
	return ref44f2cc9e, allocs44f2cc9e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ResultSliceBoxedSliceBoxedUint8T) PassValue() (C.Result_slice_boxed_slice_boxed_uint8_t, *cgoAllocMap) {
	if x.ref44f2cc9e != nil {
		return *x.ref44f2cc9e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ResultSliceBoxedSliceBoxedUint8T) Deref() {
	if x.ref44f2cc9e == nil {
		return
	}
	x.StatusCode = (FCPResponseStatusT)(x.ref44f2cc9e.status_code)
	x.ErrorMsg = *NewSliceBoxedUint8TRef(unsafe.Pointer(&x.ref44f2cc9e.error_msg))
	x.Value = *NewSliceBoxedSliceBoxedUint8TRef(unsafe.Pointer(&x.ref44f2cc9e.value))
}

// allocResultVoidTMemory allocates memory for type C.Result_void_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocResultVoidTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfResultVoidTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfResultVoidTValue = unsafe.Sizeof([1]C.Result_void_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ResultVoidT) Ref() *C.Result_void_t {
	if x == nil {
		return nil
	}
	return x.ref4381f081
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ResultVoidT) Free() {
	if x != nil && x.allocs4381f081 != nil {
		x.allocs4381f081.(*cgoAllocMap).Free()
		x.ref4381f081 = nil
	}
}

// NewResultVoidTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewResultVoidTRef(ref unsafe.Pointer) *ResultVoidT {
	if ref == nil {
		return nil
	}
	obj := new(ResultVoidT)
	obj.ref4381f081 = (*C.Result_void_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ResultVoidT) PassRef() (*C.Result_void_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4381f081 != nil {
		return x.ref4381f081, nil
	}
	mem4381f081 := allocResultVoidTMemory(1)
	ref4381f081 := (*C.Result_void_t)(mem4381f081)
	allocs4381f081 := new(cgoAllocMap)
	allocs4381f081.Add(mem4381f081)

	var cstatus_code_allocs *cgoAllocMap
	ref4381f081.status_code, cstatus_code_allocs = (C.FCPResponseStatus_t)(x.StatusCode), cgoAllocsUnknown
	allocs4381f081.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref4381f081.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocs4381f081.Borrow(cerror_msg_allocs)

	x.ref4381f081 = ref4381f081
	x.allocs4381f081 = allocs4381f081
	return ref4381f081, allocs4381f081

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ResultVoidT) PassValue() (C.Result_void_t, *cgoAllocMap) {
	if x.ref4381f081 != nil {
		return *x.ref4381f081, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ResultVoidT) Deref() {
	if x.ref4381f081 == nil {
		return
	}
	x.StatusCode = (FCPResponseStatusT)(x.ref4381f081.status_code)
	x.ErrorMsg = *NewSliceBoxedUint8TRef(unsafe.Pointer(&x.ref4381f081.error_msg))
}

// allocSliceRefUint8TMemory allocates memory for type C.slice_ref_uint8_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSliceRefUint8TMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSliceRefUint8TValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSliceRefUint8TValue = unsafe.Sizeof([1]C.slice_ref_uint8_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SliceRefUint8T) Ref() *C.slice_ref_uint8_t {
	if x == nil {
		return nil
	}
	return x.refd8594c66
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SliceRefUint8T) Free() {
	if x != nil && x.allocsd8594c66 != nil {
		x.allocsd8594c66.(*cgoAllocMap).Free()
		x.refd8594c66 = nil
	}
}

// NewSliceRefUint8TRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSliceRefUint8TRef(ref unsafe.Pointer) *SliceRefUint8T {
	if ref == nil {
		return nil
	}
	obj := new(SliceRefUint8T)
	obj.refd8594c66 = (*C.slice_ref_uint8_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SliceRefUint8T) PassRef() (*C.slice_ref_uint8_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd8594c66 != nil {
		return x.refd8594c66, nil
	}
	memd8594c66 := allocSliceRefUint8TMemory(1)
	refd8594c66 := (*C.slice_ref_uint8_t)(memd8594c66)
	allocsd8594c66 := new(cgoAllocMap)
	allocsd8594c66.Add(memd8594c66)

	var cptr_allocs *cgoAllocMap
	refd8594c66.ptr, cptr_allocs = copyPUint8TBytes((*sliceHeader)(unsafe.Pointer(&x.Ptr)))
	allocsd8594c66.Borrow(cptr_allocs)

	var clen_allocs *cgoAllocMap
	refd8594c66.len, clen_allocs = (C.size_t)(x.Len), cgoAllocsUnknown
	allocsd8594c66.Borrow(clen_allocs)

	x.refd8594c66 = refd8594c66
	x.allocsd8594c66 = allocsd8594c66
	return refd8594c66, allocsd8594c66

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SliceRefUint8T) PassValue() (C.slice_ref_uint8_t, *cgoAllocMap) {
	if x.refd8594c66 != nil {
		return *x.refd8594c66, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SliceRefUint8T) Deref() {
	if x.refd8594c66 == nil {
		return
	}
	hxf95e7c8 := (*sliceHeader)(unsafe.Pointer(&x.Ptr))
	hxf95e7c8.Data = unsafe.Pointer(x.refd8594c66.ptr)
	hxf95e7c8.Cap = 0x7fffffff
	// hxf95e7c8.Len = ?

	x.Len = (SizeT)(x.refd8594c66.len)
}

// allocUint896ArrayTMemory allocates memory for type C.uint8_96_array_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUint896ArrayTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUint896ArrayTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfUint896ArrayTValue = unsafe.Sizeof([1]C.uint8_96_array_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Uint896ArrayT) Ref() *C.uint8_96_array_t {
	if x == nil {
		return nil
	}
	return x.refa6a34c86
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Uint896ArrayT) Free() {
	if x != nil && x.allocsa6a34c86 != nil {
		x.allocsa6a34c86.(*cgoAllocMap).Free()
		x.refa6a34c86 = nil
	}
}

// NewUint896ArrayTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewUint896ArrayTRef(ref unsafe.Pointer) *Uint896ArrayT {
	if ref == nil {
		return nil
	}
	obj := new(Uint896ArrayT)
	obj.refa6a34c86 = (*C.uint8_96_array_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Uint896ArrayT) PassRef() (*C.uint8_96_array_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa6a34c86 != nil {
		return x.refa6a34c86, nil
	}
	mema6a34c86 := allocUint896ArrayTMemory(1)
	refa6a34c86 := (*C.uint8_96_array_t)(mema6a34c86)
	allocsa6a34c86 := new(cgoAllocMap)
	allocsa6a34c86.Add(mema6a34c86)

	var cidx_allocs *cgoAllocMap
	refa6a34c86.idx, cidx_allocs = *(*[96]C.uint8_t)(unsafe.Pointer(&x.Idx)), cgoAllocsUnknown
	allocsa6a34c86.Borrow(cidx_allocs)

	x.refa6a34c86 = refa6a34c86
	x.allocsa6a34c86 = allocsa6a34c86
	return refa6a34c86, allocsa6a34c86

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Uint896ArrayT) PassValue() (C.uint8_96_array_t, *cgoAllocMap) {
	if x.refa6a34c86 != nil {
		return *x.refa6a34c86, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Uint896ArrayT) Deref() {
	if x.refa6a34c86 == nil {
		return
	}
	x.Idx = *(*[96]Uint8T)(unsafe.Pointer(&x.refa6a34c86.idx))
}

// allocBLSDigestTMemory allocates memory for type C.BLSDigest_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBLSDigestTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBLSDigestTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBLSDigestTValue = unsafe.Sizeof([1]C.BLSDigest_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BLSDigestT) Ref() *C.BLSDigest_t {
	if x == nil {
		return nil
	}
	return x.ref9d19b2e1
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BLSDigestT) Free() {
	if x != nil && x.allocs9d19b2e1 != nil {
		x.allocs9d19b2e1.(*cgoAllocMap).Free()
		x.ref9d19b2e1 = nil
	}
}

// NewBLSDigestTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBLSDigestTRef(ref unsafe.Pointer) *BLSDigestT {
	if ref == nil {
		return nil
	}
	obj := new(BLSDigestT)
	obj.ref9d19b2e1 = (*C.BLSDigest_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BLSDigestT) PassRef() (*C.BLSDigest_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9d19b2e1 != nil {
		return x.ref9d19b2e1, nil
	}
	mem9d19b2e1 := allocBLSDigestTMemory(1)
	ref9d19b2e1 := (*C.BLSDigest_t)(mem9d19b2e1)
	allocs9d19b2e1 := new(cgoAllocMap)
	allocs9d19b2e1.Add(mem9d19b2e1)

	var cinner_allocs *cgoAllocMap
	ref9d19b2e1.inner, cinner_allocs = x.Inner.PassValue()
	allocs9d19b2e1.Borrow(cinner_allocs)

	x.ref9d19b2e1 = ref9d19b2e1
	x.allocs9d19b2e1 = allocs9d19b2e1
	return ref9d19b2e1, allocs9d19b2e1

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BLSDigestT) PassValue() (C.BLSDigest_t, *cgoAllocMap) {
	if x.ref9d19b2e1 != nil {
		return *x.ref9d19b2e1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BLSDigestT) Deref() {
	if x.ref9d19b2e1 == nil {
		return
	}
	x.Inner = *NewUint896ArrayTRef(unsafe.Pointer(&x.ref9d19b2e1.inner))
}

// allocHashResponseTMemory allocates memory for type C.HashResponse_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocHashResponseTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfHashResponseTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfHashResponseTValue = unsafe.Sizeof([1]C.HashResponse_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *HashResponseT) Ref() *C.HashResponse_t {
	if x == nil {
		return nil
	}
	return x.ref2e22e5c0
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *HashResponseT) Free() {
	if x != nil && x.allocs2e22e5c0 != nil {
		x.allocs2e22e5c0.(*cgoAllocMap).Free()
		x.ref2e22e5c0 = nil
	}
}

// NewHashResponseTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewHashResponseTRef(ref unsafe.Pointer) *HashResponseT {
	if ref == nil {
		return nil
	}
	obj := new(HashResponseT)
	obj.ref2e22e5c0 = (*C.HashResponse_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *HashResponseT) PassRef() (*C.HashResponse_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2e22e5c0 != nil {
		return x.ref2e22e5c0, nil
	}
	mem2e22e5c0 := allocHashResponseTMemory(1)
	ref2e22e5c0 := (*C.HashResponse_t)(mem2e22e5c0)
	allocs2e22e5c0 := new(cgoAllocMap)
	allocs2e22e5c0.Add(mem2e22e5c0)

	var cdigest_allocs *cgoAllocMap
	ref2e22e5c0.digest, cdigest_allocs = x.Digest.PassValue()
	allocs2e22e5c0.Borrow(cdigest_allocs)

	x.ref2e22e5c0 = ref2e22e5c0
	x.allocs2e22e5c0 = allocs2e22e5c0
	return ref2e22e5c0, allocs2e22e5c0

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x HashResponseT) PassValue() (C.HashResponse_t, *cgoAllocMap) {
	if x.ref2e22e5c0 != nil {
		return *x.ref2e22e5c0, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *HashResponseT) Deref() {
	if x.ref2e22e5c0 == nil {
		return
	}
	x.Digest = *NewBLSDigestTRef(unsafe.Pointer(&x.ref2e22e5c0.digest))
}

// allocBLSSignatureTMemory allocates memory for type C.BLSSignature_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBLSSignatureTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBLSSignatureTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBLSSignatureTValue = unsafe.Sizeof([1]C.BLSSignature_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BLSSignatureT) Ref() *C.BLSSignature_t {
	if x == nil {
		return nil
	}
	return x.ref4552d217
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BLSSignatureT) Free() {
	if x != nil && x.allocs4552d217 != nil {
		x.allocs4552d217.(*cgoAllocMap).Free()
		x.ref4552d217 = nil
	}
}

// NewBLSSignatureTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBLSSignatureTRef(ref unsafe.Pointer) *BLSSignatureT {
	if ref == nil {
		return nil
	}
	obj := new(BLSSignatureT)
	obj.ref4552d217 = (*C.BLSSignature_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BLSSignatureT) PassRef() (*C.BLSSignature_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4552d217 != nil {
		return x.ref4552d217, nil
	}
	mem4552d217 := allocBLSSignatureTMemory(1)
	ref4552d217 := (*C.BLSSignature_t)(mem4552d217)
	allocs4552d217 := new(cgoAllocMap)
	allocs4552d217.Add(mem4552d217)

	var cinner_allocs *cgoAllocMap
	ref4552d217.inner, cinner_allocs = x.Inner.PassValue()
	allocs4552d217.Borrow(cinner_allocs)

	x.ref4552d217 = ref4552d217
	x.allocs4552d217 = allocs4552d217
	return ref4552d217, allocs4552d217

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BLSSignatureT) PassValue() (C.BLSSignature_t, *cgoAllocMap) {
	if x.ref4552d217 != nil {
		return *x.ref4552d217, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BLSSignatureT) Deref() {
	if x.ref4552d217 == nil {
		return
	}
	x.Inner = *NewUint896ArrayTRef(unsafe.Pointer(&x.ref4552d217.inner))
}

// allocAggregateResponseTMemory allocates memory for type C.AggregateResponse_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAggregateResponseTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAggregateResponseTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfAggregateResponseTValue = unsafe.Sizeof([1]C.AggregateResponse_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *AggregateResponseT) Ref() *C.AggregateResponse_t {
	if x == nil {
		return nil
	}
	return x.refe76ad5dd
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *AggregateResponseT) Free() {
	if x != nil && x.allocse76ad5dd != nil {
		x.allocse76ad5dd.(*cgoAllocMap).Free()
		x.refe76ad5dd = nil
	}
}

// NewAggregateResponseTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAggregateResponseTRef(ref unsafe.Pointer) *AggregateResponseT {
	if ref == nil {
		return nil
	}
	obj := new(AggregateResponseT)
	obj.refe76ad5dd = (*C.AggregateResponse_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *AggregateResponseT) PassRef() (*C.AggregateResponse_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe76ad5dd != nil {
		return x.refe76ad5dd, nil
	}
	meme76ad5dd := allocAggregateResponseTMemory(1)
	refe76ad5dd := (*C.AggregateResponse_t)(meme76ad5dd)
	allocse76ad5dd := new(cgoAllocMap)
	allocse76ad5dd.Add(meme76ad5dd)

	var csignature_allocs *cgoAllocMap
	refe76ad5dd.signature, csignature_allocs = x.Signature.PassValue()
	allocse76ad5dd.Borrow(csignature_allocs)

	x.refe76ad5dd = refe76ad5dd
	x.allocse76ad5dd = allocse76ad5dd
	return refe76ad5dd, allocse76ad5dd

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x AggregateResponseT) PassValue() (C.AggregateResponse_t, *cgoAllocMap) {
	if x.refe76ad5dd != nil {
		return *x.refe76ad5dd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *AggregateResponseT) Deref() {
	if x.refe76ad5dd == nil {
		return
	}
	x.Signature = *NewBLSSignatureTRef(unsafe.Pointer(&x.refe76ad5dd.signature))
}

// allocSliceRefSizeTMemory allocates memory for type C.slice_ref_size_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSliceRefSizeTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSliceRefSizeTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSliceRefSizeTValue = unsafe.Sizeof([1]C.slice_ref_size_t{})

// copyPSizeTBytes copies the data from Go slice as *C.size_t.
func copyPSizeTBytes(slice *sliceHeader) (*C.size_t, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfSizeTValue) * slice.Len,
		Cap:  int(sizeOfSizeTValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.size_t)(mem0), allocs
}

// allocSizeTMemory allocates memory for type C.size_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSizeTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSizeTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSizeTValue = unsafe.Sizeof([1]C.size_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SliceRefSizeT) Ref() *C.slice_ref_size_t {
	if x == nil {
		return nil
	}
	return x.refc9cb2248
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SliceRefSizeT) Free() {
	if x != nil && x.allocsc9cb2248 != nil {
		x.allocsc9cb2248.(*cgoAllocMap).Free()
		x.refc9cb2248 = nil
	}
}

// NewSliceRefSizeTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSliceRefSizeTRef(ref unsafe.Pointer) *SliceRefSizeT {
	if ref == nil {
		return nil
	}
	obj := new(SliceRefSizeT)
	obj.refc9cb2248 = (*C.slice_ref_size_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SliceRefSizeT) PassRef() (*C.slice_ref_size_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc9cb2248 != nil {
		return x.refc9cb2248, nil
	}
	memc9cb2248 := allocSliceRefSizeTMemory(1)
	refc9cb2248 := (*C.slice_ref_size_t)(memc9cb2248)
	allocsc9cb2248 := new(cgoAllocMap)
	allocsc9cb2248.Add(memc9cb2248)

	var cptr_allocs *cgoAllocMap
	refc9cb2248.ptr, cptr_allocs = copyPSizeTBytes((*sliceHeader)(unsafe.Pointer(&x.Ptr)))
	allocsc9cb2248.Borrow(cptr_allocs)

	var clen_allocs *cgoAllocMap
	refc9cb2248.len, clen_allocs = (C.size_t)(x.Len), cgoAllocsUnknown
	allocsc9cb2248.Borrow(clen_allocs)

	x.refc9cb2248 = refc9cb2248
	x.allocsc9cb2248 = allocsc9cb2248
	return refc9cb2248, allocsc9cb2248

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SliceRefSizeT) PassValue() (C.slice_ref_size_t, *cgoAllocMap) {
	if x.refc9cb2248 != nil {
		return *x.refc9cb2248, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SliceRefSizeT) Deref() {
	if x.refc9cb2248 == nil {
		return
	}
	hxff2234b := (*sliceHeader)(unsafe.Pointer(&x.Ptr))
	hxff2234b.Data = unsafe.Pointer(x.refc9cb2248.ptr)
	hxff2234b.Cap = 0x7fffffff
	// hxff2234b.Len = ?

	x.Len = (SizeT)(x.refc9cb2248.len)
}

// allocUint832ArrayTMemory allocates memory for type C.uint8_32_array_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUint832ArrayTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUint832ArrayTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfUint832ArrayTValue = unsafe.Sizeof([1]C.uint8_32_array_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Uint832ArrayT) Ref() *C.uint8_32_array_t {
	if x == nil {
		return nil
	}
	return x.refec6d8d43
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Uint832ArrayT) Free() {
	if x != nil && x.allocsec6d8d43 != nil {
		x.allocsec6d8d43.(*cgoAllocMap).Free()
		x.refec6d8d43 = nil
	}
}

// NewUint832ArrayTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewUint832ArrayTRef(ref unsafe.Pointer) *Uint832ArrayT {
	if ref == nil {
		return nil
	}
	obj := new(Uint832ArrayT)
	obj.refec6d8d43 = (*C.uint8_32_array_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Uint832ArrayT) PassRef() (*C.uint8_32_array_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refec6d8d43 != nil {
		return x.refec6d8d43, nil
	}
	memec6d8d43 := allocUint832ArrayTMemory(1)
	refec6d8d43 := (*C.uint8_32_array_t)(memec6d8d43)
	allocsec6d8d43 := new(cgoAllocMap)
	allocsec6d8d43.Add(memec6d8d43)

	var cidx_allocs *cgoAllocMap
	refec6d8d43.idx, cidx_allocs = *(*[32]C.uint8_t)(unsafe.Pointer(&x.Idx)), cgoAllocsUnknown
	allocsec6d8d43.Borrow(cidx_allocs)

	x.refec6d8d43 = refec6d8d43
	x.allocsec6d8d43 = allocsec6d8d43
	return refec6d8d43, allocsec6d8d43

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Uint832ArrayT) PassValue() (C.uint8_32_array_t, *cgoAllocMap) {
	if x.refec6d8d43 != nil {
		return *x.refec6d8d43, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Uint832ArrayT) Deref() {
	if x.refec6d8d43 == nil {
		return
	}
	x.Idx = *(*[32]Uint8T)(unsafe.Pointer(&x.refec6d8d43.idx))
}

// allocBLSPrivateKeyTMemory allocates memory for type C.BLSPrivateKey_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBLSPrivateKeyTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBLSPrivateKeyTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBLSPrivateKeyTValue = unsafe.Sizeof([1]C.BLSPrivateKey_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BLSPrivateKeyT) Ref() *C.BLSPrivateKey_t {
	if x == nil {
		return nil
	}
	return x.ref1033d34f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BLSPrivateKeyT) Free() {
	if x != nil && x.allocs1033d34f != nil {
		x.allocs1033d34f.(*cgoAllocMap).Free()
		x.ref1033d34f = nil
	}
}

// NewBLSPrivateKeyTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBLSPrivateKeyTRef(ref unsafe.Pointer) *BLSPrivateKeyT {
	if ref == nil {
		return nil
	}
	obj := new(BLSPrivateKeyT)
	obj.ref1033d34f = (*C.BLSPrivateKey_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BLSPrivateKeyT) PassRef() (*C.BLSPrivateKey_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1033d34f != nil {
		return x.ref1033d34f, nil
	}
	mem1033d34f := allocBLSPrivateKeyTMemory(1)
	ref1033d34f := (*C.BLSPrivateKey_t)(mem1033d34f)
	allocs1033d34f := new(cgoAllocMap)
	allocs1033d34f.Add(mem1033d34f)

	var cinner_allocs *cgoAllocMap
	ref1033d34f.inner, cinner_allocs = x.Inner.PassValue()
	allocs1033d34f.Borrow(cinner_allocs)

	x.ref1033d34f = ref1033d34f
	x.allocs1033d34f = allocs1033d34f
	return ref1033d34f, allocs1033d34f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BLSPrivateKeyT) PassValue() (C.BLSPrivateKey_t, *cgoAllocMap) {
	if x.ref1033d34f != nil {
		return *x.ref1033d34f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BLSPrivateKeyT) Deref() {
	if x.ref1033d34f == nil {
		return
	}
	x.Inner = *NewUint832ArrayTRef(unsafe.Pointer(&x.ref1033d34f.inner))
}

// allocPrivateKeyGenerateResponseTMemory allocates memory for type C.PrivateKeyGenerateResponse_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPrivateKeyGenerateResponseTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPrivateKeyGenerateResponseTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPrivateKeyGenerateResponseTValue = unsafe.Sizeof([1]C.PrivateKeyGenerateResponse_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PrivateKeyGenerateResponseT) Ref() *C.PrivateKeyGenerateResponse_t {
	if x == nil {
		return nil
	}
	return x.ref791c6bf1
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PrivateKeyGenerateResponseT) Free() {
	if x != nil && x.allocs791c6bf1 != nil {
		x.allocs791c6bf1.(*cgoAllocMap).Free()
		x.ref791c6bf1 = nil
	}
}

// NewPrivateKeyGenerateResponseTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPrivateKeyGenerateResponseTRef(ref unsafe.Pointer) *PrivateKeyGenerateResponseT {
	if ref == nil {
		return nil
	}
	obj := new(PrivateKeyGenerateResponseT)
	obj.ref791c6bf1 = (*C.PrivateKeyGenerateResponse_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PrivateKeyGenerateResponseT) PassRef() (*C.PrivateKeyGenerateResponse_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref791c6bf1 != nil {
		return x.ref791c6bf1, nil
	}
	mem791c6bf1 := allocPrivateKeyGenerateResponseTMemory(1)
	ref791c6bf1 := (*C.PrivateKeyGenerateResponse_t)(mem791c6bf1)
	allocs791c6bf1 := new(cgoAllocMap)
	allocs791c6bf1.Add(mem791c6bf1)

	var cprivate_key_allocs *cgoAllocMap
	ref791c6bf1.private_key, cprivate_key_allocs = x.PrivateKey.PassValue()
	allocs791c6bf1.Borrow(cprivate_key_allocs)

	x.ref791c6bf1 = ref791c6bf1
	x.allocs791c6bf1 = allocs791c6bf1
	return ref791c6bf1, allocs791c6bf1

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PrivateKeyGenerateResponseT) PassValue() (C.PrivateKeyGenerateResponse_t, *cgoAllocMap) {
	if x.ref791c6bf1 != nil {
		return *x.ref791c6bf1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PrivateKeyGenerateResponseT) Deref() {
	if x.ref791c6bf1 == nil {
		return
	}
	x.PrivateKey = *NewBLSPrivateKeyTRef(unsafe.Pointer(&x.ref791c6bf1.private_key))
}

// allocByteArray32TMemory allocates memory for type C.ByteArray32_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocByteArray32TMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfByteArray32TValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfByteArray32TValue = unsafe.Sizeof([1]C.ByteArray32_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ByteArray32T) Ref() *C.ByteArray32_t {
	if x == nil {
		return nil
	}
	return x.refd648bba7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ByteArray32T) Free() {
	if x != nil && x.allocsd648bba7 != nil {
		x.allocsd648bba7.(*cgoAllocMap).Free()
		x.refd648bba7 = nil
	}
}

// NewByteArray32TRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewByteArray32TRef(ref unsafe.Pointer) *ByteArray32T {
	if ref == nil {
		return nil
	}
	obj := new(ByteArray32T)
	obj.refd648bba7 = (*C.ByteArray32_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ByteArray32T) PassRef() (*C.ByteArray32_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd648bba7 != nil {
		return x.refd648bba7, nil
	}
	memd648bba7 := allocByteArray32TMemory(1)
	refd648bba7 := (*C.ByteArray32_t)(memd648bba7)
	allocsd648bba7 := new(cgoAllocMap)
	allocsd648bba7.Add(memd648bba7)

	var cinner_allocs *cgoAllocMap
	refd648bba7.inner, cinner_allocs = x.Inner.PassValue()
	allocsd648bba7.Borrow(cinner_allocs)

	x.refd648bba7 = refd648bba7
	x.allocsd648bba7 = allocsd648bba7
	return refd648bba7, allocsd648bba7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ByteArray32T) PassValue() (C.ByteArray32_t, *cgoAllocMap) {
	if x.refd648bba7 != nil {
		return *x.refd648bba7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ByteArray32T) Deref() {
	if x.refd648bba7 == nil {
		return
	}
	x.Inner = *NewUint832ArrayTRef(unsafe.Pointer(&x.refd648bba7.inner))
}

// allocPrivateKeySignResponseTMemory allocates memory for type C.PrivateKeySignResponse_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPrivateKeySignResponseTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPrivateKeySignResponseTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPrivateKeySignResponseTValue = unsafe.Sizeof([1]C.PrivateKeySignResponse_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PrivateKeySignResponseT) Ref() *C.PrivateKeySignResponse_t {
	if x == nil {
		return nil
	}
	return x.ref4b42f5cd
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PrivateKeySignResponseT) Free() {
	if x != nil && x.allocs4b42f5cd != nil {
		x.allocs4b42f5cd.(*cgoAllocMap).Free()
		x.ref4b42f5cd = nil
	}
}

// NewPrivateKeySignResponseTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPrivateKeySignResponseTRef(ref unsafe.Pointer) *PrivateKeySignResponseT {
	if ref == nil {
		return nil
	}
	obj := new(PrivateKeySignResponseT)
	obj.ref4b42f5cd = (*C.PrivateKeySignResponse_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PrivateKeySignResponseT) PassRef() (*C.PrivateKeySignResponse_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4b42f5cd != nil {
		return x.ref4b42f5cd, nil
	}
	mem4b42f5cd := allocPrivateKeySignResponseTMemory(1)
	ref4b42f5cd := (*C.PrivateKeySignResponse_t)(mem4b42f5cd)
	allocs4b42f5cd := new(cgoAllocMap)
	allocs4b42f5cd.Add(mem4b42f5cd)

	var csignature_allocs *cgoAllocMap
	ref4b42f5cd.signature, csignature_allocs = x.Signature.PassValue()
	allocs4b42f5cd.Borrow(csignature_allocs)

	x.ref4b42f5cd = ref4b42f5cd
	x.allocs4b42f5cd = allocs4b42f5cd
	return ref4b42f5cd, allocs4b42f5cd

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PrivateKeySignResponseT) PassValue() (C.PrivateKeySignResponse_t, *cgoAllocMap) {
	if x.ref4b42f5cd != nil {
		return *x.ref4b42f5cd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PrivateKeySignResponseT) Deref() {
	if x.ref4b42f5cd == nil {
		return
	}
	x.Signature = *NewBLSSignatureTRef(unsafe.Pointer(&x.ref4b42f5cd.signature))
}

// allocUint848ArrayTMemory allocates memory for type C.uint8_48_array_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUint848ArrayTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUint848ArrayTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfUint848ArrayTValue = unsafe.Sizeof([1]C.uint8_48_array_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Uint848ArrayT) Ref() *C.uint8_48_array_t {
	if x == nil {
		return nil
	}
	return x.ref9b9f1ca4
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Uint848ArrayT) Free() {
	if x != nil && x.allocs9b9f1ca4 != nil {
		x.allocs9b9f1ca4.(*cgoAllocMap).Free()
		x.ref9b9f1ca4 = nil
	}
}

// NewUint848ArrayTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewUint848ArrayTRef(ref unsafe.Pointer) *Uint848ArrayT {
	if ref == nil {
		return nil
	}
	obj := new(Uint848ArrayT)
	obj.ref9b9f1ca4 = (*C.uint8_48_array_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Uint848ArrayT) PassRef() (*C.uint8_48_array_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9b9f1ca4 != nil {
		return x.ref9b9f1ca4, nil
	}
	mem9b9f1ca4 := allocUint848ArrayTMemory(1)
	ref9b9f1ca4 := (*C.uint8_48_array_t)(mem9b9f1ca4)
	allocs9b9f1ca4 := new(cgoAllocMap)
	allocs9b9f1ca4.Add(mem9b9f1ca4)

	var cidx_allocs *cgoAllocMap
	ref9b9f1ca4.idx, cidx_allocs = *(*[48]C.uint8_t)(unsafe.Pointer(&x.Idx)), cgoAllocsUnknown
	allocs9b9f1ca4.Borrow(cidx_allocs)

	x.ref9b9f1ca4 = ref9b9f1ca4
	x.allocs9b9f1ca4 = allocs9b9f1ca4
	return ref9b9f1ca4, allocs9b9f1ca4

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Uint848ArrayT) PassValue() (C.uint8_48_array_t, *cgoAllocMap) {
	if x.ref9b9f1ca4 != nil {
		return *x.ref9b9f1ca4, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Uint848ArrayT) Deref() {
	if x.ref9b9f1ca4 == nil {
		return
	}
	x.Idx = *(*[48]Uint8T)(unsafe.Pointer(&x.ref9b9f1ca4.idx))
}

// allocBLSPublicKeyTMemory allocates memory for type C.BLSPublicKey_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBLSPublicKeyTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBLSPublicKeyTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBLSPublicKeyTValue = unsafe.Sizeof([1]C.BLSPublicKey_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BLSPublicKeyT) Ref() *C.BLSPublicKey_t {
	if x == nil {
		return nil
	}
	return x.ref24fd8d3
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BLSPublicKeyT) Free() {
	if x != nil && x.allocs24fd8d3 != nil {
		x.allocs24fd8d3.(*cgoAllocMap).Free()
		x.ref24fd8d3 = nil
	}
}

// NewBLSPublicKeyTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBLSPublicKeyTRef(ref unsafe.Pointer) *BLSPublicKeyT {
	if ref == nil {
		return nil
	}
	obj := new(BLSPublicKeyT)
	obj.ref24fd8d3 = (*C.BLSPublicKey_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BLSPublicKeyT) PassRef() (*C.BLSPublicKey_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref24fd8d3 != nil {
		return x.ref24fd8d3, nil
	}
	mem24fd8d3 := allocBLSPublicKeyTMemory(1)
	ref24fd8d3 := (*C.BLSPublicKey_t)(mem24fd8d3)
	allocs24fd8d3 := new(cgoAllocMap)
	allocs24fd8d3.Add(mem24fd8d3)

	var cinner_allocs *cgoAllocMap
	ref24fd8d3.inner, cinner_allocs = x.Inner.PassValue()
	allocs24fd8d3.Borrow(cinner_allocs)

	x.ref24fd8d3 = ref24fd8d3
	x.allocs24fd8d3 = allocs24fd8d3
	return ref24fd8d3, allocs24fd8d3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BLSPublicKeyT) PassValue() (C.BLSPublicKey_t, *cgoAllocMap) {
	if x.ref24fd8d3 != nil {
		return *x.ref24fd8d3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BLSPublicKeyT) Deref() {
	if x.ref24fd8d3 == nil {
		return
	}
	x.Inner = *NewUint848ArrayTRef(unsafe.Pointer(&x.ref24fd8d3.inner))
}

// allocPrivateKeyPublicKeyResponseTMemory allocates memory for type C.PrivateKeyPublicKeyResponse_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPrivateKeyPublicKeyResponseTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPrivateKeyPublicKeyResponseTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPrivateKeyPublicKeyResponseTValue = unsafe.Sizeof([1]C.PrivateKeyPublicKeyResponse_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PrivateKeyPublicKeyResponseT) Ref() *C.PrivateKeyPublicKeyResponse_t {
	if x == nil {
		return nil
	}
	return x.refbd679f8e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PrivateKeyPublicKeyResponseT) Free() {
	if x != nil && x.allocsbd679f8e != nil {
		x.allocsbd679f8e.(*cgoAllocMap).Free()
		x.refbd679f8e = nil
	}
}

// NewPrivateKeyPublicKeyResponseTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPrivateKeyPublicKeyResponseTRef(ref unsafe.Pointer) *PrivateKeyPublicKeyResponseT {
	if ref == nil {
		return nil
	}
	obj := new(PrivateKeyPublicKeyResponseT)
	obj.refbd679f8e = (*C.PrivateKeyPublicKeyResponse_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PrivateKeyPublicKeyResponseT) PassRef() (*C.PrivateKeyPublicKeyResponse_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refbd679f8e != nil {
		return x.refbd679f8e, nil
	}
	membd679f8e := allocPrivateKeyPublicKeyResponseTMemory(1)
	refbd679f8e := (*C.PrivateKeyPublicKeyResponse_t)(membd679f8e)
	allocsbd679f8e := new(cgoAllocMap)
	allocsbd679f8e.Add(membd679f8e)

	var cpublic_key_allocs *cgoAllocMap
	refbd679f8e.public_key, cpublic_key_allocs = x.PublicKey.PassValue()
	allocsbd679f8e.Borrow(cpublic_key_allocs)

	x.refbd679f8e = refbd679f8e
	x.allocsbd679f8e = allocsbd679f8e
	return refbd679f8e, allocsbd679f8e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PrivateKeyPublicKeyResponseT) PassValue() (C.PrivateKeyPublicKeyResponse_t, *cgoAllocMap) {
	if x.refbd679f8e != nil {
		return *x.refbd679f8e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PrivateKeyPublicKeyResponseT) Deref() {
	if x.refbd679f8e == nil {
		return
	}
	x.PublicKey = *NewBLSPublicKeyTRef(unsafe.Pointer(&x.refbd679f8e.public_key))
}

// allocZeroSignatureResponseTMemory allocates memory for type C.ZeroSignatureResponse_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocZeroSignatureResponseTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfZeroSignatureResponseTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfZeroSignatureResponseTValue = unsafe.Sizeof([1]C.ZeroSignatureResponse_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ZeroSignatureResponseT) Ref() *C.ZeroSignatureResponse_t {
	if x == nil {
		return nil
	}
	return x.ref46d5d59
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ZeroSignatureResponseT) Free() {
	if x != nil && x.allocs46d5d59 != nil {
		x.allocs46d5d59.(*cgoAllocMap).Free()
		x.ref46d5d59 = nil
	}
}

// NewZeroSignatureResponseTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewZeroSignatureResponseTRef(ref unsafe.Pointer) *ZeroSignatureResponseT {
	if ref == nil {
		return nil
	}
	obj := new(ZeroSignatureResponseT)
	obj.ref46d5d59 = (*C.ZeroSignatureResponse_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ZeroSignatureResponseT) PassRef() (*C.ZeroSignatureResponse_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref46d5d59 != nil {
		return x.ref46d5d59, nil
	}
	mem46d5d59 := allocZeroSignatureResponseTMemory(1)
	ref46d5d59 := (*C.ZeroSignatureResponse_t)(mem46d5d59)
	allocs46d5d59 := new(cgoAllocMap)
	allocs46d5d59.Add(mem46d5d59)

	var csignature_allocs *cgoAllocMap
	ref46d5d59.signature, csignature_allocs = x.Signature.PassValue()
	allocs46d5d59.Borrow(csignature_allocs)

	x.ref46d5d59 = ref46d5d59
	x.allocs46d5d59 = allocs46d5d59
	return ref46d5d59, allocs46d5d59

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ZeroSignatureResponseT) PassValue() (C.ZeroSignatureResponse_t, *cgoAllocMap) {
	if x.ref46d5d59 != nil {
		return *x.ref46d5d59, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ZeroSignatureResponseT) Deref() {
	if x.ref46d5d59 == nil {
		return
	}
	x.Signature = *NewBLSSignatureTRef(unsafe.Pointer(&x.ref46d5d59.signature))
}

// allocSliceRefUint64TMemory allocates memory for type C.slice_ref_uint64_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSliceRefUint64TMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSliceRefUint64TValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSliceRefUint64TValue = unsafe.Sizeof([1]C.slice_ref_uint64_t{})

// copyPUint64TBytes copies the data from Go slice as *C.uint64_t.
func copyPUint64TBytes(slice *sliceHeader) (*C.uint64_t, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfUint64TValue) * slice.Len,
		Cap:  int(sizeOfUint64TValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.uint64_t)(mem0), allocs
}

// allocUint64TMemory allocates memory for type C.uint64_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUint64TMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUint64TValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfUint64TValue = unsafe.Sizeof([1]C.uint64_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SliceRefUint64T) Ref() *C.slice_ref_uint64_t {
	if x == nil {
		return nil
	}
	return x.reff34e6912
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SliceRefUint64T) Free() {
	if x != nil && x.allocsf34e6912 != nil {
		x.allocsf34e6912.(*cgoAllocMap).Free()
		x.reff34e6912 = nil
	}
}

// NewSliceRefUint64TRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSliceRefUint64TRef(ref unsafe.Pointer) *SliceRefUint64T {
	if ref == nil {
		return nil
	}
	obj := new(SliceRefUint64T)
	obj.reff34e6912 = (*C.slice_ref_uint64_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SliceRefUint64T) PassRef() (*C.slice_ref_uint64_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff34e6912 != nil {
		return x.reff34e6912, nil
	}
	memf34e6912 := allocSliceRefUint64TMemory(1)
	reff34e6912 := (*C.slice_ref_uint64_t)(memf34e6912)
	allocsf34e6912 := new(cgoAllocMap)
	allocsf34e6912.Add(memf34e6912)

	var cptr_allocs *cgoAllocMap
	reff34e6912.ptr, cptr_allocs = copyPUint64TBytes((*sliceHeader)(unsafe.Pointer(&x.Ptr)))
	allocsf34e6912.Borrow(cptr_allocs)

	var clen_allocs *cgoAllocMap
	reff34e6912.len, clen_allocs = (C.size_t)(x.Len), cgoAllocsUnknown
	allocsf34e6912.Borrow(clen_allocs)

	x.reff34e6912 = reff34e6912
	x.allocsf34e6912 = allocsf34e6912
	return reff34e6912, allocsf34e6912

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SliceRefUint64T) PassValue() (C.slice_ref_uint64_t, *cgoAllocMap) {
	if x.reff34e6912 != nil {
		return *x.reff34e6912, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SliceRefUint64T) Deref() {
	if x.reff34e6912 == nil {
		return
	}
	hxff73280 := (*sliceHeader)(unsafe.Pointer(&x.Ptr))
	hxff73280.Data = unsafe.Pointer(x.reff34e6912.ptr)
	hxff73280.Cap = 0x7fffffff
	// hxff73280.Len = ?

	x.Len = (SizeT)(x.reff34e6912.len)
}

// allocWriteWithAlignmentTMemory allocates memory for type C.WriteWithAlignment_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocWriteWithAlignmentTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfWriteWithAlignmentTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfWriteWithAlignmentTValue = unsafe.Sizeof([1]C.WriteWithAlignment_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *WriteWithAlignmentT) Ref() *C.WriteWithAlignment_t {
	if x == nil {
		return nil
	}
	return x.ref3531b450
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *WriteWithAlignmentT) Free() {
	if x != nil && x.allocs3531b450 != nil {
		x.allocs3531b450.(*cgoAllocMap).Free()
		x.ref3531b450 = nil
	}
}

// NewWriteWithAlignmentTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewWriteWithAlignmentTRef(ref unsafe.Pointer) *WriteWithAlignmentT {
	if ref == nil {
		return nil
	}
	obj := new(WriteWithAlignmentT)
	obj.ref3531b450 = (*C.WriteWithAlignment_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *WriteWithAlignmentT) PassRef() (*C.WriteWithAlignment_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3531b450 != nil {
		return x.ref3531b450, nil
	}
	mem3531b450 := allocWriteWithAlignmentTMemory(1)
	ref3531b450 := (*C.WriteWithAlignment_t)(mem3531b450)
	allocs3531b450 := new(cgoAllocMap)
	allocs3531b450.Add(mem3531b450)

	var ccomm_p_allocs *cgoAllocMap
	ref3531b450.comm_p, ccomm_p_allocs = x.CommP.PassValue()
	allocs3531b450.Borrow(ccomm_p_allocs)

	var cleft_alignment_unpadded_allocs *cgoAllocMap
	ref3531b450.left_alignment_unpadded, cleft_alignment_unpadded_allocs = (C.uint64_t)(x.LeftAlignmentUnpadded), cgoAllocsUnknown
	allocs3531b450.Borrow(cleft_alignment_unpadded_allocs)

	var ctotal_write_unpadded_allocs *cgoAllocMap
	ref3531b450.total_write_unpadded, ctotal_write_unpadded_allocs = (C.uint64_t)(x.TotalWriteUnpadded), cgoAllocsUnknown
	allocs3531b450.Borrow(ctotal_write_unpadded_allocs)

	x.ref3531b450 = ref3531b450
	x.allocs3531b450 = allocs3531b450
	return ref3531b450, allocs3531b450

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x WriteWithAlignmentT) PassValue() (C.WriteWithAlignment_t, *cgoAllocMap) {
	if x.ref3531b450 != nil {
		return *x.ref3531b450, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *WriteWithAlignmentT) Deref() {
	if x.ref3531b450 == nil {
		return
	}
	x.CommP = *NewUint832ArrayTRef(unsafe.Pointer(&x.ref3531b450.comm_p))
	x.LeftAlignmentUnpadded = (Uint64T)(x.ref3531b450.left_alignment_unpadded)
	x.TotalWriteUnpadded = (Uint64T)(x.ref3531b450.total_write_unpadded)
}

// allocResultWriteWithAlignmentTMemory allocates memory for type C.Result_WriteWithAlignment_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocResultWriteWithAlignmentTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfResultWriteWithAlignmentTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfResultWriteWithAlignmentTValue = unsafe.Sizeof([1]C.Result_WriteWithAlignment_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ResultWriteWithAlignmentT) Ref() *C.Result_WriteWithAlignment_t {
	if x == nil {
		return nil
	}
	return x.refed31278e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ResultWriteWithAlignmentT) Free() {
	if x != nil && x.allocsed31278e != nil {
		x.allocsed31278e.(*cgoAllocMap).Free()
		x.refed31278e = nil
	}
}

// NewResultWriteWithAlignmentTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewResultWriteWithAlignmentTRef(ref unsafe.Pointer) *ResultWriteWithAlignmentT {
	if ref == nil {
		return nil
	}
	obj := new(ResultWriteWithAlignmentT)
	obj.refed31278e = (*C.Result_WriteWithAlignment_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ResultWriteWithAlignmentT) PassRef() (*C.Result_WriteWithAlignment_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refed31278e != nil {
		return x.refed31278e, nil
	}
	memed31278e := allocResultWriteWithAlignmentTMemory(1)
	refed31278e := (*C.Result_WriteWithAlignment_t)(memed31278e)
	allocsed31278e := new(cgoAllocMap)
	allocsed31278e.Add(memed31278e)

	var cstatus_code_allocs *cgoAllocMap
	refed31278e.status_code, cstatus_code_allocs = (C.FCPResponseStatus_t)(x.StatusCode), cgoAllocsUnknown
	allocsed31278e.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	refed31278e.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocsed31278e.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	refed31278e.value, cvalue_allocs = x.Value.PassValue()
	allocsed31278e.Borrow(cvalue_allocs)

	x.refed31278e = refed31278e
	x.allocsed31278e = allocsed31278e
	return refed31278e, allocsed31278e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ResultWriteWithAlignmentT) PassValue() (C.Result_WriteWithAlignment_t, *cgoAllocMap) {
	if x.refed31278e != nil {
		return *x.refed31278e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ResultWriteWithAlignmentT) Deref() {
	if x.refed31278e == nil {
		return
	}
	x.StatusCode = (FCPResponseStatusT)(x.refed31278e.status_code)
	x.ErrorMsg = *NewSliceBoxedUint8TRef(unsafe.Pointer(&x.refed31278e.error_msg))
	x.Value = *NewWriteWithAlignmentTRef(unsafe.Pointer(&x.refed31278e.value))
}

// allocWriteWithoutAlignmentTMemory allocates memory for type C.WriteWithoutAlignment_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocWriteWithoutAlignmentTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfWriteWithoutAlignmentTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfWriteWithoutAlignmentTValue = unsafe.Sizeof([1]C.WriteWithoutAlignment_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *WriteWithoutAlignmentT) Ref() *C.WriteWithoutAlignment_t {
	if x == nil {
		return nil
	}
	return x.ref591a420c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *WriteWithoutAlignmentT) Free() {
	if x != nil && x.allocs591a420c != nil {
		x.allocs591a420c.(*cgoAllocMap).Free()
		x.ref591a420c = nil
	}
}

// NewWriteWithoutAlignmentTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewWriteWithoutAlignmentTRef(ref unsafe.Pointer) *WriteWithoutAlignmentT {
	if ref == nil {
		return nil
	}
	obj := new(WriteWithoutAlignmentT)
	obj.ref591a420c = (*C.WriteWithoutAlignment_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *WriteWithoutAlignmentT) PassRef() (*C.WriteWithoutAlignment_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref591a420c != nil {
		return x.ref591a420c, nil
	}
	mem591a420c := allocWriteWithoutAlignmentTMemory(1)
	ref591a420c := (*C.WriteWithoutAlignment_t)(mem591a420c)
	allocs591a420c := new(cgoAllocMap)
	allocs591a420c.Add(mem591a420c)

	var ccomm_p_allocs *cgoAllocMap
	ref591a420c.comm_p, ccomm_p_allocs = x.CommP.PassValue()
	allocs591a420c.Borrow(ccomm_p_allocs)

	var ctotal_write_unpadded_allocs *cgoAllocMap
	ref591a420c.total_write_unpadded, ctotal_write_unpadded_allocs = (C.uint64_t)(x.TotalWriteUnpadded), cgoAllocsUnknown
	allocs591a420c.Borrow(ctotal_write_unpadded_allocs)

	x.ref591a420c = ref591a420c
	x.allocs591a420c = allocs591a420c
	return ref591a420c, allocs591a420c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x WriteWithoutAlignmentT) PassValue() (C.WriteWithoutAlignment_t, *cgoAllocMap) {
	if x.ref591a420c != nil {
		return *x.ref591a420c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *WriteWithoutAlignmentT) Deref() {
	if x.ref591a420c == nil {
		return
	}
	x.CommP = *NewUint832ArrayTRef(unsafe.Pointer(&x.ref591a420c.comm_p))
	x.TotalWriteUnpadded = (Uint64T)(x.ref591a420c.total_write_unpadded)
}

// allocResultWriteWithoutAlignmentTMemory allocates memory for type C.Result_WriteWithoutAlignment_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocResultWriteWithoutAlignmentTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfResultWriteWithoutAlignmentTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfResultWriteWithoutAlignmentTValue = unsafe.Sizeof([1]C.Result_WriteWithoutAlignment_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ResultWriteWithoutAlignmentT) Ref() *C.Result_WriteWithoutAlignment_t {
	if x == nil {
		return nil
	}
	return x.ref84618337
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ResultWriteWithoutAlignmentT) Free() {
	if x != nil && x.allocs84618337 != nil {
		x.allocs84618337.(*cgoAllocMap).Free()
		x.ref84618337 = nil
	}
}

// NewResultWriteWithoutAlignmentTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewResultWriteWithoutAlignmentTRef(ref unsafe.Pointer) *ResultWriteWithoutAlignmentT {
	if ref == nil {
		return nil
	}
	obj := new(ResultWriteWithoutAlignmentT)
	obj.ref84618337 = (*C.Result_WriteWithoutAlignment_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ResultWriteWithoutAlignmentT) PassRef() (*C.Result_WriteWithoutAlignment_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref84618337 != nil {
		return x.ref84618337, nil
	}
	mem84618337 := allocResultWriteWithoutAlignmentTMemory(1)
	ref84618337 := (*C.Result_WriteWithoutAlignment_t)(mem84618337)
	allocs84618337 := new(cgoAllocMap)
	allocs84618337.Add(mem84618337)

	var cstatus_code_allocs *cgoAllocMap
	ref84618337.status_code, cstatus_code_allocs = (C.FCPResponseStatus_t)(x.StatusCode), cgoAllocsUnknown
	allocs84618337.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref84618337.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocs84618337.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	ref84618337.value, cvalue_allocs = x.Value.PassValue()
	allocs84618337.Borrow(cvalue_allocs)

	x.ref84618337 = ref84618337
	x.allocs84618337 = allocs84618337
	return ref84618337, allocs84618337

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ResultWriteWithoutAlignmentT) PassValue() (C.Result_WriteWithoutAlignment_t, *cgoAllocMap) {
	if x.ref84618337 != nil {
		return *x.ref84618337, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ResultWriteWithoutAlignmentT) Deref() {
	if x.ref84618337 == nil {
		return
	}
	x.StatusCode = (FCPResponseStatusT)(x.ref84618337.status_code)
	x.ErrorMsg = *NewSliceBoxedUint8TRef(unsafe.Pointer(&x.ref84618337.error_msg))
	x.Value = *NewWriteWithoutAlignmentTRef(unsafe.Pointer(&x.ref84618337.value))
}

// allocResultByteArray32TMemory allocates memory for type C.Result_ByteArray32_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocResultByteArray32TMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfResultByteArray32TValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfResultByteArray32TValue = unsafe.Sizeof([1]C.Result_ByteArray32_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ResultByteArray32T) Ref() *C.Result_ByteArray32_t {
	if x == nil {
		return nil
	}
	return x.ref4c37f9af
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ResultByteArray32T) Free() {
	if x != nil && x.allocs4c37f9af != nil {
		x.allocs4c37f9af.(*cgoAllocMap).Free()
		x.ref4c37f9af = nil
	}
}

// NewResultByteArray32TRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewResultByteArray32TRef(ref unsafe.Pointer) *ResultByteArray32T {
	if ref == nil {
		return nil
	}
	obj := new(ResultByteArray32T)
	obj.ref4c37f9af = (*C.Result_ByteArray32_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ResultByteArray32T) PassRef() (*C.Result_ByteArray32_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4c37f9af != nil {
		return x.ref4c37f9af, nil
	}
	mem4c37f9af := allocResultByteArray32TMemory(1)
	ref4c37f9af := (*C.Result_ByteArray32_t)(mem4c37f9af)
	allocs4c37f9af := new(cgoAllocMap)
	allocs4c37f9af.Add(mem4c37f9af)

	var cstatus_code_allocs *cgoAllocMap
	ref4c37f9af.status_code, cstatus_code_allocs = (C.FCPResponseStatus_t)(x.StatusCode), cgoAllocsUnknown
	allocs4c37f9af.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref4c37f9af.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocs4c37f9af.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	ref4c37f9af.value, cvalue_allocs = x.Value.PassValue()
	allocs4c37f9af.Borrow(cvalue_allocs)

	x.ref4c37f9af = ref4c37f9af
	x.allocs4c37f9af = allocs4c37f9af
	return ref4c37f9af, allocs4c37f9af

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ResultByteArray32T) PassValue() (C.Result_ByteArray32_t, *cgoAllocMap) {
	if x.ref4c37f9af != nil {
		return *x.ref4c37f9af, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ResultByteArray32T) Deref() {
	if x.ref4c37f9af == nil {
		return
	}
	x.StatusCode = (FCPResponseStatusT)(x.ref4c37f9af.status_code)
	x.ErrorMsg = *NewSliceBoxedUint8TRef(unsafe.Pointer(&x.ref4c37f9af.error_msg))
	x.Value = *NewByteArray32TRef(unsafe.Pointer(&x.ref4c37f9af.value))
}

// allocPublicPieceInfoTMemory allocates memory for type C.PublicPieceInfo_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPublicPieceInfoTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPublicPieceInfoTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPublicPieceInfoTValue = unsafe.Sizeof([1]C.PublicPieceInfo_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PublicPieceInfoT) Ref() *C.PublicPieceInfo_t {
	if x == nil {
		return nil
	}
	return x.ref41775798
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PublicPieceInfoT) Free() {
	if x != nil && x.allocs41775798 != nil {
		x.allocs41775798.(*cgoAllocMap).Free()
		x.ref41775798 = nil
	}
}

// NewPublicPieceInfoTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPublicPieceInfoTRef(ref unsafe.Pointer) *PublicPieceInfoT {
	if ref == nil {
		return nil
	}
	obj := new(PublicPieceInfoT)
	obj.ref41775798 = (*C.PublicPieceInfo_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PublicPieceInfoT) PassRef() (*C.PublicPieceInfo_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref41775798 != nil {
		return x.ref41775798, nil
	}
	mem41775798 := allocPublicPieceInfoTMemory(1)
	ref41775798 := (*C.PublicPieceInfo_t)(mem41775798)
	allocs41775798 := new(cgoAllocMap)
	allocs41775798.Add(mem41775798)

	var cnum_bytes_allocs *cgoAllocMap
	ref41775798.num_bytes, cnum_bytes_allocs = (C.uint64_t)(x.NumBytes), cgoAllocsUnknown
	allocs41775798.Borrow(cnum_bytes_allocs)

	var ccomm_p_allocs *cgoAllocMap
	ref41775798.comm_p, ccomm_p_allocs = x.CommP.PassValue()
	allocs41775798.Borrow(ccomm_p_allocs)

	x.ref41775798 = ref41775798
	x.allocs41775798 = allocs41775798
	return ref41775798, allocs41775798

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PublicPieceInfoT) PassValue() (C.PublicPieceInfo_t, *cgoAllocMap) {
	if x.ref41775798 != nil {
		return *x.ref41775798, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PublicPieceInfoT) Deref() {
	if x.ref41775798 == nil {
		return
	}
	x.NumBytes = (Uint64T)(x.ref41775798.num_bytes)
	x.CommP = *NewUint832ArrayTRef(unsafe.Pointer(&x.ref41775798.comm_p))
}

// allocSliceRefPublicPieceInfoTMemory allocates memory for type C.slice_ref_PublicPieceInfo_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSliceRefPublicPieceInfoTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSliceRefPublicPieceInfoTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSliceRefPublicPieceInfoTValue = unsafe.Sizeof([1]C.slice_ref_PublicPieceInfo_t{})

// unpackSPublicPieceInfoT transforms a sliced Go data structure into plain C format.
func unpackSPublicPieceInfoT(x []PublicPieceInfoT) (unpacked *C.PublicPieceInfo_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPublicPieceInfoTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.PublicPieceInfo_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.PublicPieceInfo_t)(h.Data)
	return
}

// packSPublicPieceInfoT reads sliced Go data structure out from plain C format.
func packSPublicPieceInfoT(v []PublicPieceInfoT, ptr0 *C.PublicPieceInfo_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPublicPieceInfoTValue]C.PublicPieceInfo_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPublicPieceInfoTRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SliceRefPublicPieceInfoT) Ref() *C.slice_ref_PublicPieceInfo_t {
	if x == nil {
		return nil
	}
	return x.ref28c8f598
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SliceRefPublicPieceInfoT) Free() {
	if x != nil && x.allocs28c8f598 != nil {
		x.allocs28c8f598.(*cgoAllocMap).Free()
		x.ref28c8f598 = nil
	}
}

// NewSliceRefPublicPieceInfoTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSliceRefPublicPieceInfoTRef(ref unsafe.Pointer) *SliceRefPublicPieceInfoT {
	if ref == nil {
		return nil
	}
	obj := new(SliceRefPublicPieceInfoT)
	obj.ref28c8f598 = (*C.slice_ref_PublicPieceInfo_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SliceRefPublicPieceInfoT) PassRef() (*C.slice_ref_PublicPieceInfo_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref28c8f598 != nil {
		return x.ref28c8f598, nil
	}
	mem28c8f598 := allocSliceRefPublicPieceInfoTMemory(1)
	ref28c8f598 := (*C.slice_ref_PublicPieceInfo_t)(mem28c8f598)
	allocs28c8f598 := new(cgoAllocMap)
	allocs28c8f598.Add(mem28c8f598)

	var cptr_allocs *cgoAllocMap
	ref28c8f598.ptr, cptr_allocs = unpackSPublicPieceInfoT(x.Ptr)
	allocs28c8f598.Borrow(cptr_allocs)

	var clen_allocs *cgoAllocMap
	ref28c8f598.len, clen_allocs = (C.size_t)(x.Len), cgoAllocsUnknown
	allocs28c8f598.Borrow(clen_allocs)

	x.ref28c8f598 = ref28c8f598
	x.allocs28c8f598 = allocs28c8f598
	return ref28c8f598, allocs28c8f598

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SliceRefPublicPieceInfoT) PassValue() (C.slice_ref_PublicPieceInfo_t, *cgoAllocMap) {
	if x.ref28c8f598 != nil {
		return *x.ref28c8f598, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SliceRefPublicPieceInfoT) Deref() {
	if x.ref28c8f598 == nil {
		return
	}
	packSPublicPieceInfoT(x.Ptr, x.ref28c8f598.ptr)
	x.Len = (SizeT)(x.ref28c8f598.len)
}

// allocResultSliceBoxedUint8TMemory allocates memory for type C.Result_slice_boxed_uint8_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocResultSliceBoxedUint8TMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfResultSliceBoxedUint8TValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfResultSliceBoxedUint8TValue = unsafe.Sizeof([1]C.Result_slice_boxed_uint8_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ResultSliceBoxedUint8T) Ref() *C.Result_slice_boxed_uint8_t {
	if x == nil {
		return nil
	}
	return x.ref2ceefbe4
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ResultSliceBoxedUint8T) Free() {
	if x != nil && x.allocs2ceefbe4 != nil {
		x.allocs2ceefbe4.(*cgoAllocMap).Free()
		x.ref2ceefbe4 = nil
	}
}

// NewResultSliceBoxedUint8TRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewResultSliceBoxedUint8TRef(ref unsafe.Pointer) *ResultSliceBoxedUint8T {
	if ref == nil {
		return nil
	}
	obj := new(ResultSliceBoxedUint8T)
	obj.ref2ceefbe4 = (*C.Result_slice_boxed_uint8_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ResultSliceBoxedUint8T) PassRef() (*C.Result_slice_boxed_uint8_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2ceefbe4 != nil {
		return x.ref2ceefbe4, nil
	}
	mem2ceefbe4 := allocResultSliceBoxedUint8TMemory(1)
	ref2ceefbe4 := (*C.Result_slice_boxed_uint8_t)(mem2ceefbe4)
	allocs2ceefbe4 := new(cgoAllocMap)
	allocs2ceefbe4.Add(mem2ceefbe4)

	var cstatus_code_allocs *cgoAllocMap
	ref2ceefbe4.status_code, cstatus_code_allocs = (C.FCPResponseStatus_t)(x.StatusCode), cgoAllocsUnknown
	allocs2ceefbe4.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref2ceefbe4.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocs2ceefbe4.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	ref2ceefbe4.value, cvalue_allocs = x.Value.PassValue()
	allocs2ceefbe4.Borrow(cvalue_allocs)

	x.ref2ceefbe4 = ref2ceefbe4
	x.allocs2ceefbe4 = allocs2ceefbe4
	return ref2ceefbe4, allocs2ceefbe4

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ResultSliceBoxedUint8T) PassValue() (C.Result_slice_boxed_uint8_t, *cgoAllocMap) {
	if x.ref2ceefbe4 != nil {
		return *x.ref2ceefbe4, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ResultSliceBoxedUint8T) Deref() {
	if x.ref2ceefbe4 == nil {
		return
	}
	x.StatusCode = (FCPResponseStatusT)(x.ref2ceefbe4.status_code)
	x.ErrorMsg = *NewSliceBoxedUint8TRef(unsafe.Pointer(&x.ref2ceefbe4.error_msg))
	x.Value = *NewSliceBoxedUint8TRef(unsafe.Pointer(&x.ref2ceefbe4.value))
}

// allocSealPreCommitPhase2TMemory allocates memory for type C.SealPreCommitPhase2_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSealPreCommitPhase2TMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSealPreCommitPhase2TValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSealPreCommitPhase2TValue = unsafe.Sizeof([1]C.SealPreCommitPhase2_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SealPreCommitPhase2T) Ref() *C.SealPreCommitPhase2_t {
	if x == nil {
		return nil
	}
	return x.refcd07a1fc
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SealPreCommitPhase2T) Free() {
	if x != nil && x.allocscd07a1fc != nil {
		x.allocscd07a1fc.(*cgoAllocMap).Free()
		x.refcd07a1fc = nil
	}
}

// NewSealPreCommitPhase2TRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSealPreCommitPhase2TRef(ref unsafe.Pointer) *SealPreCommitPhase2T {
	if ref == nil {
		return nil
	}
	obj := new(SealPreCommitPhase2T)
	obj.refcd07a1fc = (*C.SealPreCommitPhase2_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SealPreCommitPhase2T) PassRef() (*C.SealPreCommitPhase2_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refcd07a1fc != nil {
		return x.refcd07a1fc, nil
	}
	memcd07a1fc := allocSealPreCommitPhase2TMemory(1)
	refcd07a1fc := (*C.SealPreCommitPhase2_t)(memcd07a1fc)
	allocscd07a1fc := new(cgoAllocMap)
	allocscd07a1fc.Add(memcd07a1fc)

	var cregistered_proof_allocs *cgoAllocMap
	refcd07a1fc.registered_proof, cregistered_proof_allocs = (C.RegisteredSealProof_t)(x.RegisteredProof), cgoAllocsUnknown
	allocscd07a1fc.Borrow(cregistered_proof_allocs)

	var ccomm_d_allocs *cgoAllocMap
	refcd07a1fc.comm_d, ccomm_d_allocs = x.CommD.PassValue()
	allocscd07a1fc.Borrow(ccomm_d_allocs)

	var ccomm_r_allocs *cgoAllocMap
	refcd07a1fc.comm_r, ccomm_r_allocs = x.CommR.PassValue()
	allocscd07a1fc.Borrow(ccomm_r_allocs)

	x.refcd07a1fc = refcd07a1fc
	x.allocscd07a1fc = allocscd07a1fc
	return refcd07a1fc, allocscd07a1fc

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SealPreCommitPhase2T) PassValue() (C.SealPreCommitPhase2_t, *cgoAllocMap) {
	if x.refcd07a1fc != nil {
		return *x.refcd07a1fc, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SealPreCommitPhase2T) Deref() {
	if x.refcd07a1fc == nil {
		return
	}
	x.RegisteredProof = (RegisteredSealProofT)(x.refcd07a1fc.registered_proof)
	x.CommD = *NewUint832ArrayTRef(unsafe.Pointer(&x.refcd07a1fc.comm_d))
	x.CommR = *NewUint832ArrayTRef(unsafe.Pointer(&x.refcd07a1fc.comm_r))
}

// allocResultSealPreCommitPhase2TMemory allocates memory for type C.Result_SealPreCommitPhase2_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocResultSealPreCommitPhase2TMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfResultSealPreCommitPhase2TValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfResultSealPreCommitPhase2TValue = unsafe.Sizeof([1]C.Result_SealPreCommitPhase2_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ResultSealPreCommitPhase2T) Ref() *C.Result_SealPreCommitPhase2_t {
	if x == nil {
		return nil
	}
	return x.refacb45ebc
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ResultSealPreCommitPhase2T) Free() {
	if x != nil && x.allocsacb45ebc != nil {
		x.allocsacb45ebc.(*cgoAllocMap).Free()
		x.refacb45ebc = nil
	}
}

// NewResultSealPreCommitPhase2TRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewResultSealPreCommitPhase2TRef(ref unsafe.Pointer) *ResultSealPreCommitPhase2T {
	if ref == nil {
		return nil
	}
	obj := new(ResultSealPreCommitPhase2T)
	obj.refacb45ebc = (*C.Result_SealPreCommitPhase2_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ResultSealPreCommitPhase2T) PassRef() (*C.Result_SealPreCommitPhase2_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refacb45ebc != nil {
		return x.refacb45ebc, nil
	}
	memacb45ebc := allocResultSealPreCommitPhase2TMemory(1)
	refacb45ebc := (*C.Result_SealPreCommitPhase2_t)(memacb45ebc)
	allocsacb45ebc := new(cgoAllocMap)
	allocsacb45ebc.Add(memacb45ebc)

	var cstatus_code_allocs *cgoAllocMap
	refacb45ebc.status_code, cstatus_code_allocs = (C.FCPResponseStatus_t)(x.StatusCode), cgoAllocsUnknown
	allocsacb45ebc.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	refacb45ebc.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocsacb45ebc.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	refacb45ebc.value, cvalue_allocs = x.Value.PassValue()
	allocsacb45ebc.Borrow(cvalue_allocs)

	x.refacb45ebc = refacb45ebc
	x.allocsacb45ebc = allocsacb45ebc
	return refacb45ebc, allocsacb45ebc

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ResultSealPreCommitPhase2T) PassValue() (C.Result_SealPreCommitPhase2_t, *cgoAllocMap) {
	if x.refacb45ebc != nil {
		return *x.refacb45ebc, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ResultSealPreCommitPhase2T) Deref() {
	if x.refacb45ebc == nil {
		return
	}
	x.StatusCode = (FCPResponseStatusT)(x.refacb45ebc.status_code)
	x.ErrorMsg = *NewSliceBoxedUint8TRef(unsafe.Pointer(&x.refacb45ebc.error_msg))
	x.Value = *NewSealPreCommitPhase2TRef(unsafe.Pointer(&x.refacb45ebc.value))
}

// allocSealCommitPhase2TMemory allocates memory for type C.SealCommitPhase2_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSealCommitPhase2TMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSealCommitPhase2TValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSealCommitPhase2TValue = unsafe.Sizeof([1]C.SealCommitPhase2_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SealCommitPhase2T) Ref() *C.SealCommitPhase2_t {
	if x == nil {
		return nil
	}
	return x.ref66b8d6ea
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SealCommitPhase2T) Free() {
	if x != nil && x.allocs66b8d6ea != nil {
		x.allocs66b8d6ea.(*cgoAllocMap).Free()
		x.ref66b8d6ea = nil
	}
}

// NewSealCommitPhase2TRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSealCommitPhase2TRef(ref unsafe.Pointer) *SealCommitPhase2T {
	if ref == nil {
		return nil
	}
	obj := new(SealCommitPhase2T)
	obj.ref66b8d6ea = (*C.SealCommitPhase2_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SealCommitPhase2T) PassRef() (*C.SealCommitPhase2_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref66b8d6ea != nil {
		return x.ref66b8d6ea, nil
	}
	mem66b8d6ea := allocSealCommitPhase2TMemory(1)
	ref66b8d6ea := (*C.SealCommitPhase2_t)(mem66b8d6ea)
	allocs66b8d6ea := new(cgoAllocMap)
	allocs66b8d6ea.Add(mem66b8d6ea)

	var cproof_allocs *cgoAllocMap
	ref66b8d6ea.proof, cproof_allocs = x.Proof.PassValue()
	allocs66b8d6ea.Borrow(cproof_allocs)

	x.ref66b8d6ea = ref66b8d6ea
	x.allocs66b8d6ea = allocs66b8d6ea
	return ref66b8d6ea, allocs66b8d6ea

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SealCommitPhase2T) PassValue() (C.SealCommitPhase2_t, *cgoAllocMap) {
	if x.ref66b8d6ea != nil {
		return *x.ref66b8d6ea, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SealCommitPhase2T) Deref() {
	if x.ref66b8d6ea == nil {
		return
	}
	x.Proof = *NewSliceBoxedUint8TRef(unsafe.Pointer(&x.ref66b8d6ea.proof))
}

// allocResultSealCommitPhase2TMemory allocates memory for type C.Result_SealCommitPhase2_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocResultSealCommitPhase2TMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfResultSealCommitPhase2TValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfResultSealCommitPhase2TValue = unsafe.Sizeof([1]C.Result_SealCommitPhase2_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ResultSealCommitPhase2T) Ref() *C.Result_SealCommitPhase2_t {
	if x == nil {
		return nil
	}
	return x.refb3d64060
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ResultSealCommitPhase2T) Free() {
	if x != nil && x.allocsb3d64060 != nil {
		x.allocsb3d64060.(*cgoAllocMap).Free()
		x.refb3d64060 = nil
	}
}

// NewResultSealCommitPhase2TRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewResultSealCommitPhase2TRef(ref unsafe.Pointer) *ResultSealCommitPhase2T {
	if ref == nil {
		return nil
	}
	obj := new(ResultSealCommitPhase2T)
	obj.refb3d64060 = (*C.Result_SealCommitPhase2_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ResultSealCommitPhase2T) PassRef() (*C.Result_SealCommitPhase2_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb3d64060 != nil {
		return x.refb3d64060, nil
	}
	memb3d64060 := allocResultSealCommitPhase2TMemory(1)
	refb3d64060 := (*C.Result_SealCommitPhase2_t)(memb3d64060)
	allocsb3d64060 := new(cgoAllocMap)
	allocsb3d64060.Add(memb3d64060)

	var cstatus_code_allocs *cgoAllocMap
	refb3d64060.status_code, cstatus_code_allocs = (C.FCPResponseStatus_t)(x.StatusCode), cgoAllocsUnknown
	allocsb3d64060.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	refb3d64060.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocsb3d64060.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	refb3d64060.value, cvalue_allocs = x.Value.PassValue()
	allocsb3d64060.Borrow(cvalue_allocs)

	x.refb3d64060 = refb3d64060
	x.allocsb3d64060 = allocsb3d64060
	return refb3d64060, allocsb3d64060

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ResultSealCommitPhase2T) PassValue() (C.Result_SealCommitPhase2_t, *cgoAllocMap) {
	if x.refb3d64060 != nil {
		return *x.refb3d64060, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ResultSealCommitPhase2T) Deref() {
	if x.refb3d64060 == nil {
		return
	}
	x.StatusCode = (FCPResponseStatusT)(x.refb3d64060.status_code)
	x.ErrorMsg = *NewSliceBoxedUint8TRef(unsafe.Pointer(&x.refb3d64060.error_msg))
	x.Value = *NewSealCommitPhase2TRef(unsafe.Pointer(&x.refb3d64060.value))
}

// allocSliceBoxedByteArray32TMemory allocates memory for type C.slice_boxed_ByteArray32_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSliceBoxedByteArray32TMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSliceBoxedByteArray32TValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSliceBoxedByteArray32TValue = unsafe.Sizeof([1]C.slice_boxed_ByteArray32_t{})

// unpackSByteArray32T transforms a sliced Go data structure into plain C format.
func unpackSByteArray32T(x []ByteArray32T) (unpacked *C.ByteArray32_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocByteArray32TMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.ByteArray32_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.ByteArray32_t)(h.Data)
	return
}

// packSByteArray32T reads sliced Go data structure out from plain C format.
func packSByteArray32T(v []ByteArray32T, ptr0 *C.ByteArray32_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfByteArray32TValue]C.ByteArray32_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewByteArray32TRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SliceBoxedByteArray32T) Ref() *C.slice_boxed_ByteArray32_t {
	if x == nil {
		return nil
	}
	return x.refe3015bfe
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SliceBoxedByteArray32T) Free() {
	if x != nil && x.allocse3015bfe != nil {
		x.allocse3015bfe.(*cgoAllocMap).Free()
		x.refe3015bfe = nil
	}
}

// NewSliceBoxedByteArray32TRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSliceBoxedByteArray32TRef(ref unsafe.Pointer) *SliceBoxedByteArray32T {
	if ref == nil {
		return nil
	}
	obj := new(SliceBoxedByteArray32T)
	obj.refe3015bfe = (*C.slice_boxed_ByteArray32_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SliceBoxedByteArray32T) PassRef() (*C.slice_boxed_ByteArray32_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe3015bfe != nil {
		return x.refe3015bfe, nil
	}
	meme3015bfe := allocSliceBoxedByteArray32TMemory(1)
	refe3015bfe := (*C.slice_boxed_ByteArray32_t)(meme3015bfe)
	allocse3015bfe := new(cgoAllocMap)
	allocse3015bfe.Add(meme3015bfe)

	var cptr_allocs *cgoAllocMap
	refe3015bfe.ptr, cptr_allocs = unpackSByteArray32T(x.Ptr)
	allocse3015bfe.Borrow(cptr_allocs)

	var clen_allocs *cgoAllocMap
	refe3015bfe.len, clen_allocs = (C.size_t)(x.Len), cgoAllocsUnknown
	allocse3015bfe.Borrow(clen_allocs)

	x.refe3015bfe = refe3015bfe
	x.allocse3015bfe = allocse3015bfe
	return refe3015bfe, allocse3015bfe

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SliceBoxedByteArray32T) PassValue() (C.slice_boxed_ByteArray32_t, *cgoAllocMap) {
	if x.refe3015bfe != nil {
		return *x.refe3015bfe, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SliceBoxedByteArray32T) Deref() {
	if x.refe3015bfe == nil {
		return
	}
	packSByteArray32T(x.Ptr, x.refe3015bfe.ptr)
	x.Len = (SizeT)(x.refe3015bfe.len)
}

// allocSliceRefSealCommitPhase2TMemory allocates memory for type C.slice_ref_SealCommitPhase2_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSliceRefSealCommitPhase2TMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSliceRefSealCommitPhase2TValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSliceRefSealCommitPhase2TValue = unsafe.Sizeof([1]C.slice_ref_SealCommitPhase2_t{})

// unpackSSealCommitPhase2T transforms a sliced Go data structure into plain C format.
func unpackSSealCommitPhase2T(x []SealCommitPhase2T) (unpacked *C.SealCommitPhase2_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocSealCommitPhase2TMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.SealCommitPhase2_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.SealCommitPhase2_t)(h.Data)
	return
}

// packSSealCommitPhase2T reads sliced Go data structure out from plain C format.
func packSSealCommitPhase2T(v []SealCommitPhase2T, ptr0 *C.SealCommitPhase2_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSealCommitPhase2TValue]C.SealCommitPhase2_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSealCommitPhase2TRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SliceRefSealCommitPhase2T) Ref() *C.slice_ref_SealCommitPhase2_t {
	if x == nil {
		return nil
	}
	return x.ref66d16948
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SliceRefSealCommitPhase2T) Free() {
	if x != nil && x.allocs66d16948 != nil {
		x.allocs66d16948.(*cgoAllocMap).Free()
		x.ref66d16948 = nil
	}
}

// NewSliceRefSealCommitPhase2TRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSliceRefSealCommitPhase2TRef(ref unsafe.Pointer) *SliceRefSealCommitPhase2T {
	if ref == nil {
		return nil
	}
	obj := new(SliceRefSealCommitPhase2T)
	obj.ref66d16948 = (*C.slice_ref_SealCommitPhase2_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SliceRefSealCommitPhase2T) PassRef() (*C.slice_ref_SealCommitPhase2_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref66d16948 != nil {
		return x.ref66d16948, nil
	}
	mem66d16948 := allocSliceRefSealCommitPhase2TMemory(1)
	ref66d16948 := (*C.slice_ref_SealCommitPhase2_t)(mem66d16948)
	allocs66d16948 := new(cgoAllocMap)
	allocs66d16948.Add(mem66d16948)

	var cptr_allocs *cgoAllocMap
	ref66d16948.ptr, cptr_allocs = unpackSSealCommitPhase2T(x.Ptr)
	allocs66d16948.Borrow(cptr_allocs)

	var clen_allocs *cgoAllocMap
	ref66d16948.len, clen_allocs = (C.size_t)(x.Len), cgoAllocsUnknown
	allocs66d16948.Borrow(clen_allocs)

	x.ref66d16948 = ref66d16948
	x.allocs66d16948 = allocs66d16948
	return ref66d16948, allocs66d16948

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SliceRefSealCommitPhase2T) PassValue() (C.slice_ref_SealCommitPhase2_t, *cgoAllocMap) {
	if x.ref66d16948 != nil {
		return *x.ref66d16948, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SliceRefSealCommitPhase2T) Deref() {
	if x.ref66d16948 == nil {
		return
	}
	packSSealCommitPhase2T(x.Ptr, x.ref66d16948.ptr)
	x.Len = (SizeT)(x.ref66d16948.len)
}

// allocAggregationInputsTMemory allocates memory for type C.AggregationInputs_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAggregationInputsTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAggregationInputsTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfAggregationInputsTValue = unsafe.Sizeof([1]C.AggregationInputs_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *AggregationInputsT) Ref() *C.AggregationInputs_t {
	if x == nil {
		return nil
	}
	return x.refb10889cf
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *AggregationInputsT) Free() {
	if x != nil && x.allocsb10889cf != nil {
		x.allocsb10889cf.(*cgoAllocMap).Free()
		x.refb10889cf = nil
	}
}

// NewAggregationInputsTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAggregationInputsTRef(ref unsafe.Pointer) *AggregationInputsT {
	if ref == nil {
		return nil
	}
	obj := new(AggregationInputsT)
	obj.refb10889cf = (*C.AggregationInputs_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *AggregationInputsT) PassRef() (*C.AggregationInputs_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb10889cf != nil {
		return x.refb10889cf, nil
	}
	memb10889cf := allocAggregationInputsTMemory(1)
	refb10889cf := (*C.AggregationInputs_t)(memb10889cf)
	allocsb10889cf := new(cgoAllocMap)
	allocsb10889cf.Add(memb10889cf)

	var ccomm_r_allocs *cgoAllocMap
	refb10889cf.comm_r, ccomm_r_allocs = x.CommR.PassValue()
	allocsb10889cf.Borrow(ccomm_r_allocs)

	var ccomm_d_allocs *cgoAllocMap
	refb10889cf.comm_d, ccomm_d_allocs = x.CommD.PassValue()
	allocsb10889cf.Borrow(ccomm_d_allocs)

	var csector_id_allocs *cgoAllocMap
	refb10889cf.sector_id, csector_id_allocs = (C.uint64_t)(x.SectorId), cgoAllocsUnknown
	allocsb10889cf.Borrow(csector_id_allocs)

	var cticket_allocs *cgoAllocMap
	refb10889cf.ticket, cticket_allocs = x.Ticket.PassValue()
	allocsb10889cf.Borrow(cticket_allocs)

	var cseed_allocs *cgoAllocMap
	refb10889cf.seed, cseed_allocs = x.Seed.PassValue()
	allocsb10889cf.Borrow(cseed_allocs)

	x.refb10889cf = refb10889cf
	x.allocsb10889cf = allocsb10889cf
	return refb10889cf, allocsb10889cf

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x AggregationInputsT) PassValue() (C.AggregationInputs_t, *cgoAllocMap) {
	if x.refb10889cf != nil {
		return *x.refb10889cf, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *AggregationInputsT) Deref() {
	if x.refb10889cf == nil {
		return
	}
	x.CommR = *NewByteArray32TRef(unsafe.Pointer(&x.refb10889cf.comm_r))
	x.CommD = *NewByteArray32TRef(unsafe.Pointer(&x.refb10889cf.comm_d))
	x.SectorId = (Uint64T)(x.refb10889cf.sector_id)
	x.Ticket = *NewByteArray32TRef(unsafe.Pointer(&x.refb10889cf.ticket))
	x.Seed = *NewByteArray32TRef(unsafe.Pointer(&x.refb10889cf.seed))
}

// allocSliceRefAggregationInputsTMemory allocates memory for type C.slice_ref_AggregationInputs_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSliceRefAggregationInputsTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSliceRefAggregationInputsTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSliceRefAggregationInputsTValue = unsafe.Sizeof([1]C.slice_ref_AggregationInputs_t{})

// unpackSAggregationInputsT transforms a sliced Go data structure into plain C format.
func unpackSAggregationInputsT(x []AggregationInputsT) (unpacked *C.AggregationInputs_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocAggregationInputsTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.AggregationInputs_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.AggregationInputs_t)(h.Data)
	return
}

// packSAggregationInputsT reads sliced Go data structure out from plain C format.
func packSAggregationInputsT(v []AggregationInputsT, ptr0 *C.AggregationInputs_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfAggregationInputsTValue]C.AggregationInputs_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewAggregationInputsTRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SliceRefAggregationInputsT) Ref() *C.slice_ref_AggregationInputs_t {
	if x == nil {
		return nil
	}
	return x.ref89d022b4
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SliceRefAggregationInputsT) Free() {
	if x != nil && x.allocs89d022b4 != nil {
		x.allocs89d022b4.(*cgoAllocMap).Free()
		x.ref89d022b4 = nil
	}
}

// NewSliceRefAggregationInputsTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSliceRefAggregationInputsTRef(ref unsafe.Pointer) *SliceRefAggregationInputsT {
	if ref == nil {
		return nil
	}
	obj := new(SliceRefAggregationInputsT)
	obj.ref89d022b4 = (*C.slice_ref_AggregationInputs_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SliceRefAggregationInputsT) PassRef() (*C.slice_ref_AggregationInputs_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref89d022b4 != nil {
		return x.ref89d022b4, nil
	}
	mem89d022b4 := allocSliceRefAggregationInputsTMemory(1)
	ref89d022b4 := (*C.slice_ref_AggregationInputs_t)(mem89d022b4)
	allocs89d022b4 := new(cgoAllocMap)
	allocs89d022b4.Add(mem89d022b4)

	var cptr_allocs *cgoAllocMap
	ref89d022b4.ptr, cptr_allocs = unpackSAggregationInputsT(x.Ptr)
	allocs89d022b4.Borrow(cptr_allocs)

	var clen_allocs *cgoAllocMap
	ref89d022b4.len, clen_allocs = (C.size_t)(x.Len), cgoAllocsUnknown
	allocs89d022b4.Borrow(clen_allocs)

	x.ref89d022b4 = ref89d022b4
	x.allocs89d022b4 = allocs89d022b4
	return ref89d022b4, allocs89d022b4

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SliceRefAggregationInputsT) PassValue() (C.slice_ref_AggregationInputs_t, *cgoAllocMap) {
	if x.ref89d022b4 != nil {
		return *x.ref89d022b4, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SliceRefAggregationInputsT) Deref() {
	if x.ref89d022b4 == nil {
		return
	}
	packSAggregationInputsT(x.Ptr, x.ref89d022b4.ptr)
	x.Len = (SizeT)(x.ref89d022b4.len)
}

// allocResultBoolTMemory allocates memory for type C.Result_bool_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocResultBoolTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfResultBoolTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfResultBoolTValue = unsafe.Sizeof([1]C.Result_bool_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ResultBoolT) Ref() *C.Result_bool_t {
	if x == nil {
		return nil
	}
	return x.reff0bebe68
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ResultBoolT) Free() {
	if x != nil && x.allocsf0bebe68 != nil {
		x.allocsf0bebe68.(*cgoAllocMap).Free()
		x.reff0bebe68 = nil
	}
}

// NewResultBoolTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewResultBoolTRef(ref unsafe.Pointer) *ResultBoolT {
	if ref == nil {
		return nil
	}
	obj := new(ResultBoolT)
	obj.reff0bebe68 = (*C.Result_bool_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ResultBoolT) PassRef() (*C.Result_bool_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff0bebe68 != nil {
		return x.reff0bebe68, nil
	}
	memf0bebe68 := allocResultBoolTMemory(1)
	reff0bebe68 := (*C.Result_bool_t)(memf0bebe68)
	allocsf0bebe68 := new(cgoAllocMap)
	allocsf0bebe68.Add(memf0bebe68)

	var cstatus_code_allocs *cgoAllocMap
	reff0bebe68.status_code, cstatus_code_allocs = (C.FCPResponseStatus_t)(x.StatusCode), cgoAllocsUnknown
	allocsf0bebe68.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	reff0bebe68.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocsf0bebe68.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	reff0bebe68.value, cvalue_allocs = (C._Bool)(x.Value), cgoAllocsUnknown
	allocsf0bebe68.Borrow(cvalue_allocs)

	x.reff0bebe68 = reff0bebe68
	x.allocsf0bebe68 = allocsf0bebe68
	return reff0bebe68, allocsf0bebe68

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ResultBoolT) PassValue() (C.Result_bool_t, *cgoAllocMap) {
	if x.reff0bebe68 != nil {
		return *x.reff0bebe68, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ResultBoolT) Deref() {
	if x.reff0bebe68 == nil {
		return
	}
	x.StatusCode = (FCPResponseStatusT)(x.reff0bebe68.status_code)
	x.ErrorMsg = *NewSliceBoxedUint8TRef(unsafe.Pointer(&x.reff0bebe68.error_msg))
	x.Value = (bool)(x.reff0bebe68.value)
}

// allocSliceBoxedUint64TMemory allocates memory for type C.slice_boxed_uint64_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSliceBoxedUint64TMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSliceBoxedUint64TValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSliceBoxedUint64TValue = unsafe.Sizeof([1]C.slice_boxed_uint64_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SliceBoxedUint64T) Ref() *C.slice_boxed_uint64_t {
	if x == nil {
		return nil
	}
	return x.ref280caf77
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SliceBoxedUint64T) Free() {
	if x != nil && x.allocs280caf77 != nil {
		x.allocs280caf77.(*cgoAllocMap).Free()
		x.ref280caf77 = nil
	}
}

// NewSliceBoxedUint64TRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSliceBoxedUint64TRef(ref unsafe.Pointer) *SliceBoxedUint64T {
	if ref == nil {
		return nil
	}
	obj := new(SliceBoxedUint64T)
	obj.ref280caf77 = (*C.slice_boxed_uint64_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SliceBoxedUint64T) PassRef() (*C.slice_boxed_uint64_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref280caf77 != nil {
		return x.ref280caf77, nil
	}
	mem280caf77 := allocSliceBoxedUint64TMemory(1)
	ref280caf77 := (*C.slice_boxed_uint64_t)(mem280caf77)
	allocs280caf77 := new(cgoAllocMap)
	allocs280caf77.Add(mem280caf77)

	var cptr_allocs *cgoAllocMap
	ref280caf77.ptr, cptr_allocs = copyPUint64TBytes((*sliceHeader)(unsafe.Pointer(&x.Ptr)))
	allocs280caf77.Borrow(cptr_allocs)

	var clen_allocs *cgoAllocMap
	ref280caf77.len, clen_allocs = (C.size_t)(x.Len), cgoAllocsUnknown
	allocs280caf77.Borrow(clen_allocs)

	x.ref280caf77 = ref280caf77
	x.allocs280caf77 = allocs280caf77
	return ref280caf77, allocs280caf77

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SliceBoxedUint64T) PassValue() (C.slice_boxed_uint64_t, *cgoAllocMap) {
	if x.ref280caf77 != nil {
		return *x.ref280caf77, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SliceBoxedUint64T) Deref() {
	if x.ref280caf77 == nil {
		return
	}
	hxfa9955c := (*sliceHeader)(unsafe.Pointer(&x.Ptr))
	hxfa9955c.Data = unsafe.Pointer(x.ref280caf77.ptr)
	hxfa9955c.Cap = 0x7fffffff
	// hxfa9955c.Len = ?

	x.Len = (SizeT)(x.ref280caf77.len)
}

// allocResultSliceBoxedUint64TMemory allocates memory for type C.Result_slice_boxed_uint64_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocResultSliceBoxedUint64TMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfResultSliceBoxedUint64TValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfResultSliceBoxedUint64TValue = unsafe.Sizeof([1]C.Result_slice_boxed_uint64_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ResultSliceBoxedUint64T) Ref() *C.Result_slice_boxed_uint64_t {
	if x == nil {
		return nil
	}
	return x.reff00c3ca9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ResultSliceBoxedUint64T) Free() {
	if x != nil && x.allocsf00c3ca9 != nil {
		x.allocsf00c3ca9.(*cgoAllocMap).Free()
		x.reff00c3ca9 = nil
	}
}

// NewResultSliceBoxedUint64TRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewResultSliceBoxedUint64TRef(ref unsafe.Pointer) *ResultSliceBoxedUint64T {
	if ref == nil {
		return nil
	}
	obj := new(ResultSliceBoxedUint64T)
	obj.reff00c3ca9 = (*C.Result_slice_boxed_uint64_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ResultSliceBoxedUint64T) PassRef() (*C.Result_slice_boxed_uint64_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff00c3ca9 != nil {
		return x.reff00c3ca9, nil
	}
	memf00c3ca9 := allocResultSliceBoxedUint64TMemory(1)
	reff00c3ca9 := (*C.Result_slice_boxed_uint64_t)(memf00c3ca9)
	allocsf00c3ca9 := new(cgoAllocMap)
	allocsf00c3ca9.Add(memf00c3ca9)

	var cstatus_code_allocs *cgoAllocMap
	reff00c3ca9.status_code, cstatus_code_allocs = (C.FCPResponseStatus_t)(x.StatusCode), cgoAllocsUnknown
	allocsf00c3ca9.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	reff00c3ca9.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocsf00c3ca9.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	reff00c3ca9.value, cvalue_allocs = x.Value.PassValue()
	allocsf00c3ca9.Borrow(cvalue_allocs)

	x.reff00c3ca9 = reff00c3ca9
	x.allocsf00c3ca9 = allocsf00c3ca9
	return reff00c3ca9, allocsf00c3ca9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ResultSliceBoxedUint64T) PassValue() (C.Result_slice_boxed_uint64_t, *cgoAllocMap) {
	if x.reff00c3ca9 != nil {
		return *x.reff00c3ca9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ResultSliceBoxedUint64T) Deref() {
	if x.reff00c3ca9 == nil {
		return
	}
	x.StatusCode = (FCPResponseStatusT)(x.reff00c3ca9.status_code)
	x.ErrorMsg = *NewSliceBoxedUint8TRef(unsafe.Pointer(&x.reff00c3ca9.error_msg))
	x.Value = *NewSliceBoxedUint64TRef(unsafe.Pointer(&x.reff00c3ca9.value))
}

// allocGenerateFallbackSectorChallengesTMemory allocates memory for type C.GenerateFallbackSectorChallenges_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocGenerateFallbackSectorChallengesTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfGenerateFallbackSectorChallengesTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfGenerateFallbackSectorChallengesTValue = unsafe.Sizeof([1]C.GenerateFallbackSectorChallenges_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *GenerateFallbackSectorChallengesT) Ref() *C.GenerateFallbackSectorChallenges_t {
	if x == nil {
		return nil
	}
	return x.ref1a0802cf
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *GenerateFallbackSectorChallengesT) Free() {
	if x != nil && x.allocs1a0802cf != nil {
		x.allocs1a0802cf.(*cgoAllocMap).Free()
		x.ref1a0802cf = nil
	}
}

// NewGenerateFallbackSectorChallengesTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewGenerateFallbackSectorChallengesTRef(ref unsafe.Pointer) *GenerateFallbackSectorChallengesT {
	if ref == nil {
		return nil
	}
	obj := new(GenerateFallbackSectorChallengesT)
	obj.ref1a0802cf = (*C.GenerateFallbackSectorChallenges_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *GenerateFallbackSectorChallengesT) PassRef() (*C.GenerateFallbackSectorChallenges_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1a0802cf != nil {
		return x.ref1a0802cf, nil
	}
	mem1a0802cf := allocGenerateFallbackSectorChallengesTMemory(1)
	ref1a0802cf := (*C.GenerateFallbackSectorChallenges_t)(mem1a0802cf)
	allocs1a0802cf := new(cgoAllocMap)
	allocs1a0802cf.Add(mem1a0802cf)

	var cids_allocs *cgoAllocMap
	ref1a0802cf.ids, cids_allocs = x.Ids.PassValue()
	allocs1a0802cf.Borrow(cids_allocs)

	var cchallenges_allocs *cgoAllocMap
	ref1a0802cf.challenges, cchallenges_allocs = x.Challenges.PassValue()
	allocs1a0802cf.Borrow(cchallenges_allocs)

	var cchallenges_stride_allocs *cgoAllocMap
	ref1a0802cf.challenges_stride, cchallenges_stride_allocs = (C.size_t)(x.ChallengesStride), cgoAllocsUnknown
	allocs1a0802cf.Borrow(cchallenges_stride_allocs)

	x.ref1a0802cf = ref1a0802cf
	x.allocs1a0802cf = allocs1a0802cf
	return ref1a0802cf, allocs1a0802cf

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x GenerateFallbackSectorChallengesT) PassValue() (C.GenerateFallbackSectorChallenges_t, *cgoAllocMap) {
	if x.ref1a0802cf != nil {
		return *x.ref1a0802cf, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *GenerateFallbackSectorChallengesT) Deref() {
	if x.ref1a0802cf == nil {
		return
	}
	x.Ids = *NewSliceBoxedUint64TRef(unsafe.Pointer(&x.ref1a0802cf.ids))
	x.Challenges = *NewSliceBoxedUint64TRef(unsafe.Pointer(&x.ref1a0802cf.challenges))
	x.ChallengesStride = (SizeT)(x.ref1a0802cf.challenges_stride)
}

// allocResultGenerateFallbackSectorChallengesTMemory allocates memory for type C.Result_GenerateFallbackSectorChallenges_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocResultGenerateFallbackSectorChallengesTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfResultGenerateFallbackSectorChallengesTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfResultGenerateFallbackSectorChallengesTValue = unsafe.Sizeof([1]C.Result_GenerateFallbackSectorChallenges_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ResultGenerateFallbackSectorChallengesT) Ref() *C.Result_GenerateFallbackSectorChallenges_t {
	if x == nil {
		return nil
	}
	return x.ref69d095cd
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ResultGenerateFallbackSectorChallengesT) Free() {
	if x != nil && x.allocs69d095cd != nil {
		x.allocs69d095cd.(*cgoAllocMap).Free()
		x.ref69d095cd = nil
	}
}

// NewResultGenerateFallbackSectorChallengesTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewResultGenerateFallbackSectorChallengesTRef(ref unsafe.Pointer) *ResultGenerateFallbackSectorChallengesT {
	if ref == nil {
		return nil
	}
	obj := new(ResultGenerateFallbackSectorChallengesT)
	obj.ref69d095cd = (*C.Result_GenerateFallbackSectorChallenges_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ResultGenerateFallbackSectorChallengesT) PassRef() (*C.Result_GenerateFallbackSectorChallenges_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref69d095cd != nil {
		return x.ref69d095cd, nil
	}
	mem69d095cd := allocResultGenerateFallbackSectorChallengesTMemory(1)
	ref69d095cd := (*C.Result_GenerateFallbackSectorChallenges_t)(mem69d095cd)
	allocs69d095cd := new(cgoAllocMap)
	allocs69d095cd.Add(mem69d095cd)

	var cstatus_code_allocs *cgoAllocMap
	ref69d095cd.status_code, cstatus_code_allocs = (C.FCPResponseStatus_t)(x.StatusCode), cgoAllocsUnknown
	allocs69d095cd.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref69d095cd.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocs69d095cd.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	ref69d095cd.value, cvalue_allocs = x.Value.PassValue()
	allocs69d095cd.Borrow(cvalue_allocs)

	x.ref69d095cd = ref69d095cd
	x.allocs69d095cd = allocs69d095cd
	return ref69d095cd, allocs69d095cd

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ResultGenerateFallbackSectorChallengesT) PassValue() (C.Result_GenerateFallbackSectorChallenges_t, *cgoAllocMap) {
	if x.ref69d095cd != nil {
		return *x.ref69d095cd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ResultGenerateFallbackSectorChallengesT) Deref() {
	if x.ref69d095cd == nil {
		return
	}
	x.StatusCode = (FCPResponseStatusT)(x.ref69d095cd.status_code)
	x.ErrorMsg = *NewSliceBoxedUint8TRef(unsafe.Pointer(&x.ref69d095cd.error_msg))
	x.Value = *NewGenerateFallbackSectorChallengesTRef(unsafe.Pointer(&x.ref69d095cd.value))
}

// allocPrivateReplicaInfoTMemory allocates memory for type C.PrivateReplicaInfo_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPrivateReplicaInfoTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPrivateReplicaInfoTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPrivateReplicaInfoTValue = unsafe.Sizeof([1]C.PrivateReplicaInfo_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PrivateReplicaInfoT) Ref() *C.PrivateReplicaInfo_t {
	if x == nil {
		return nil
	}
	return x.ref4fcd660f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PrivateReplicaInfoT) Free() {
	if x != nil && x.allocs4fcd660f != nil {
		x.allocs4fcd660f.(*cgoAllocMap).Free()
		x.ref4fcd660f = nil
	}
}

// NewPrivateReplicaInfoTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPrivateReplicaInfoTRef(ref unsafe.Pointer) *PrivateReplicaInfoT {
	if ref == nil {
		return nil
	}
	obj := new(PrivateReplicaInfoT)
	obj.ref4fcd660f = (*C.PrivateReplicaInfo_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PrivateReplicaInfoT) PassRef() (*C.PrivateReplicaInfo_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4fcd660f != nil {
		return x.ref4fcd660f, nil
	}
	mem4fcd660f := allocPrivateReplicaInfoTMemory(1)
	ref4fcd660f := (*C.PrivateReplicaInfo_t)(mem4fcd660f)
	allocs4fcd660f := new(cgoAllocMap)
	allocs4fcd660f.Add(mem4fcd660f)

	var cregistered_proof_allocs *cgoAllocMap
	ref4fcd660f.registered_proof, cregistered_proof_allocs = (C.RegisteredPoStProof_t)(x.RegisteredProof), cgoAllocsUnknown
	allocs4fcd660f.Borrow(cregistered_proof_allocs)

	var ccache_dir_path_allocs *cgoAllocMap
	ref4fcd660f.cache_dir_path, ccache_dir_path_allocs = x.CacheDirPath.PassValue()
	allocs4fcd660f.Borrow(ccache_dir_path_allocs)

	var ccomm_r_allocs *cgoAllocMap
	ref4fcd660f.comm_r, ccomm_r_allocs = x.CommR.PassValue()
	allocs4fcd660f.Borrow(ccomm_r_allocs)

	var creplica_path_allocs *cgoAllocMap
	ref4fcd660f.replica_path, creplica_path_allocs = x.ReplicaPath.PassValue()
	allocs4fcd660f.Borrow(creplica_path_allocs)

	var csector_id_allocs *cgoAllocMap
	ref4fcd660f.sector_id, csector_id_allocs = (C.uint64_t)(x.SectorId), cgoAllocsUnknown
	allocs4fcd660f.Borrow(csector_id_allocs)

	x.ref4fcd660f = ref4fcd660f
	x.allocs4fcd660f = allocs4fcd660f
	return ref4fcd660f, allocs4fcd660f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PrivateReplicaInfoT) PassValue() (C.PrivateReplicaInfo_t, *cgoAllocMap) {
	if x.ref4fcd660f != nil {
		return *x.ref4fcd660f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PrivateReplicaInfoT) Deref() {
	if x.ref4fcd660f == nil {
		return
	}
	x.RegisteredProof = (RegisteredPoStProofT)(x.ref4fcd660f.registered_proof)
	x.CacheDirPath = *NewSliceBoxedUint8TRef(unsafe.Pointer(&x.ref4fcd660f.cache_dir_path))
	x.CommR = *NewUint832ArrayTRef(unsafe.Pointer(&x.ref4fcd660f.comm_r))
	x.ReplicaPath = *NewSliceBoxedUint8TRef(unsafe.Pointer(&x.ref4fcd660f.replica_path))
	x.SectorId = (Uint64T)(x.ref4fcd660f.sector_id)
}

// allocSliceRefSliceBoxedUint8TMemory allocates memory for type C.slice_ref_slice_boxed_uint8_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSliceRefSliceBoxedUint8TMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSliceRefSliceBoxedUint8TValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSliceRefSliceBoxedUint8TValue = unsafe.Sizeof([1]C.slice_ref_slice_boxed_uint8_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SliceRefSliceBoxedUint8T) Ref() *C.slice_ref_slice_boxed_uint8_t {
	if x == nil {
		return nil
	}
	return x.ref198e5437
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SliceRefSliceBoxedUint8T) Free() {
	if x != nil && x.allocs198e5437 != nil {
		x.allocs198e5437.(*cgoAllocMap).Free()
		x.ref198e5437 = nil
	}
}

// NewSliceRefSliceBoxedUint8TRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSliceRefSliceBoxedUint8TRef(ref unsafe.Pointer) *SliceRefSliceBoxedUint8T {
	if ref == nil {
		return nil
	}
	obj := new(SliceRefSliceBoxedUint8T)
	obj.ref198e5437 = (*C.slice_ref_slice_boxed_uint8_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SliceRefSliceBoxedUint8T) PassRef() (*C.slice_ref_slice_boxed_uint8_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref198e5437 != nil {
		return x.ref198e5437, nil
	}
	mem198e5437 := allocSliceRefSliceBoxedUint8TMemory(1)
	ref198e5437 := (*C.slice_ref_slice_boxed_uint8_t)(mem198e5437)
	allocs198e5437 := new(cgoAllocMap)
	allocs198e5437.Add(mem198e5437)

	var cptr_allocs *cgoAllocMap
	ref198e5437.ptr, cptr_allocs = unpackSSliceBoxedUint8T(x.Ptr)
	allocs198e5437.Borrow(cptr_allocs)

	var clen_allocs *cgoAllocMap
	ref198e5437.len, clen_allocs = (C.size_t)(x.Len), cgoAllocsUnknown
	allocs198e5437.Borrow(clen_allocs)

	x.ref198e5437 = ref198e5437
	x.allocs198e5437 = allocs198e5437
	return ref198e5437, allocs198e5437

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SliceRefSliceBoxedUint8T) PassValue() (C.slice_ref_slice_boxed_uint8_t, *cgoAllocMap) {
	if x.ref198e5437 != nil {
		return *x.ref198e5437, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SliceRefSliceBoxedUint8T) Deref() {
	if x.ref198e5437 == nil {
		return
	}
	packSSliceBoxedUint8T(x.Ptr, x.ref198e5437.ptr)
	x.Len = (SizeT)(x.ref198e5437.len)
}

// allocPoStProofTMemory allocates memory for type C.PoStProof_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPoStProofTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPoStProofTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPoStProofTValue = unsafe.Sizeof([1]C.PoStProof_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PoStProofT) Ref() *C.PoStProof_t {
	if x == nil {
		return nil
	}
	return x.ref6b19d074
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PoStProofT) Free() {
	if x != nil && x.allocs6b19d074 != nil {
		x.allocs6b19d074.(*cgoAllocMap).Free()
		x.ref6b19d074 = nil
	}
}

// NewPoStProofTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPoStProofTRef(ref unsafe.Pointer) *PoStProofT {
	if ref == nil {
		return nil
	}
	obj := new(PoStProofT)
	obj.ref6b19d074 = (*C.PoStProof_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PoStProofT) PassRef() (*C.PoStProof_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6b19d074 != nil {
		return x.ref6b19d074, nil
	}
	mem6b19d074 := allocPoStProofTMemory(1)
	ref6b19d074 := (*C.PoStProof_t)(mem6b19d074)
	allocs6b19d074 := new(cgoAllocMap)
	allocs6b19d074.Add(mem6b19d074)

	var cregistered_proof_allocs *cgoAllocMap
	ref6b19d074.registered_proof, cregistered_proof_allocs = (C.RegisteredPoStProof_t)(x.RegisteredProof), cgoAllocsUnknown
	allocs6b19d074.Borrow(cregistered_proof_allocs)

	var cproof_allocs *cgoAllocMap
	ref6b19d074.proof, cproof_allocs = x.Proof.PassValue()
	allocs6b19d074.Borrow(cproof_allocs)

	x.ref6b19d074 = ref6b19d074
	x.allocs6b19d074 = allocs6b19d074
	return ref6b19d074, allocs6b19d074

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PoStProofT) PassValue() (C.PoStProof_t, *cgoAllocMap) {
	if x.ref6b19d074 != nil {
		return *x.ref6b19d074, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PoStProofT) Deref() {
	if x.ref6b19d074 == nil {
		return
	}
	x.RegisteredProof = (RegisteredPoStProofT)(x.ref6b19d074.registered_proof)
	x.Proof = *NewSliceBoxedUint8TRef(unsafe.Pointer(&x.ref6b19d074.proof))
}

// allocSliceBoxedPoStProofTMemory allocates memory for type C.slice_boxed_PoStProof_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSliceBoxedPoStProofTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSliceBoxedPoStProofTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSliceBoxedPoStProofTValue = unsafe.Sizeof([1]C.slice_boxed_PoStProof_t{})

// unpackSPoStProofT transforms a sliced Go data structure into plain C format.
func unpackSPoStProofT(x []PoStProofT) (unpacked *C.PoStProof_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPoStProofTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.PoStProof_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.PoStProof_t)(h.Data)
	return
}

// packSPoStProofT reads sliced Go data structure out from plain C format.
func packSPoStProofT(v []PoStProofT, ptr0 *C.PoStProof_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPoStProofTValue]C.PoStProof_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPoStProofTRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SliceBoxedPoStProofT) Ref() *C.slice_boxed_PoStProof_t {
	if x == nil {
		return nil
	}
	return x.ref9a32842f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SliceBoxedPoStProofT) Free() {
	if x != nil && x.allocs9a32842f != nil {
		x.allocs9a32842f.(*cgoAllocMap).Free()
		x.ref9a32842f = nil
	}
}

// NewSliceBoxedPoStProofTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSliceBoxedPoStProofTRef(ref unsafe.Pointer) *SliceBoxedPoStProofT {
	if ref == nil {
		return nil
	}
	obj := new(SliceBoxedPoStProofT)
	obj.ref9a32842f = (*C.slice_boxed_PoStProof_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SliceBoxedPoStProofT) PassRef() (*C.slice_boxed_PoStProof_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9a32842f != nil {
		return x.ref9a32842f, nil
	}
	mem9a32842f := allocSliceBoxedPoStProofTMemory(1)
	ref9a32842f := (*C.slice_boxed_PoStProof_t)(mem9a32842f)
	allocs9a32842f := new(cgoAllocMap)
	allocs9a32842f.Add(mem9a32842f)

	var cptr_allocs *cgoAllocMap
	ref9a32842f.ptr, cptr_allocs = unpackSPoStProofT(x.Ptr)
	allocs9a32842f.Borrow(cptr_allocs)

	var clen_allocs *cgoAllocMap
	ref9a32842f.len, clen_allocs = (C.size_t)(x.Len), cgoAllocsUnknown
	allocs9a32842f.Borrow(clen_allocs)

	x.ref9a32842f = ref9a32842f
	x.allocs9a32842f = allocs9a32842f
	return ref9a32842f, allocs9a32842f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SliceBoxedPoStProofT) PassValue() (C.slice_boxed_PoStProof_t, *cgoAllocMap) {
	if x.ref9a32842f != nil {
		return *x.ref9a32842f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SliceBoxedPoStProofT) Deref() {
	if x.ref9a32842f == nil {
		return
	}
	packSPoStProofT(x.Ptr, x.ref9a32842f.ptr)
	x.Len = (SizeT)(x.ref9a32842f.len)
}

// allocResultSliceBoxedPoStProofTMemory allocates memory for type C.Result_slice_boxed_PoStProof_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocResultSliceBoxedPoStProofTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfResultSliceBoxedPoStProofTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfResultSliceBoxedPoStProofTValue = unsafe.Sizeof([1]C.Result_slice_boxed_PoStProof_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ResultSliceBoxedPoStProofT) Ref() *C.Result_slice_boxed_PoStProof_t {
	if x == nil {
		return nil
	}
	return x.ref47494514
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ResultSliceBoxedPoStProofT) Free() {
	if x != nil && x.allocs47494514 != nil {
		x.allocs47494514.(*cgoAllocMap).Free()
		x.ref47494514 = nil
	}
}

// NewResultSliceBoxedPoStProofTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewResultSliceBoxedPoStProofTRef(ref unsafe.Pointer) *ResultSliceBoxedPoStProofT {
	if ref == nil {
		return nil
	}
	obj := new(ResultSliceBoxedPoStProofT)
	obj.ref47494514 = (*C.Result_slice_boxed_PoStProof_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ResultSliceBoxedPoStProofT) PassRef() (*C.Result_slice_boxed_PoStProof_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref47494514 != nil {
		return x.ref47494514, nil
	}
	mem47494514 := allocResultSliceBoxedPoStProofTMemory(1)
	ref47494514 := (*C.Result_slice_boxed_PoStProof_t)(mem47494514)
	allocs47494514 := new(cgoAllocMap)
	allocs47494514.Add(mem47494514)

	var cstatus_code_allocs *cgoAllocMap
	ref47494514.status_code, cstatus_code_allocs = (C.FCPResponseStatus_t)(x.StatusCode), cgoAllocsUnknown
	allocs47494514.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref47494514.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocs47494514.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	ref47494514.value, cvalue_allocs = x.Value.PassValue()
	allocs47494514.Borrow(cvalue_allocs)

	x.ref47494514 = ref47494514
	x.allocs47494514 = allocs47494514
	return ref47494514, allocs47494514

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ResultSliceBoxedPoStProofT) PassValue() (C.Result_slice_boxed_PoStProof_t, *cgoAllocMap) {
	if x.ref47494514 != nil {
		return *x.ref47494514, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ResultSliceBoxedPoStProofT) Deref() {
	if x.ref47494514 == nil {
		return
	}
	x.StatusCode = (FCPResponseStatusT)(x.ref47494514.status_code)
	x.ErrorMsg = *NewSliceBoxedUint8TRef(unsafe.Pointer(&x.ref47494514.error_msg))
	x.Value = *NewSliceBoxedPoStProofTRef(unsafe.Pointer(&x.ref47494514.value))
}

// allocSliceRefPrivateReplicaInfoTMemory allocates memory for type C.slice_ref_PrivateReplicaInfo_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSliceRefPrivateReplicaInfoTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSliceRefPrivateReplicaInfoTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSliceRefPrivateReplicaInfoTValue = unsafe.Sizeof([1]C.slice_ref_PrivateReplicaInfo_t{})

// unpackSPrivateReplicaInfoT transforms a sliced Go data structure into plain C format.
func unpackSPrivateReplicaInfoT(x []PrivateReplicaInfoT) (unpacked *C.PrivateReplicaInfo_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPrivateReplicaInfoTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.PrivateReplicaInfo_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.PrivateReplicaInfo_t)(h.Data)
	return
}

// packSPrivateReplicaInfoT reads sliced Go data structure out from plain C format.
func packSPrivateReplicaInfoT(v []PrivateReplicaInfoT, ptr0 *C.PrivateReplicaInfo_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPrivateReplicaInfoTValue]C.PrivateReplicaInfo_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPrivateReplicaInfoTRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SliceRefPrivateReplicaInfoT) Ref() *C.slice_ref_PrivateReplicaInfo_t {
	if x == nil {
		return nil
	}
	return x.ref88221610
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SliceRefPrivateReplicaInfoT) Free() {
	if x != nil && x.allocs88221610 != nil {
		x.allocs88221610.(*cgoAllocMap).Free()
		x.ref88221610 = nil
	}
}

// NewSliceRefPrivateReplicaInfoTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSliceRefPrivateReplicaInfoTRef(ref unsafe.Pointer) *SliceRefPrivateReplicaInfoT {
	if ref == nil {
		return nil
	}
	obj := new(SliceRefPrivateReplicaInfoT)
	obj.ref88221610 = (*C.slice_ref_PrivateReplicaInfo_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SliceRefPrivateReplicaInfoT) PassRef() (*C.slice_ref_PrivateReplicaInfo_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref88221610 != nil {
		return x.ref88221610, nil
	}
	mem88221610 := allocSliceRefPrivateReplicaInfoTMemory(1)
	ref88221610 := (*C.slice_ref_PrivateReplicaInfo_t)(mem88221610)
	allocs88221610 := new(cgoAllocMap)
	allocs88221610.Add(mem88221610)

	var cptr_allocs *cgoAllocMap
	ref88221610.ptr, cptr_allocs = unpackSPrivateReplicaInfoT(x.Ptr)
	allocs88221610.Borrow(cptr_allocs)

	var clen_allocs *cgoAllocMap
	ref88221610.len, clen_allocs = (C.size_t)(x.Len), cgoAllocsUnknown
	allocs88221610.Borrow(clen_allocs)

	x.ref88221610 = ref88221610
	x.allocs88221610 = allocs88221610
	return ref88221610, allocs88221610

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SliceRefPrivateReplicaInfoT) PassValue() (C.slice_ref_PrivateReplicaInfo_t, *cgoAllocMap) {
	if x.ref88221610 != nil {
		return *x.ref88221610, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SliceRefPrivateReplicaInfoT) Deref() {
	if x.ref88221610 == nil {
		return
	}
	packSPrivateReplicaInfoT(x.Ptr, x.ref88221610.ptr)
	x.Len = (SizeT)(x.ref88221610.len)
}

// allocPublicReplicaInfoTMemory allocates memory for type C.PublicReplicaInfo_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPublicReplicaInfoTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPublicReplicaInfoTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPublicReplicaInfoTValue = unsafe.Sizeof([1]C.PublicReplicaInfo_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PublicReplicaInfoT) Ref() *C.PublicReplicaInfo_t {
	if x == nil {
		return nil
	}
	return x.ref2f93037
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PublicReplicaInfoT) Free() {
	if x != nil && x.allocs2f93037 != nil {
		x.allocs2f93037.(*cgoAllocMap).Free()
		x.ref2f93037 = nil
	}
}

// NewPublicReplicaInfoTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPublicReplicaInfoTRef(ref unsafe.Pointer) *PublicReplicaInfoT {
	if ref == nil {
		return nil
	}
	obj := new(PublicReplicaInfoT)
	obj.ref2f93037 = (*C.PublicReplicaInfo_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PublicReplicaInfoT) PassRef() (*C.PublicReplicaInfo_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2f93037 != nil {
		return x.ref2f93037, nil
	}
	mem2f93037 := allocPublicReplicaInfoTMemory(1)
	ref2f93037 := (*C.PublicReplicaInfo_t)(mem2f93037)
	allocs2f93037 := new(cgoAllocMap)
	allocs2f93037.Add(mem2f93037)

	var cregistered_proof_allocs *cgoAllocMap
	ref2f93037.registered_proof, cregistered_proof_allocs = (C.RegisteredPoStProof_t)(x.RegisteredProof), cgoAllocsUnknown
	allocs2f93037.Borrow(cregistered_proof_allocs)

	var ccomm_r_allocs *cgoAllocMap
	ref2f93037.comm_r, ccomm_r_allocs = x.CommR.PassValue()
	allocs2f93037.Borrow(ccomm_r_allocs)

	var csector_id_allocs *cgoAllocMap
	ref2f93037.sector_id, csector_id_allocs = (C.uint64_t)(x.SectorId), cgoAllocsUnknown
	allocs2f93037.Borrow(csector_id_allocs)

	x.ref2f93037 = ref2f93037
	x.allocs2f93037 = allocs2f93037
	return ref2f93037, allocs2f93037

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PublicReplicaInfoT) PassValue() (C.PublicReplicaInfo_t, *cgoAllocMap) {
	if x.ref2f93037 != nil {
		return *x.ref2f93037, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PublicReplicaInfoT) Deref() {
	if x.ref2f93037 == nil {
		return
	}
	x.RegisteredProof = (RegisteredPoStProofT)(x.ref2f93037.registered_proof)
	x.CommR = *NewUint832ArrayTRef(unsafe.Pointer(&x.ref2f93037.comm_r))
	x.SectorId = (Uint64T)(x.ref2f93037.sector_id)
}

// allocSliceRefPublicReplicaInfoTMemory allocates memory for type C.slice_ref_PublicReplicaInfo_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSliceRefPublicReplicaInfoTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSliceRefPublicReplicaInfoTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSliceRefPublicReplicaInfoTValue = unsafe.Sizeof([1]C.slice_ref_PublicReplicaInfo_t{})

// unpackSPublicReplicaInfoT transforms a sliced Go data structure into plain C format.
func unpackSPublicReplicaInfoT(x []PublicReplicaInfoT) (unpacked *C.PublicReplicaInfo_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPublicReplicaInfoTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.PublicReplicaInfo_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.PublicReplicaInfo_t)(h.Data)
	return
}

// packSPublicReplicaInfoT reads sliced Go data structure out from plain C format.
func packSPublicReplicaInfoT(v []PublicReplicaInfoT, ptr0 *C.PublicReplicaInfo_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPublicReplicaInfoTValue]C.PublicReplicaInfo_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPublicReplicaInfoTRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SliceRefPublicReplicaInfoT) Ref() *C.slice_ref_PublicReplicaInfo_t {
	if x == nil {
		return nil
	}
	return x.ref3a219b4c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SliceRefPublicReplicaInfoT) Free() {
	if x != nil && x.allocs3a219b4c != nil {
		x.allocs3a219b4c.(*cgoAllocMap).Free()
		x.ref3a219b4c = nil
	}
}

// NewSliceRefPublicReplicaInfoTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSliceRefPublicReplicaInfoTRef(ref unsafe.Pointer) *SliceRefPublicReplicaInfoT {
	if ref == nil {
		return nil
	}
	obj := new(SliceRefPublicReplicaInfoT)
	obj.ref3a219b4c = (*C.slice_ref_PublicReplicaInfo_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SliceRefPublicReplicaInfoT) PassRef() (*C.slice_ref_PublicReplicaInfo_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3a219b4c != nil {
		return x.ref3a219b4c, nil
	}
	mem3a219b4c := allocSliceRefPublicReplicaInfoTMemory(1)
	ref3a219b4c := (*C.slice_ref_PublicReplicaInfo_t)(mem3a219b4c)
	allocs3a219b4c := new(cgoAllocMap)
	allocs3a219b4c.Add(mem3a219b4c)

	var cptr_allocs *cgoAllocMap
	ref3a219b4c.ptr, cptr_allocs = unpackSPublicReplicaInfoT(x.Ptr)
	allocs3a219b4c.Borrow(cptr_allocs)

	var clen_allocs *cgoAllocMap
	ref3a219b4c.len, clen_allocs = (C.size_t)(x.Len), cgoAllocsUnknown
	allocs3a219b4c.Borrow(clen_allocs)

	x.ref3a219b4c = ref3a219b4c
	x.allocs3a219b4c = allocs3a219b4c
	return ref3a219b4c, allocs3a219b4c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SliceRefPublicReplicaInfoT) PassValue() (C.slice_ref_PublicReplicaInfo_t, *cgoAllocMap) {
	if x.ref3a219b4c != nil {
		return *x.ref3a219b4c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SliceRefPublicReplicaInfoT) Deref() {
	if x.ref3a219b4c == nil {
		return
	}
	packSPublicReplicaInfoT(x.Ptr, x.ref3a219b4c.ptr)
	x.Len = (SizeT)(x.ref3a219b4c.len)
}

// allocSliceRefPoStProofTMemory allocates memory for type C.slice_ref_PoStProof_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSliceRefPoStProofTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSliceRefPoStProofTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSliceRefPoStProofTValue = unsafe.Sizeof([1]C.slice_ref_PoStProof_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SliceRefPoStProofT) Ref() *C.slice_ref_PoStProof_t {
	if x == nil {
		return nil
	}
	return x.refd15cdd4b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SliceRefPoStProofT) Free() {
	if x != nil && x.allocsd15cdd4b != nil {
		x.allocsd15cdd4b.(*cgoAllocMap).Free()
		x.refd15cdd4b = nil
	}
}

// NewSliceRefPoStProofTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSliceRefPoStProofTRef(ref unsafe.Pointer) *SliceRefPoStProofT {
	if ref == nil {
		return nil
	}
	obj := new(SliceRefPoStProofT)
	obj.refd15cdd4b = (*C.slice_ref_PoStProof_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SliceRefPoStProofT) PassRef() (*C.slice_ref_PoStProof_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd15cdd4b != nil {
		return x.refd15cdd4b, nil
	}
	memd15cdd4b := allocSliceRefPoStProofTMemory(1)
	refd15cdd4b := (*C.slice_ref_PoStProof_t)(memd15cdd4b)
	allocsd15cdd4b := new(cgoAllocMap)
	allocsd15cdd4b.Add(memd15cdd4b)

	var cptr_allocs *cgoAllocMap
	refd15cdd4b.ptr, cptr_allocs = unpackSPoStProofT(x.Ptr)
	allocsd15cdd4b.Borrow(cptr_allocs)

	var clen_allocs *cgoAllocMap
	refd15cdd4b.len, clen_allocs = (C.size_t)(x.Len), cgoAllocsUnknown
	allocsd15cdd4b.Borrow(clen_allocs)

	x.refd15cdd4b = refd15cdd4b
	x.allocsd15cdd4b = allocsd15cdd4b
	return refd15cdd4b, allocsd15cdd4b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SliceRefPoStProofT) PassValue() (C.slice_ref_PoStProof_t, *cgoAllocMap) {
	if x.refd15cdd4b != nil {
		return *x.refd15cdd4b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SliceRefPoStProofT) Deref() {
	if x.refd15cdd4b == nil {
		return
	}
	packSPoStProofT(x.Ptr, x.refd15cdd4b.ptr)
	x.Len = (SizeT)(x.refd15cdd4b.len)
}

// allocGenerateWindowPoStTMemory allocates memory for type C.GenerateWindowPoSt_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocGenerateWindowPoStTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfGenerateWindowPoStTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfGenerateWindowPoStTValue = unsafe.Sizeof([1]C.GenerateWindowPoSt_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *GenerateWindowPoStT) Ref() *C.GenerateWindowPoSt_t {
	if x == nil {
		return nil
	}
	return x.refcee66945
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *GenerateWindowPoStT) Free() {
	if x != nil && x.allocscee66945 != nil {
		x.allocscee66945.(*cgoAllocMap).Free()
		x.refcee66945 = nil
	}
}

// NewGenerateWindowPoStTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewGenerateWindowPoStTRef(ref unsafe.Pointer) *GenerateWindowPoStT {
	if ref == nil {
		return nil
	}
	obj := new(GenerateWindowPoStT)
	obj.refcee66945 = (*C.GenerateWindowPoSt_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *GenerateWindowPoStT) PassRef() (*C.GenerateWindowPoSt_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refcee66945 != nil {
		return x.refcee66945, nil
	}
	memcee66945 := allocGenerateWindowPoStTMemory(1)
	refcee66945 := (*C.GenerateWindowPoSt_t)(memcee66945)
	allocscee66945 := new(cgoAllocMap)
	allocscee66945.Add(memcee66945)

	var cproofs_allocs *cgoAllocMap
	refcee66945.proofs, cproofs_allocs = x.Proofs.PassValue()
	allocscee66945.Borrow(cproofs_allocs)

	var cfaulty_sectors_allocs *cgoAllocMap
	refcee66945.faulty_sectors, cfaulty_sectors_allocs = x.FaultySectors.PassValue()
	allocscee66945.Borrow(cfaulty_sectors_allocs)

	x.refcee66945 = refcee66945
	x.allocscee66945 = allocscee66945
	return refcee66945, allocscee66945

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x GenerateWindowPoStT) PassValue() (C.GenerateWindowPoSt_t, *cgoAllocMap) {
	if x.refcee66945 != nil {
		return *x.refcee66945, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *GenerateWindowPoStT) Deref() {
	if x.refcee66945 == nil {
		return
	}
	x.Proofs = *NewSliceBoxedPoStProofTRef(unsafe.Pointer(&x.refcee66945.proofs))
	x.FaultySectors = *NewSliceBoxedUint64TRef(unsafe.Pointer(&x.refcee66945.faulty_sectors))
}

// allocResultGenerateWindowPoStTMemory allocates memory for type C.Result_GenerateWindowPoSt_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocResultGenerateWindowPoStTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfResultGenerateWindowPoStTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfResultGenerateWindowPoStTValue = unsafe.Sizeof([1]C.Result_GenerateWindowPoSt_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ResultGenerateWindowPoStT) Ref() *C.Result_GenerateWindowPoSt_t {
	if x == nil {
		return nil
	}
	return x.ref16e6fa9b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ResultGenerateWindowPoStT) Free() {
	if x != nil && x.allocs16e6fa9b != nil {
		x.allocs16e6fa9b.(*cgoAllocMap).Free()
		x.ref16e6fa9b = nil
	}
}

// NewResultGenerateWindowPoStTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewResultGenerateWindowPoStTRef(ref unsafe.Pointer) *ResultGenerateWindowPoStT {
	if ref == nil {
		return nil
	}
	obj := new(ResultGenerateWindowPoStT)
	obj.ref16e6fa9b = (*C.Result_GenerateWindowPoSt_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ResultGenerateWindowPoStT) PassRef() (*C.Result_GenerateWindowPoSt_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref16e6fa9b != nil {
		return x.ref16e6fa9b, nil
	}
	mem16e6fa9b := allocResultGenerateWindowPoStTMemory(1)
	ref16e6fa9b := (*C.Result_GenerateWindowPoSt_t)(mem16e6fa9b)
	allocs16e6fa9b := new(cgoAllocMap)
	allocs16e6fa9b.Add(mem16e6fa9b)

	var cstatus_code_allocs *cgoAllocMap
	ref16e6fa9b.status_code, cstatus_code_allocs = (C.FCPResponseStatus_t)(x.StatusCode), cgoAllocsUnknown
	allocs16e6fa9b.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref16e6fa9b.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocs16e6fa9b.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	ref16e6fa9b.value, cvalue_allocs = x.Value.PassValue()
	allocs16e6fa9b.Borrow(cvalue_allocs)

	x.ref16e6fa9b = ref16e6fa9b
	x.allocs16e6fa9b = allocs16e6fa9b
	return ref16e6fa9b, allocs16e6fa9b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ResultGenerateWindowPoStT) PassValue() (C.Result_GenerateWindowPoSt_t, *cgoAllocMap) {
	if x.ref16e6fa9b != nil {
		return *x.ref16e6fa9b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ResultGenerateWindowPoStT) Deref() {
	if x.ref16e6fa9b == nil {
		return
	}
	x.StatusCode = (FCPResponseStatusT)(x.ref16e6fa9b.status_code)
	x.ErrorMsg = *NewSliceBoxedUint8TRef(unsafe.Pointer(&x.ref16e6fa9b.error_msg))
	x.Value = *NewGenerateWindowPoStTRef(unsafe.Pointer(&x.ref16e6fa9b.value))
}

// allocPartitionSnarkProofTMemory allocates memory for type C.PartitionSnarkProof_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPartitionSnarkProofTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPartitionSnarkProofTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPartitionSnarkProofTValue = unsafe.Sizeof([1]C.PartitionSnarkProof_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PartitionSnarkProofT) Ref() *C.PartitionSnarkProof_t {
	if x == nil {
		return nil
	}
	return x.ref66732a1e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PartitionSnarkProofT) Free() {
	if x != nil && x.allocs66732a1e != nil {
		x.allocs66732a1e.(*cgoAllocMap).Free()
		x.ref66732a1e = nil
	}
}

// NewPartitionSnarkProofTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPartitionSnarkProofTRef(ref unsafe.Pointer) *PartitionSnarkProofT {
	if ref == nil {
		return nil
	}
	obj := new(PartitionSnarkProofT)
	obj.ref66732a1e = (*C.PartitionSnarkProof_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PartitionSnarkProofT) PassRef() (*C.PartitionSnarkProof_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref66732a1e != nil {
		return x.ref66732a1e, nil
	}
	mem66732a1e := allocPartitionSnarkProofTMemory(1)
	ref66732a1e := (*C.PartitionSnarkProof_t)(mem66732a1e)
	allocs66732a1e := new(cgoAllocMap)
	allocs66732a1e.Add(mem66732a1e)

	var cregistered_proof_allocs *cgoAllocMap
	ref66732a1e.registered_proof, cregistered_proof_allocs = (C.RegisteredPoStProof_t)(x.RegisteredProof), cgoAllocsUnknown
	allocs66732a1e.Borrow(cregistered_proof_allocs)

	var cproof_allocs *cgoAllocMap
	ref66732a1e.proof, cproof_allocs = x.Proof.PassValue()
	allocs66732a1e.Borrow(cproof_allocs)

	x.ref66732a1e = ref66732a1e
	x.allocs66732a1e = allocs66732a1e
	return ref66732a1e, allocs66732a1e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PartitionSnarkProofT) PassValue() (C.PartitionSnarkProof_t, *cgoAllocMap) {
	if x.ref66732a1e != nil {
		return *x.ref66732a1e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PartitionSnarkProofT) Deref() {
	if x.ref66732a1e == nil {
		return
	}
	x.RegisteredProof = (RegisteredPoStProofT)(x.ref66732a1e.registered_proof)
	x.Proof = *NewSliceBoxedUint8TRef(unsafe.Pointer(&x.ref66732a1e.proof))
}

// allocSliceRefPartitionSnarkProofTMemory allocates memory for type C.slice_ref_PartitionSnarkProof_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSliceRefPartitionSnarkProofTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSliceRefPartitionSnarkProofTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSliceRefPartitionSnarkProofTValue = unsafe.Sizeof([1]C.slice_ref_PartitionSnarkProof_t{})

// unpackSPartitionSnarkProofT transforms a sliced Go data structure into plain C format.
func unpackSPartitionSnarkProofT(x []PartitionSnarkProofT) (unpacked *C.PartitionSnarkProof_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPartitionSnarkProofTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.PartitionSnarkProof_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.PartitionSnarkProof_t)(h.Data)
	return
}

// packSPartitionSnarkProofT reads sliced Go data structure out from plain C format.
func packSPartitionSnarkProofT(v []PartitionSnarkProofT, ptr0 *C.PartitionSnarkProof_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPartitionSnarkProofTValue]C.PartitionSnarkProof_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPartitionSnarkProofTRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SliceRefPartitionSnarkProofT) Ref() *C.slice_ref_PartitionSnarkProof_t {
	if x == nil {
		return nil
	}
	return x.refebbcc89b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SliceRefPartitionSnarkProofT) Free() {
	if x != nil && x.allocsebbcc89b != nil {
		x.allocsebbcc89b.(*cgoAllocMap).Free()
		x.refebbcc89b = nil
	}
}

// NewSliceRefPartitionSnarkProofTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSliceRefPartitionSnarkProofTRef(ref unsafe.Pointer) *SliceRefPartitionSnarkProofT {
	if ref == nil {
		return nil
	}
	obj := new(SliceRefPartitionSnarkProofT)
	obj.refebbcc89b = (*C.slice_ref_PartitionSnarkProof_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SliceRefPartitionSnarkProofT) PassRef() (*C.slice_ref_PartitionSnarkProof_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refebbcc89b != nil {
		return x.refebbcc89b, nil
	}
	memebbcc89b := allocSliceRefPartitionSnarkProofTMemory(1)
	refebbcc89b := (*C.slice_ref_PartitionSnarkProof_t)(memebbcc89b)
	allocsebbcc89b := new(cgoAllocMap)
	allocsebbcc89b.Add(memebbcc89b)

	var cptr_allocs *cgoAllocMap
	refebbcc89b.ptr, cptr_allocs = unpackSPartitionSnarkProofT(x.Ptr)
	allocsebbcc89b.Borrow(cptr_allocs)

	var clen_allocs *cgoAllocMap
	refebbcc89b.len, clen_allocs = (C.size_t)(x.Len), cgoAllocsUnknown
	allocsebbcc89b.Borrow(clen_allocs)

	x.refebbcc89b = refebbcc89b
	x.allocsebbcc89b = allocsebbcc89b
	return refebbcc89b, allocsebbcc89b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SliceRefPartitionSnarkProofT) PassValue() (C.slice_ref_PartitionSnarkProof_t, *cgoAllocMap) {
	if x.refebbcc89b != nil {
		return *x.refebbcc89b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SliceRefPartitionSnarkProofT) Deref() {
	if x.refebbcc89b == nil {
		return
	}
	packSPartitionSnarkProofT(x.Ptr, x.refebbcc89b.ptr)
	x.Len = (SizeT)(x.refebbcc89b.len)
}

// allocResultPoStProofTMemory allocates memory for type C.Result_PoStProof_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocResultPoStProofTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfResultPoStProofTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfResultPoStProofTValue = unsafe.Sizeof([1]C.Result_PoStProof_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ResultPoStProofT) Ref() *C.Result_PoStProof_t {
	if x == nil {
		return nil
	}
	return x.ref20cbfc0b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ResultPoStProofT) Free() {
	if x != nil && x.allocs20cbfc0b != nil {
		x.allocs20cbfc0b.(*cgoAllocMap).Free()
		x.ref20cbfc0b = nil
	}
}

// NewResultPoStProofTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewResultPoStProofTRef(ref unsafe.Pointer) *ResultPoStProofT {
	if ref == nil {
		return nil
	}
	obj := new(ResultPoStProofT)
	obj.ref20cbfc0b = (*C.Result_PoStProof_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ResultPoStProofT) PassRef() (*C.Result_PoStProof_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref20cbfc0b != nil {
		return x.ref20cbfc0b, nil
	}
	mem20cbfc0b := allocResultPoStProofTMemory(1)
	ref20cbfc0b := (*C.Result_PoStProof_t)(mem20cbfc0b)
	allocs20cbfc0b := new(cgoAllocMap)
	allocs20cbfc0b.Add(mem20cbfc0b)

	var cstatus_code_allocs *cgoAllocMap
	ref20cbfc0b.status_code, cstatus_code_allocs = (C.FCPResponseStatus_t)(x.StatusCode), cgoAllocsUnknown
	allocs20cbfc0b.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref20cbfc0b.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocs20cbfc0b.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	ref20cbfc0b.value, cvalue_allocs = x.Value.PassValue()
	allocs20cbfc0b.Borrow(cvalue_allocs)

	x.ref20cbfc0b = ref20cbfc0b
	x.allocs20cbfc0b = allocs20cbfc0b
	return ref20cbfc0b, allocs20cbfc0b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ResultPoStProofT) PassValue() (C.Result_PoStProof_t, *cgoAllocMap) {
	if x.ref20cbfc0b != nil {
		return *x.ref20cbfc0b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ResultPoStProofT) Deref() {
	if x.ref20cbfc0b == nil {
		return
	}
	x.StatusCode = (FCPResponseStatusT)(x.ref20cbfc0b.status_code)
	x.ErrorMsg = *NewSliceBoxedUint8TRef(unsafe.Pointer(&x.ref20cbfc0b.error_msg))
	x.Value = *NewPoStProofTRef(unsafe.Pointer(&x.ref20cbfc0b.value))
}

// allocResultSizeTMemory allocates memory for type C.Result_size_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocResultSizeTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfResultSizeTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfResultSizeTValue = unsafe.Sizeof([1]C.Result_size_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ResultSizeT) Ref() *C.Result_size_t {
	if x == nil {
		return nil
	}
	return x.refdf6206d4
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ResultSizeT) Free() {
	if x != nil && x.allocsdf6206d4 != nil {
		x.allocsdf6206d4.(*cgoAllocMap).Free()
		x.refdf6206d4 = nil
	}
}

// NewResultSizeTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewResultSizeTRef(ref unsafe.Pointer) *ResultSizeT {
	if ref == nil {
		return nil
	}
	obj := new(ResultSizeT)
	obj.refdf6206d4 = (*C.Result_size_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ResultSizeT) PassRef() (*C.Result_size_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refdf6206d4 != nil {
		return x.refdf6206d4, nil
	}
	memdf6206d4 := allocResultSizeTMemory(1)
	refdf6206d4 := (*C.Result_size_t)(memdf6206d4)
	allocsdf6206d4 := new(cgoAllocMap)
	allocsdf6206d4.Add(memdf6206d4)

	var cstatus_code_allocs *cgoAllocMap
	refdf6206d4.status_code, cstatus_code_allocs = (C.FCPResponseStatus_t)(x.StatusCode), cgoAllocsUnknown
	allocsdf6206d4.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	refdf6206d4.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocsdf6206d4.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	refdf6206d4.value, cvalue_allocs = (C.size_t)(x.Value), cgoAllocsUnknown
	allocsdf6206d4.Borrow(cvalue_allocs)

	x.refdf6206d4 = refdf6206d4
	x.allocsdf6206d4 = allocsdf6206d4
	return refdf6206d4, allocsdf6206d4

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ResultSizeT) PassValue() (C.Result_size_t, *cgoAllocMap) {
	if x.refdf6206d4 != nil {
		return *x.refdf6206d4, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ResultSizeT) Deref() {
	if x.refdf6206d4 == nil {
		return
	}
	x.StatusCode = (FCPResponseStatusT)(x.refdf6206d4.status_code)
	x.ErrorMsg = *NewSliceBoxedUint8TRef(unsafe.Pointer(&x.refdf6206d4.error_msg))
	x.Value = (SizeT)(x.refdf6206d4.value)
}

// allocGenerateSingleWindowPoStWithVanillaTMemory allocates memory for type C.GenerateSingleWindowPoStWithVanilla_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocGenerateSingleWindowPoStWithVanillaTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfGenerateSingleWindowPoStWithVanillaTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfGenerateSingleWindowPoStWithVanillaTValue = unsafe.Sizeof([1]C.GenerateSingleWindowPoStWithVanilla_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *GenerateSingleWindowPoStWithVanillaT) Ref() *C.GenerateSingleWindowPoStWithVanilla_t {
	if x == nil {
		return nil
	}
	return x.refe1ddcd34
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *GenerateSingleWindowPoStWithVanillaT) Free() {
	if x != nil && x.allocse1ddcd34 != nil {
		x.allocse1ddcd34.(*cgoAllocMap).Free()
		x.refe1ddcd34 = nil
	}
}

// NewGenerateSingleWindowPoStWithVanillaTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewGenerateSingleWindowPoStWithVanillaTRef(ref unsafe.Pointer) *GenerateSingleWindowPoStWithVanillaT {
	if ref == nil {
		return nil
	}
	obj := new(GenerateSingleWindowPoStWithVanillaT)
	obj.refe1ddcd34 = (*C.GenerateSingleWindowPoStWithVanilla_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *GenerateSingleWindowPoStWithVanillaT) PassRef() (*C.GenerateSingleWindowPoStWithVanilla_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe1ddcd34 != nil {
		return x.refe1ddcd34, nil
	}
	meme1ddcd34 := allocGenerateSingleWindowPoStWithVanillaTMemory(1)
	refe1ddcd34 := (*C.GenerateSingleWindowPoStWithVanilla_t)(meme1ddcd34)
	allocse1ddcd34 := new(cgoAllocMap)
	allocse1ddcd34.Add(meme1ddcd34)

	var cpartition_proof_allocs *cgoAllocMap
	refe1ddcd34.partition_proof, cpartition_proof_allocs = x.PartitionProof.PassValue()
	allocse1ddcd34.Borrow(cpartition_proof_allocs)

	var cfaulty_sectors_allocs *cgoAllocMap
	refe1ddcd34.faulty_sectors, cfaulty_sectors_allocs = x.FaultySectors.PassValue()
	allocse1ddcd34.Borrow(cfaulty_sectors_allocs)

	x.refe1ddcd34 = refe1ddcd34
	x.allocse1ddcd34 = allocse1ddcd34
	return refe1ddcd34, allocse1ddcd34

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x GenerateSingleWindowPoStWithVanillaT) PassValue() (C.GenerateSingleWindowPoStWithVanilla_t, *cgoAllocMap) {
	if x.refe1ddcd34 != nil {
		return *x.refe1ddcd34, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *GenerateSingleWindowPoStWithVanillaT) Deref() {
	if x.refe1ddcd34 == nil {
		return
	}
	x.PartitionProof = *NewPartitionSnarkProofTRef(unsafe.Pointer(&x.refe1ddcd34.partition_proof))
	x.FaultySectors = *NewSliceBoxedUint64TRef(unsafe.Pointer(&x.refe1ddcd34.faulty_sectors))
}

// allocResultGenerateSingleWindowPoStWithVanillaTMemory allocates memory for type C.Result_GenerateSingleWindowPoStWithVanilla_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocResultGenerateSingleWindowPoStWithVanillaTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfResultGenerateSingleWindowPoStWithVanillaTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfResultGenerateSingleWindowPoStWithVanillaTValue = unsafe.Sizeof([1]C.Result_GenerateSingleWindowPoStWithVanilla_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ResultGenerateSingleWindowPoStWithVanillaT) Ref() *C.Result_GenerateSingleWindowPoStWithVanilla_t {
	if x == nil {
		return nil
	}
	return x.ref54515f12
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ResultGenerateSingleWindowPoStWithVanillaT) Free() {
	if x != nil && x.allocs54515f12 != nil {
		x.allocs54515f12.(*cgoAllocMap).Free()
		x.ref54515f12 = nil
	}
}

// NewResultGenerateSingleWindowPoStWithVanillaTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewResultGenerateSingleWindowPoStWithVanillaTRef(ref unsafe.Pointer) *ResultGenerateSingleWindowPoStWithVanillaT {
	if ref == nil {
		return nil
	}
	obj := new(ResultGenerateSingleWindowPoStWithVanillaT)
	obj.ref54515f12 = (*C.Result_GenerateSingleWindowPoStWithVanilla_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ResultGenerateSingleWindowPoStWithVanillaT) PassRef() (*C.Result_GenerateSingleWindowPoStWithVanilla_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref54515f12 != nil {
		return x.ref54515f12, nil
	}
	mem54515f12 := allocResultGenerateSingleWindowPoStWithVanillaTMemory(1)
	ref54515f12 := (*C.Result_GenerateSingleWindowPoStWithVanilla_t)(mem54515f12)
	allocs54515f12 := new(cgoAllocMap)
	allocs54515f12.Add(mem54515f12)

	var cstatus_code_allocs *cgoAllocMap
	ref54515f12.status_code, cstatus_code_allocs = (C.FCPResponseStatus_t)(x.StatusCode), cgoAllocsUnknown
	allocs54515f12.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref54515f12.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocs54515f12.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	ref54515f12.value, cvalue_allocs = x.Value.PassValue()
	allocs54515f12.Borrow(cvalue_allocs)

	x.ref54515f12 = ref54515f12
	x.allocs54515f12 = allocs54515f12
	return ref54515f12, allocs54515f12

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ResultGenerateSingleWindowPoStWithVanillaT) PassValue() (C.Result_GenerateSingleWindowPoStWithVanilla_t, *cgoAllocMap) {
	if x.ref54515f12 != nil {
		return *x.ref54515f12, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ResultGenerateSingleWindowPoStWithVanillaT) Deref() {
	if x.ref54515f12 == nil {
		return
	}
	x.StatusCode = (FCPResponseStatusT)(x.ref54515f12.status_code)
	x.ErrorMsg = *NewSliceBoxedUint8TRef(unsafe.Pointer(&x.ref54515f12.error_msg))
	x.Value = *NewGenerateSingleWindowPoStWithVanillaTRef(unsafe.Pointer(&x.ref54515f12.value))
}

// allocEmptySectorUpdateEncodeIntoTMemory allocates memory for type C.EmptySectorUpdateEncodeInto_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocEmptySectorUpdateEncodeIntoTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfEmptySectorUpdateEncodeIntoTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfEmptySectorUpdateEncodeIntoTValue = unsafe.Sizeof([1]C.EmptySectorUpdateEncodeInto_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *EmptySectorUpdateEncodeIntoT) Ref() *C.EmptySectorUpdateEncodeInto_t {
	if x == nil {
		return nil
	}
	return x.ref7572da08
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *EmptySectorUpdateEncodeIntoT) Free() {
	if x != nil && x.allocs7572da08 != nil {
		x.allocs7572da08.(*cgoAllocMap).Free()
		x.ref7572da08 = nil
	}
}

// NewEmptySectorUpdateEncodeIntoTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewEmptySectorUpdateEncodeIntoTRef(ref unsafe.Pointer) *EmptySectorUpdateEncodeIntoT {
	if ref == nil {
		return nil
	}
	obj := new(EmptySectorUpdateEncodeIntoT)
	obj.ref7572da08 = (*C.EmptySectorUpdateEncodeInto_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *EmptySectorUpdateEncodeIntoT) PassRef() (*C.EmptySectorUpdateEncodeInto_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7572da08 != nil {
		return x.ref7572da08, nil
	}
	mem7572da08 := allocEmptySectorUpdateEncodeIntoTMemory(1)
	ref7572da08 := (*C.EmptySectorUpdateEncodeInto_t)(mem7572da08)
	allocs7572da08 := new(cgoAllocMap)
	allocs7572da08.Add(mem7572da08)

	var ccomm_r_new_allocs *cgoAllocMap
	ref7572da08.comm_r_new, ccomm_r_new_allocs = x.CommRNew.PassValue()
	allocs7572da08.Borrow(ccomm_r_new_allocs)

	var ccomm_r_last_new_allocs *cgoAllocMap
	ref7572da08.comm_r_last_new, ccomm_r_last_new_allocs = x.CommRLastNew.PassValue()
	allocs7572da08.Borrow(ccomm_r_last_new_allocs)

	var ccomm_d_new_allocs *cgoAllocMap
	ref7572da08.comm_d_new, ccomm_d_new_allocs = x.CommDNew.PassValue()
	allocs7572da08.Borrow(ccomm_d_new_allocs)

	x.ref7572da08 = ref7572da08
	x.allocs7572da08 = allocs7572da08
	return ref7572da08, allocs7572da08

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x EmptySectorUpdateEncodeIntoT) PassValue() (C.EmptySectorUpdateEncodeInto_t, *cgoAllocMap) {
	if x.ref7572da08 != nil {
		return *x.ref7572da08, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *EmptySectorUpdateEncodeIntoT) Deref() {
	if x.ref7572da08 == nil {
		return
	}
	x.CommRNew = *NewUint832ArrayTRef(unsafe.Pointer(&x.ref7572da08.comm_r_new))
	x.CommRLastNew = *NewUint832ArrayTRef(unsafe.Pointer(&x.ref7572da08.comm_r_last_new))
	x.CommDNew = *NewUint832ArrayTRef(unsafe.Pointer(&x.ref7572da08.comm_d_new))
}

// allocResultEmptySectorUpdateEncodeIntoTMemory allocates memory for type C.Result_EmptySectorUpdateEncodeInto_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocResultEmptySectorUpdateEncodeIntoTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfResultEmptySectorUpdateEncodeIntoTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfResultEmptySectorUpdateEncodeIntoTValue = unsafe.Sizeof([1]C.Result_EmptySectorUpdateEncodeInto_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ResultEmptySectorUpdateEncodeIntoT) Ref() *C.Result_EmptySectorUpdateEncodeInto_t {
	if x == nil {
		return nil
	}
	return x.reff6d56df3
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ResultEmptySectorUpdateEncodeIntoT) Free() {
	if x != nil && x.allocsf6d56df3 != nil {
		x.allocsf6d56df3.(*cgoAllocMap).Free()
		x.reff6d56df3 = nil
	}
}

// NewResultEmptySectorUpdateEncodeIntoTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewResultEmptySectorUpdateEncodeIntoTRef(ref unsafe.Pointer) *ResultEmptySectorUpdateEncodeIntoT {
	if ref == nil {
		return nil
	}
	obj := new(ResultEmptySectorUpdateEncodeIntoT)
	obj.reff6d56df3 = (*C.Result_EmptySectorUpdateEncodeInto_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ResultEmptySectorUpdateEncodeIntoT) PassRef() (*C.Result_EmptySectorUpdateEncodeInto_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff6d56df3 != nil {
		return x.reff6d56df3, nil
	}
	memf6d56df3 := allocResultEmptySectorUpdateEncodeIntoTMemory(1)
	reff6d56df3 := (*C.Result_EmptySectorUpdateEncodeInto_t)(memf6d56df3)
	allocsf6d56df3 := new(cgoAllocMap)
	allocsf6d56df3.Add(memf6d56df3)

	var cstatus_code_allocs *cgoAllocMap
	reff6d56df3.status_code, cstatus_code_allocs = (C.FCPResponseStatus_t)(x.StatusCode), cgoAllocsUnknown
	allocsf6d56df3.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	reff6d56df3.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocsf6d56df3.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	reff6d56df3.value, cvalue_allocs = x.Value.PassValue()
	allocsf6d56df3.Borrow(cvalue_allocs)

	x.reff6d56df3 = reff6d56df3
	x.allocsf6d56df3 = allocsf6d56df3
	return reff6d56df3, allocsf6d56df3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ResultEmptySectorUpdateEncodeIntoT) PassValue() (C.Result_EmptySectorUpdateEncodeInto_t, *cgoAllocMap) {
	if x.reff6d56df3 != nil {
		return *x.reff6d56df3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ResultEmptySectorUpdateEncodeIntoT) Deref() {
	if x.reff6d56df3 == nil {
		return
	}
	x.StatusCode = (FCPResponseStatusT)(x.reff6d56df3.status_code)
	x.ErrorMsg = *NewSliceBoxedUint8TRef(unsafe.Pointer(&x.reff6d56df3.error_msg))
	x.Value = *NewEmptySectorUpdateEncodeIntoTRef(unsafe.Pointer(&x.reff6d56df3.value))
}

// allocGeneratePieceCommitmentTMemory allocates memory for type C.GeneratePieceCommitment_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocGeneratePieceCommitmentTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfGeneratePieceCommitmentTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfGeneratePieceCommitmentTValue = unsafe.Sizeof([1]C.GeneratePieceCommitment_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *GeneratePieceCommitmentT) Ref() *C.GeneratePieceCommitment_t {
	if x == nil {
		return nil
	}
	return x.refba03f700
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *GeneratePieceCommitmentT) Free() {
	if x != nil && x.allocsba03f700 != nil {
		x.allocsba03f700.(*cgoAllocMap).Free()
		x.refba03f700 = nil
	}
}

// NewGeneratePieceCommitmentTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewGeneratePieceCommitmentTRef(ref unsafe.Pointer) *GeneratePieceCommitmentT {
	if ref == nil {
		return nil
	}
	obj := new(GeneratePieceCommitmentT)
	obj.refba03f700 = (*C.GeneratePieceCommitment_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *GeneratePieceCommitmentT) PassRef() (*C.GeneratePieceCommitment_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refba03f700 != nil {
		return x.refba03f700, nil
	}
	memba03f700 := allocGeneratePieceCommitmentTMemory(1)
	refba03f700 := (*C.GeneratePieceCommitment_t)(memba03f700)
	allocsba03f700 := new(cgoAllocMap)
	allocsba03f700.Add(memba03f700)

	var ccomm_p_allocs *cgoAllocMap
	refba03f700.comm_p, ccomm_p_allocs = x.CommP.PassValue()
	allocsba03f700.Borrow(ccomm_p_allocs)

	var cnum_bytes_aligned_allocs *cgoAllocMap
	refba03f700.num_bytes_aligned, cnum_bytes_aligned_allocs = (C.uint64_t)(x.NumBytesAligned), cgoAllocsUnknown
	allocsba03f700.Borrow(cnum_bytes_aligned_allocs)

	x.refba03f700 = refba03f700
	x.allocsba03f700 = allocsba03f700
	return refba03f700, allocsba03f700

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x GeneratePieceCommitmentT) PassValue() (C.GeneratePieceCommitment_t, *cgoAllocMap) {
	if x.refba03f700 != nil {
		return *x.refba03f700, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *GeneratePieceCommitmentT) Deref() {
	if x.refba03f700 == nil {
		return
	}
	x.CommP = *NewUint832ArrayTRef(unsafe.Pointer(&x.refba03f700.comm_p))
	x.NumBytesAligned = (Uint64T)(x.refba03f700.num_bytes_aligned)
}

// allocResultGeneratePieceCommitmentTMemory allocates memory for type C.Result_GeneratePieceCommitment_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocResultGeneratePieceCommitmentTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfResultGeneratePieceCommitmentTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfResultGeneratePieceCommitmentTValue = unsafe.Sizeof([1]C.Result_GeneratePieceCommitment_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ResultGeneratePieceCommitmentT) Ref() *C.Result_GeneratePieceCommitment_t {
	if x == nil {
		return nil
	}
	return x.ref6ad23765
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ResultGeneratePieceCommitmentT) Free() {
	if x != nil && x.allocs6ad23765 != nil {
		x.allocs6ad23765.(*cgoAllocMap).Free()
		x.ref6ad23765 = nil
	}
}

// NewResultGeneratePieceCommitmentTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewResultGeneratePieceCommitmentTRef(ref unsafe.Pointer) *ResultGeneratePieceCommitmentT {
	if ref == nil {
		return nil
	}
	obj := new(ResultGeneratePieceCommitmentT)
	obj.ref6ad23765 = (*C.Result_GeneratePieceCommitment_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ResultGeneratePieceCommitmentT) PassRef() (*C.Result_GeneratePieceCommitment_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6ad23765 != nil {
		return x.ref6ad23765, nil
	}
	mem6ad23765 := allocResultGeneratePieceCommitmentTMemory(1)
	ref6ad23765 := (*C.Result_GeneratePieceCommitment_t)(mem6ad23765)
	allocs6ad23765 := new(cgoAllocMap)
	allocs6ad23765.Add(mem6ad23765)

	var cstatus_code_allocs *cgoAllocMap
	ref6ad23765.status_code, cstatus_code_allocs = (C.FCPResponseStatus_t)(x.StatusCode), cgoAllocsUnknown
	allocs6ad23765.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref6ad23765.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocs6ad23765.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	ref6ad23765.value, cvalue_allocs = x.Value.PassValue()
	allocs6ad23765.Borrow(cvalue_allocs)

	x.ref6ad23765 = ref6ad23765
	x.allocs6ad23765 = allocs6ad23765
	return ref6ad23765, allocs6ad23765

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ResultGeneratePieceCommitmentT) PassValue() (C.Result_GeneratePieceCommitment_t, *cgoAllocMap) {
	if x.ref6ad23765 != nil {
		return *x.ref6ad23765, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ResultGeneratePieceCommitmentT) Deref() {
	if x.ref6ad23765 == nil {
		return
	}
	x.StatusCode = (FCPResponseStatusT)(x.ref6ad23765.status_code)
	x.ErrorMsg = *NewSliceBoxedUint8TRef(unsafe.Pointer(&x.ref6ad23765.error_msg))
	x.Value = *NewGeneratePieceCommitmentTRef(unsafe.Pointer(&x.ref6ad23765.value))
}

// copyPCharBytes copies the data from Go slice as *C.char.
func copyPCharBytes(slice *sliceHeader) (*C.char, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfCharValue) * slice.Len,
		Cap:  int(sizeOfCharValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.char)(mem0), allocs
}

// allocCharMemory allocates memory for type C.char in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCharMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCharValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCharValue = unsafe.Sizeof([1]C.char{})

// unpackArgSResultSliceBoxedSliceBoxedUint8T transforms a sliced Go data structure into plain C format.
func unpackArgSResultSliceBoxedSliceBoxedUint8T(x []ResultSliceBoxedSliceBoxedUint8T) (unpacked *C.Result_slice_boxed_slice_boxed_uint8_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocResultSliceBoxedSliceBoxedUint8TMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Result_slice_boxed_slice_boxed_uint8_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Result_slice_boxed_slice_boxed_uint8_t)(h.Data)
	return
}

// packSResultSliceBoxedSliceBoxedUint8T reads sliced Go data structure out from plain C format.
func packSResultSliceBoxedSliceBoxedUint8T(v []ResultSliceBoxedSliceBoxedUint8T, ptr0 *C.Result_slice_boxed_slice_boxed_uint8_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfResultSliceBoxedSliceBoxedUint8TValue]C.Result_slice_boxed_slice_boxed_uint8_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewResultSliceBoxedSliceBoxedUint8TRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSResultVoidT transforms a sliced Go data structure into plain C format.
func unpackArgSResultVoidT(x []ResultVoidT) (unpacked *C.Result_void_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocResultVoidTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Result_void_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Result_void_t)(h.Data)
	return
}

// packSResultVoidT reads sliced Go data structure out from plain C format.
func packSResultVoidT(v []ResultVoidT, ptr0 *C.Result_void_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfResultVoidTValue]C.Result_void_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewResultVoidTRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSUint896ArrayT transforms a sliced Go data structure into plain C format.
func unpackArgSUint896ArrayT(x []Uint896ArrayT) (unpacked *C.uint8_96_array_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocUint896ArrayTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.uint8_96_array_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.uint8_96_array_t)(h.Data)
	return
}

// packSUint896ArrayT reads sliced Go data structure out from plain C format.
func packSUint896ArrayT(v []Uint896ArrayT, ptr0 *C.uint8_96_array_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfUint896ArrayTValue]C.uint8_96_array_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewUint896ArrayTRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSUint832ArrayT transforms a sliced Go data structure into plain C format.
func unpackArgSUint832ArrayT(x []Uint832ArrayT) (unpacked *C.uint8_32_array_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocUint832ArrayTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.uint8_32_array_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.uint8_32_array_t)(h.Data)
	return
}

// packSUint832ArrayT reads sliced Go data structure out from plain C format.
func packSUint832ArrayT(v []Uint832ArrayT, ptr0 *C.uint8_32_array_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfUint832ArrayTValue]C.uint8_32_array_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewUint832ArrayTRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSZeroSignatureResponseT transforms a sliced Go data structure into plain C format.
func unpackArgSZeroSignatureResponseT(x []ZeroSignatureResponseT) (unpacked *C.ZeroSignatureResponse_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocZeroSignatureResponseTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.ZeroSignatureResponse_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.ZeroSignatureResponse_t)(h.Data)
	return
}

// packSZeroSignatureResponseT reads sliced Go data structure out from plain C format.
func packSZeroSignatureResponseT(v []ZeroSignatureResponseT, ptr0 *C.ZeroSignatureResponse_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfZeroSignatureResponseTValue]C.ZeroSignatureResponse_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewZeroSignatureResponseTRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSResultWriteWithAlignmentT transforms a sliced Go data structure into plain C format.
func unpackArgSResultWriteWithAlignmentT(x []ResultWriteWithAlignmentT) (unpacked *C.Result_WriteWithAlignment_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocResultWriteWithAlignmentTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Result_WriteWithAlignment_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Result_WriteWithAlignment_t)(h.Data)
	return
}

// packSResultWriteWithAlignmentT reads sliced Go data structure out from plain C format.
func packSResultWriteWithAlignmentT(v []ResultWriteWithAlignmentT, ptr0 *C.Result_WriteWithAlignment_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfResultWriteWithAlignmentTValue]C.Result_WriteWithAlignment_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewResultWriteWithAlignmentTRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSResultWriteWithoutAlignmentT transforms a sliced Go data structure into plain C format.
func unpackArgSResultWriteWithoutAlignmentT(x []ResultWriteWithoutAlignmentT) (unpacked *C.Result_WriteWithoutAlignment_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocResultWriteWithoutAlignmentTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Result_WriteWithoutAlignment_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Result_WriteWithoutAlignment_t)(h.Data)
	return
}

// packSResultWriteWithoutAlignmentT reads sliced Go data structure out from plain C format.
func packSResultWriteWithoutAlignmentT(v []ResultWriteWithoutAlignmentT, ptr0 *C.Result_WriteWithoutAlignment_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfResultWriteWithoutAlignmentTValue]C.Result_WriteWithoutAlignment_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewResultWriteWithoutAlignmentTRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSResultByteArray32T transforms a sliced Go data structure into plain C format.
func unpackArgSResultByteArray32T(x []ResultByteArray32T) (unpacked *C.Result_ByteArray32_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocResultByteArray32TMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Result_ByteArray32_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Result_ByteArray32_t)(h.Data)
	return
}

// packSResultByteArray32T reads sliced Go data structure out from plain C format.
func packSResultByteArray32T(v []ResultByteArray32T, ptr0 *C.Result_ByteArray32_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfResultByteArray32TValue]C.Result_ByteArray32_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewResultByteArray32TRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSResultSliceBoxedUint8T transforms a sliced Go data structure into plain C format.
func unpackArgSResultSliceBoxedUint8T(x []ResultSliceBoxedUint8T) (unpacked *C.Result_slice_boxed_uint8_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocResultSliceBoxedUint8TMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Result_slice_boxed_uint8_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Result_slice_boxed_uint8_t)(h.Data)
	return
}

// packSResultSliceBoxedUint8T reads sliced Go data structure out from plain C format.
func packSResultSliceBoxedUint8T(v []ResultSliceBoxedUint8T, ptr0 *C.Result_slice_boxed_uint8_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfResultSliceBoxedUint8TValue]C.Result_slice_boxed_uint8_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewResultSliceBoxedUint8TRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSResultSealPreCommitPhase2T transforms a sliced Go data structure into plain C format.
func unpackArgSResultSealPreCommitPhase2T(x []ResultSealPreCommitPhase2T) (unpacked *C.Result_SealPreCommitPhase2_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocResultSealPreCommitPhase2TMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Result_SealPreCommitPhase2_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Result_SealPreCommitPhase2_t)(h.Data)
	return
}

// packSResultSealPreCommitPhase2T reads sliced Go data structure out from plain C format.
func packSResultSealPreCommitPhase2T(v []ResultSealPreCommitPhase2T, ptr0 *C.Result_SealPreCommitPhase2_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfResultSealPreCommitPhase2TValue]C.Result_SealPreCommitPhase2_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewResultSealPreCommitPhase2TRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSResultSealCommitPhase2T transforms a sliced Go data structure into plain C format.
func unpackArgSResultSealCommitPhase2T(x []ResultSealCommitPhase2T) (unpacked *C.Result_SealCommitPhase2_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocResultSealCommitPhase2TMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Result_SealCommitPhase2_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Result_SealCommitPhase2_t)(h.Data)
	return
}

// packSResultSealCommitPhase2T reads sliced Go data structure out from plain C format.
func packSResultSealCommitPhase2T(v []ResultSealCommitPhase2T, ptr0 *C.Result_SealCommitPhase2_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfResultSealCommitPhase2TValue]C.Result_SealCommitPhase2_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewResultSealCommitPhase2TRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSResultGeneratePieceCommitmentT transforms a sliced Go data structure into plain C format.
func unpackArgSResultGeneratePieceCommitmentT(x []ResultGeneratePieceCommitmentT) (unpacked *C.Result_GeneratePieceCommitment_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocResultGeneratePieceCommitmentTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Result_GeneratePieceCommitment_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Result_GeneratePieceCommitment_t)(h.Data)
	return
}

// packSResultGeneratePieceCommitmentT reads sliced Go data structure out from plain C format.
func packSResultGeneratePieceCommitmentT(v []ResultGeneratePieceCommitmentT, ptr0 *C.Result_GeneratePieceCommitment_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfResultGeneratePieceCommitmentTValue]C.Result_GeneratePieceCommitment_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewResultGeneratePieceCommitmentTRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSResultBoolT transforms a sliced Go data structure into plain C format.
func unpackArgSResultBoolT(x []ResultBoolT) (unpacked *C.Result_bool_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocResultBoolTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Result_bool_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Result_bool_t)(h.Data)
	return
}

// packSResultBoolT reads sliced Go data structure out from plain C format.
func packSResultBoolT(v []ResultBoolT, ptr0 *C.Result_bool_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfResultBoolTValue]C.Result_bool_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewResultBoolTRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSResultGenerateFallbackSectorChallengesT transforms a sliced Go data structure into plain C format.
func unpackArgSResultGenerateFallbackSectorChallengesT(x []ResultGenerateFallbackSectorChallengesT) (unpacked *C.Result_GenerateFallbackSectorChallenges_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocResultGenerateFallbackSectorChallengesTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Result_GenerateFallbackSectorChallenges_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Result_GenerateFallbackSectorChallenges_t)(h.Data)
	return
}

// packSResultGenerateFallbackSectorChallengesT reads sliced Go data structure out from plain C format.
func packSResultGenerateFallbackSectorChallengesT(v []ResultGenerateFallbackSectorChallengesT, ptr0 *C.Result_GenerateFallbackSectorChallenges_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfResultGenerateFallbackSectorChallengesTValue]C.Result_GenerateFallbackSectorChallenges_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewResultGenerateFallbackSectorChallengesTRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSResultGenerateSingleWindowPoStWithVanillaT transforms a sliced Go data structure into plain C format.
func unpackArgSResultGenerateSingleWindowPoStWithVanillaT(x []ResultGenerateSingleWindowPoStWithVanillaT) (unpacked *C.Result_GenerateSingleWindowPoStWithVanilla_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocResultGenerateSingleWindowPoStWithVanillaTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Result_GenerateSingleWindowPoStWithVanilla_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Result_GenerateSingleWindowPoStWithVanilla_t)(h.Data)
	return
}

// packSResultGenerateSingleWindowPoStWithVanillaT reads sliced Go data structure out from plain C format.
func packSResultGenerateSingleWindowPoStWithVanillaT(v []ResultGenerateSingleWindowPoStWithVanillaT, ptr0 *C.Result_GenerateSingleWindowPoStWithVanilla_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfResultGenerateSingleWindowPoStWithVanillaTValue]C.Result_GenerateSingleWindowPoStWithVanilla_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewResultGenerateSingleWindowPoStWithVanillaTRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSResultSizeT transforms a sliced Go data structure into plain C format.
func unpackArgSResultSizeT(x []ResultSizeT) (unpacked *C.Result_size_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocResultSizeTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Result_size_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Result_size_t)(h.Data)
	return
}

// packSResultSizeT reads sliced Go data structure out from plain C format.
func packSResultSizeT(v []ResultSizeT, ptr0 *C.Result_size_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfResultSizeTValue]C.Result_size_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewResultSizeTRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSResultPoStProofT transforms a sliced Go data structure into plain C format.
func unpackArgSResultPoStProofT(x []ResultPoStProofT) (unpacked *C.Result_PoStProof_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocResultPoStProofTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Result_PoStProof_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Result_PoStProof_t)(h.Data)
	return
}

// packSResultPoStProofT reads sliced Go data structure out from plain C format.
func packSResultPoStProofT(v []ResultPoStProofT, ptr0 *C.Result_PoStProof_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfResultPoStProofTValue]C.Result_PoStProof_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewResultPoStProofTRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSResultSliceBoxedPoStProofT transforms a sliced Go data structure into plain C format.
func unpackArgSResultSliceBoxedPoStProofT(x []ResultSliceBoxedPoStProofT) (unpacked *C.Result_slice_boxed_PoStProof_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocResultSliceBoxedPoStProofTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Result_slice_boxed_PoStProof_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Result_slice_boxed_PoStProof_t)(h.Data)
	return
}

// packSResultSliceBoxedPoStProofT reads sliced Go data structure out from plain C format.
func packSResultSliceBoxedPoStProofT(v []ResultSliceBoxedPoStProofT, ptr0 *C.Result_slice_boxed_PoStProof_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfResultSliceBoxedPoStProofTValue]C.Result_slice_boxed_PoStProof_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewResultSliceBoxedPoStProofTRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSResultGenerateWindowPoStT transforms a sliced Go data structure into plain C format.
func unpackArgSResultGenerateWindowPoStT(x []ResultGenerateWindowPoStT) (unpacked *C.Result_GenerateWindowPoSt_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocResultGenerateWindowPoStTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Result_GenerateWindowPoSt_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Result_GenerateWindowPoSt_t)(h.Data)
	return
}

// packSResultGenerateWindowPoStT reads sliced Go data structure out from plain C format.
func packSResultGenerateWindowPoStT(v []ResultGenerateWindowPoStT, ptr0 *C.Result_GenerateWindowPoSt_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfResultGenerateWindowPoStTValue]C.Result_GenerateWindowPoSt_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewResultGenerateWindowPoStTRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSResultSliceBoxedUint64T transforms a sliced Go data structure into plain C format.
func unpackArgSResultSliceBoxedUint64T(x []ResultSliceBoxedUint64T) (unpacked *C.Result_slice_boxed_uint64_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocResultSliceBoxedUint64TMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Result_slice_boxed_uint64_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Result_slice_boxed_uint64_t)(h.Data)
	return
}

// packSResultSliceBoxedUint64T reads sliced Go data structure out from plain C format.
func packSResultSliceBoxedUint64T(v []ResultSliceBoxedUint64T, ptr0 *C.Result_slice_boxed_uint64_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfResultSliceBoxedUint64TValue]C.Result_slice_boxed_uint64_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewResultSliceBoxedUint64TRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSResultEmptySectorUpdateEncodeIntoT transforms a sliced Go data structure into plain C format.
func unpackArgSResultEmptySectorUpdateEncodeIntoT(x []ResultEmptySectorUpdateEncodeIntoT) (unpacked *C.Result_EmptySectorUpdateEncodeInto_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocResultEmptySectorUpdateEncodeIntoTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Result_EmptySectorUpdateEncodeInto_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Result_EmptySectorUpdateEncodeInto_t)(h.Data)
	return
}

// packSResultEmptySectorUpdateEncodeIntoT reads sliced Go data structure out from plain C format.
func packSResultEmptySectorUpdateEncodeIntoT(v []ResultEmptySectorUpdateEncodeIntoT, ptr0 *C.Result_EmptySectorUpdateEncodeInto_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfResultEmptySectorUpdateEncodeIntoTValue]C.Result_EmptySectorUpdateEncodeInto_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewResultEmptySectorUpdateEncodeIntoTRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSHashResponseT transforms a sliced Go data structure into plain C format.
func unpackArgSHashResponseT(x []HashResponseT) (unpacked *C.HashResponse_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocHashResponseTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.HashResponse_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.HashResponse_t)(h.Data)
	return
}

// packSHashResponseT reads sliced Go data structure out from plain C format.
func packSHashResponseT(v []HashResponseT, ptr0 *C.HashResponse_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfHashResponseTValue]C.HashResponse_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewHashResponseTRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSAggregateResponseT transforms a sliced Go data structure into plain C format.
func unpackArgSAggregateResponseT(x []AggregateResponseT) (unpacked *C.AggregateResponse_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocAggregateResponseTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.AggregateResponse_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.AggregateResponse_t)(h.Data)
	return
}

// packSAggregateResponseT reads sliced Go data structure out from plain C format.
func packSAggregateResponseT(v []AggregateResponseT, ptr0 *C.AggregateResponse_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfAggregateResponseTValue]C.AggregateResponse_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewAggregateResponseTRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSPrivateKeyGenerateResponseT transforms a sliced Go data structure into plain C format.
func unpackArgSPrivateKeyGenerateResponseT(x []PrivateKeyGenerateResponseT) (unpacked *C.PrivateKeyGenerateResponse_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPrivateKeyGenerateResponseTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.PrivateKeyGenerateResponse_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.PrivateKeyGenerateResponse_t)(h.Data)
	return
}

// packSPrivateKeyGenerateResponseT reads sliced Go data structure out from plain C format.
func packSPrivateKeyGenerateResponseT(v []PrivateKeyGenerateResponseT, ptr0 *C.PrivateKeyGenerateResponse_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPrivateKeyGenerateResponseTValue]C.PrivateKeyGenerateResponse_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPrivateKeyGenerateResponseTRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSPrivateKeySignResponseT transforms a sliced Go data structure into plain C format.
func unpackArgSPrivateKeySignResponseT(x []PrivateKeySignResponseT) (unpacked *C.PrivateKeySignResponse_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPrivateKeySignResponseTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.PrivateKeySignResponse_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.PrivateKeySignResponse_t)(h.Data)
	return
}

// packSPrivateKeySignResponseT reads sliced Go data structure out from plain C format.
func packSPrivateKeySignResponseT(v []PrivateKeySignResponseT, ptr0 *C.PrivateKeySignResponse_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPrivateKeySignResponseTValue]C.PrivateKeySignResponse_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPrivateKeySignResponseTRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSPrivateKeyPublicKeyResponseT transforms a sliced Go data structure into plain C format.
func unpackArgSPrivateKeyPublicKeyResponseT(x []PrivateKeyPublicKeyResponseT) (unpacked *C.PrivateKeyPublicKeyResponse_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPrivateKeyPublicKeyResponseTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.PrivateKeyPublicKeyResponse_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.PrivateKeyPublicKeyResponse_t)(h.Data)
	return
}

// packSPrivateKeyPublicKeyResponseT reads sliced Go data structure out from plain C format.
func packSPrivateKeyPublicKeyResponseT(v []PrivateKeyPublicKeyResponseT, ptr0 *C.PrivateKeyPublicKeyResponse_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPrivateKeyPublicKeyResponseTValue]C.PrivateKeyPublicKeyResponse_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPrivateKeyPublicKeyResponseTRef(unsafe.Pointer(&ptr1))
	}
}
