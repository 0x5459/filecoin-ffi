// WARNING: This file has automatically been generated
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package generated

/*
#cgo LDFLAGS: -L${SRCDIR}/..
#cgo pkg-config: ${SRCDIR}/../filcrypto.pc
#include "../filcrypto.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"fmt"
	"runtime"
	"sync"
	"unsafe"
)

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

// allocFilArrayUint64TMemory allocates memory for type C.fil_Array_uint64_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilArrayUint64TMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilArrayUint64TValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilArrayUint64TValue = unsafe.Sizeof([1]C.fil_Array_uint64_t{})

type sliceHeader struct {
	Data unsafe.Pointer
	Len  int
	Cap  int
}

// allocPUint64TMemory allocates memory for type *C.uint64_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPUint64TMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPUint64TValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPUint64TValue = unsafe.Sizeof([1]*C.uint64_t{})

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// unpackSSUUint64 transforms a sliced Go data structure into plain C format.
func unpackSSUUint64(x [][]uint64) (unpacked **C.uint64_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPUint64TMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.uint64_t)(unsafe.Pointer(h0))
	for i0 := range x {
		h := (*sliceHeader)(unsafe.Pointer(&x[i0]))
		v0[i0] = (*C.uint64_t)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.uint64_t)(h.Data)
	return
}

// packSSUUint64 reads sliced Go data structure out from plain C format.
func packSSUUint64(v [][]uint64, ptr0 **C.uint64_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.uint64_t)(unsafe.Pointer(ptr0)))[i0]
		hxfc4425b := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxfc4425b.Data = unsafe.Pointer(ptr1)
		hxfc4425b.Cap = 0x7fffffff
		// hxfc4425b.Len = ?
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilArrayUint64T) Ref() *C.fil_Array_uint64_t {
	if x == nil {
		return nil
	}
	return x.ref785418ed
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilArrayUint64T) Free() {
	if x != nil && x.allocs785418ed != nil {
		x.allocs785418ed.(*cgoAllocMap).Free()
		x.ref785418ed = nil
	}
}

// NewFilArrayUint64TRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilArrayUint64TRef(ref unsafe.Pointer) *FilArrayUint64T {
	if ref == nil {
		return nil
	}
	obj := new(FilArrayUint64T)
	obj.ref785418ed = (*C.fil_Array_uint64_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilArrayUint64T) PassRef() (*C.fil_Array_uint64_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref785418ed != nil {
		return x.ref785418ed, nil
	}
	mem785418ed := allocFilArrayUint64TMemory(1)
	ref785418ed := (*C.fil_Array_uint64_t)(mem785418ed)
	allocs785418ed := new(cgoAllocMap)
	allocs785418ed.Add(mem785418ed)

	var cptr_allocs *cgoAllocMap
	ref785418ed.ptr, cptr_allocs = unpackSSUUint64(x.Ptr)
	allocs785418ed.Borrow(cptr_allocs)

	var clen_allocs *cgoAllocMap
	ref785418ed.len, clen_allocs = (C.size_t)(x.Len), cgoAllocsUnknown
	allocs785418ed.Borrow(clen_allocs)

	x.ref785418ed = ref785418ed
	x.allocs785418ed = allocs785418ed
	return ref785418ed, allocs785418ed

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilArrayUint64T) PassValue() (C.fil_Array_uint64_t, *cgoAllocMap) {
	if x.ref785418ed != nil {
		return *x.ref785418ed, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilArrayUint64T) Deref() {
	if x.ref785418ed == nil {
		return
	}
	packSSUUint64(x.Ptr, x.ref785418ed.ptr)
	x.Len = (uint)(x.ref785418ed.len)
}

// allocFilArrayUint8TMemory allocates memory for type C.fil_Array_uint8_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilArrayUint8TMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilArrayUint8TValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilArrayUint8TValue = unsafe.Sizeof([1]C.fil_Array_uint8_t{})

// allocPUint8TMemory allocates memory for type *C.uint8_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPUint8TMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPUint8TValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPUint8TValue = unsafe.Sizeof([1]*C.uint8_t{})

// unpackSSByte transforms a sliced Go data structure into plain C format.
func unpackSSByte(x [][]byte) (unpacked **C.uint8_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPUint8TMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.uint8_t)(unsafe.Pointer(h0))
	for i0 := range x {
		h := (*sliceHeader)(unsafe.Pointer(&x[i0]))
		v0[i0] = (*C.uint8_t)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.uint8_t)(h.Data)
	return
}

// packSSByte reads sliced Go data structure out from plain C format.
func packSSByte(v [][]byte, ptr0 **C.uint8_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.uint8_t)(unsafe.Pointer(ptr0)))[i0]
		hxf95e7c8 := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxf95e7c8.Data = unsafe.Pointer(ptr1)
		hxf95e7c8.Cap = 0x7fffffff
		// hxf95e7c8.Len = ?
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilArrayUint8T) Ref() *C.fil_Array_uint8_t {
	if x == nil {
		return nil
	}
	return x.ref7c90593c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilArrayUint8T) Free() {
	if x != nil && x.allocs7c90593c != nil {
		x.allocs7c90593c.(*cgoAllocMap).Free()
		x.ref7c90593c = nil
	}
}

// NewFilArrayUint8TRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilArrayUint8TRef(ref unsafe.Pointer) *FilArrayUint8T {
	if ref == nil {
		return nil
	}
	obj := new(FilArrayUint8T)
	obj.ref7c90593c = (*C.fil_Array_uint8_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilArrayUint8T) PassRef() (*C.fil_Array_uint8_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7c90593c != nil {
		return x.ref7c90593c, nil
	}
	mem7c90593c := allocFilArrayUint8TMemory(1)
	ref7c90593c := (*C.fil_Array_uint8_t)(mem7c90593c)
	allocs7c90593c := new(cgoAllocMap)
	allocs7c90593c.Add(mem7c90593c)

	var cptr_allocs *cgoAllocMap
	ref7c90593c.ptr, cptr_allocs = unpackSSByte(x.Ptr)
	allocs7c90593c.Borrow(cptr_allocs)

	var clen_allocs *cgoAllocMap
	ref7c90593c.len, clen_allocs = (C.size_t)(x.Len), cgoAllocsUnknown
	allocs7c90593c.Borrow(clen_allocs)

	x.ref7c90593c = ref7c90593c
	x.allocs7c90593c = allocs7c90593c
	return ref7c90593c, allocs7c90593c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilArrayUint8T) PassValue() (C.fil_Array_uint8_t, *cgoAllocMap) {
	if x.ref7c90593c != nil {
		return *x.ref7c90593c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilArrayUint8T) Deref() {
	if x.ref7c90593c == nil {
		return
	}
	packSSByte(x.Ptr, x.ref7c90593c.ptr)
	x.Len = (uint)(x.ref7c90593c.len)
}

// allocFilWriteWithAlignmentTMemory allocates memory for type C.fil_WriteWithAlignment_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilWriteWithAlignmentTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilWriteWithAlignmentTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilWriteWithAlignmentTValue = unsafe.Sizeof([1]C.fil_WriteWithAlignment_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilWriteWithAlignmentT) Ref() *C.fil_WriteWithAlignment_t {
	if x == nil {
		return nil
	}
	return x.ref39d4db0f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilWriteWithAlignmentT) Free() {
	if x != nil && x.allocs39d4db0f != nil {
		x.allocs39d4db0f.(*cgoAllocMap).Free()
		x.ref39d4db0f = nil
	}
}

// NewFilWriteWithAlignmentTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilWriteWithAlignmentTRef(ref unsafe.Pointer) *FilWriteWithAlignmentT {
	if ref == nil {
		return nil
	}
	obj := new(FilWriteWithAlignmentT)
	obj.ref39d4db0f = (*C.fil_WriteWithAlignment_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilWriteWithAlignmentT) PassRef() (*C.fil_WriteWithAlignment_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref39d4db0f != nil {
		return x.ref39d4db0f, nil
	}
	mem39d4db0f := allocFilWriteWithAlignmentTMemory(1)
	ref39d4db0f := (*C.fil_WriteWithAlignment_t)(mem39d4db0f)
	allocs39d4db0f := new(cgoAllocMap)
	allocs39d4db0f.Add(mem39d4db0f)

	var cleft_alignment_unpadded_allocs *cgoAllocMap
	ref39d4db0f.left_alignment_unpadded, cleft_alignment_unpadded_allocs = (C.uint64_t)(x.LeftAlignmentUnpadded), cgoAllocsUnknown
	allocs39d4db0f.Borrow(cleft_alignment_unpadded_allocs)

	var ctotal_write_unpadded_allocs *cgoAllocMap
	ref39d4db0f.total_write_unpadded, ctotal_write_unpadded_allocs = (C.uint64_t)(x.TotalWriteUnpadded), cgoAllocsUnknown
	allocs39d4db0f.Borrow(ctotal_write_unpadded_allocs)

	x.ref39d4db0f = ref39d4db0f
	x.allocs39d4db0f = allocs39d4db0f
	return ref39d4db0f, allocs39d4db0f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilWriteWithAlignmentT) PassValue() (C.fil_WriteWithAlignment_t, *cgoAllocMap) {
	if x.ref39d4db0f != nil {
		return *x.ref39d4db0f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilWriteWithAlignmentT) Deref() {
	if x.ref39d4db0f == nil {
		return
	}
	x.LeftAlignmentUnpadded = (uint64)(x.ref39d4db0f.left_alignment_unpadded)
	x.TotalWriteUnpadded = (uint64)(x.ref39d4db0f.total_write_unpadded)
}

// allocFilResultFilWriteWithAlignmentTMemory allocates memory for type C.fil_Result_fil_WriteWithAlignment_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilResultFilWriteWithAlignmentTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilResultFilWriteWithAlignmentTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilResultFilWriteWithAlignmentTValue = unsafe.Sizeof([1]C.fil_Result_fil_WriteWithAlignment_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilResultFilWriteWithAlignmentT) Ref() *C.fil_Result_fil_WriteWithAlignment_t {
	if x == nil {
		return nil
	}
	return x.ref64a6ee1e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilResultFilWriteWithAlignmentT) Free() {
	if x != nil && x.allocs64a6ee1e != nil {
		x.allocs64a6ee1e.(*cgoAllocMap).Free()
		x.ref64a6ee1e = nil
	}
}

// NewFilResultFilWriteWithAlignmentTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilResultFilWriteWithAlignmentTRef(ref unsafe.Pointer) *FilResultFilWriteWithAlignmentT {
	if ref == nil {
		return nil
	}
	obj := new(FilResultFilWriteWithAlignmentT)
	obj.ref64a6ee1e = (*C.fil_Result_fil_WriteWithAlignment_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilResultFilWriteWithAlignmentT) PassRef() (*C.fil_Result_fil_WriteWithAlignment_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref64a6ee1e != nil {
		return x.ref64a6ee1e, nil
	}
	mem64a6ee1e := allocFilResultFilWriteWithAlignmentTMemory(1)
	ref64a6ee1e := (*C.fil_Result_fil_WriteWithAlignment_t)(mem64a6ee1e)
	allocs64a6ee1e := new(cgoAllocMap)
	allocs64a6ee1e.Add(mem64a6ee1e)

	var cstatus_code_allocs *cgoAllocMap
	ref64a6ee1e.status_code, cstatus_code_allocs = (C.FCPResponseStatus_t)(x.StatusCode), cgoAllocsUnknown
	allocs64a6ee1e.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref64a6ee1e.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocs64a6ee1e.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	ref64a6ee1e.value, cvalue_allocs = x.Value.PassValue()
	allocs64a6ee1e.Borrow(cvalue_allocs)

	x.ref64a6ee1e = ref64a6ee1e
	x.allocs64a6ee1e = allocs64a6ee1e
	return ref64a6ee1e, allocs64a6ee1e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilResultFilWriteWithAlignmentT) PassValue() (C.fil_Result_fil_WriteWithAlignment_t, *cgoAllocMap) {
	if x.ref64a6ee1e != nil {
		return *x.ref64a6ee1e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilResultFilWriteWithAlignmentT) Deref() {
	if x.ref64a6ee1e == nil {
		return
	}
	x.StatusCode = (FCPResponseStatusT)(x.ref64a6ee1e.status_code)
	x.ErrorMsg = *NewFilArrayUint8TRef(unsafe.Pointer(&x.ref64a6ee1e.error_msg))
	x.Value = *NewFilWriteWithAlignmentTRef(unsafe.Pointer(&x.ref64a6ee1e.value))
}

// unpackArgSFilArrayUint64T transforms a sliced Go data structure into plain C format.
func unpackArgSFilArrayUint64T(x []FilArrayUint64T) (unpacked *C.fil_Array_uint64_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocFilArrayUint64TMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fil_Array_uint64_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fil_Array_uint64_t)(h.Data)
	return
}

// packSFilArrayUint64T reads sliced Go data structure out from plain C format.
func packSFilArrayUint64T(v []FilArrayUint64T, ptr0 *C.fil_Array_uint64_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfFilArrayUint64TValue]C.fil_Array_uint64_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewFilArrayUint64TRef(unsafe.Pointer(&ptr1))
	}
}
