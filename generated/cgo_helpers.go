// WARNING: This file has automatically been generated
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package generated

/*
#cgo LDFLAGS: -L${SRCDIR}/..
#cgo pkg-config: ${SRCDIR}/../filcrypto.pc
#include "../filcrypto.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"fmt"
	"runtime"
	"sync"
	"unsafe"
)

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

// allocArrayUint8TMemory allocates memory for type C.Array_uint8_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocArrayUint8TMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfArrayUint8TValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfArrayUint8TValue = unsafe.Sizeof([1]C.Array_uint8_t{})

type sliceHeader struct {
	Data unsafe.Pointer
	Len  int
	Cap  int
}

// allocPUint8TMemory allocates memory for type *C.uint8_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPUint8TMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPUint8TValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPUint8TValue = unsafe.Sizeof([1]*C.uint8_t{})

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// unpackSSUint8T transforms a sliced Go data structure into plain C format.
func unpackSSUint8T(x [][]Uint8T) (unpacked **C.uint8_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPUint8TMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.uint8_t)(unsafe.Pointer(h0))
	for i0 := range x {
		h := (*sliceHeader)(unsafe.Pointer(&x[i0]))
		v0[i0] = (*C.uint8_t)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.uint8_t)(h.Data)
	return
}

// packSSUint8T reads sliced Go data structure out from plain C format.
func packSSUint8T(v [][]Uint8T, ptr0 **C.uint8_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.uint8_t)(unsafe.Pointer(ptr0)))[i0]
		hxfc4425b := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxfc4425b.Data = unsafe.Pointer(ptr1)
		hxfc4425b.Cap = 0x7fffffff
		// hxfc4425b.Len = ?
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ArrayUint8T) Ref() *C.Array_uint8_t {
	if x == nil {
		return nil
	}
	return x.reffcb41e30
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ArrayUint8T) Free() {
	if x != nil && x.allocsfcb41e30 != nil {
		x.allocsfcb41e30.(*cgoAllocMap).Free()
		x.reffcb41e30 = nil
	}
}

// NewArrayUint8TRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewArrayUint8TRef(ref unsafe.Pointer) *ArrayUint8T {
	if ref == nil {
		return nil
	}
	obj := new(ArrayUint8T)
	obj.reffcb41e30 = (*C.Array_uint8_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ArrayUint8T) PassRef() (*C.Array_uint8_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffcb41e30 != nil {
		return x.reffcb41e30, nil
	}
	memfcb41e30 := allocArrayUint8TMemory(1)
	reffcb41e30 := (*C.Array_uint8_t)(memfcb41e30)
	allocsfcb41e30 := new(cgoAllocMap)
	allocsfcb41e30.Add(memfcb41e30)

	var cptr_allocs *cgoAllocMap
	reffcb41e30.ptr, cptr_allocs = unpackSSUint8T(x.Ptr)
	allocsfcb41e30.Borrow(cptr_allocs)

	var clen_allocs *cgoAllocMap
	reffcb41e30.len, clen_allocs = (C.size_t)(x.Len), cgoAllocsUnknown
	allocsfcb41e30.Borrow(clen_allocs)

	x.reffcb41e30 = reffcb41e30
	x.allocsfcb41e30 = allocsfcb41e30
	return reffcb41e30, allocsfcb41e30

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ArrayUint8T) PassValue() (C.Array_uint8_t, *cgoAllocMap) {
	if x.reffcb41e30 != nil {
		return *x.reffcb41e30, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ArrayUint8T) Deref() {
	if x.reffcb41e30 == nil {
		return
	}
	packSSUint8T(x.Ptr, x.reffcb41e30.ptr)
	x.Len = (SizeT)(x.reffcb41e30.len)
}

// allocArrayArrayUint8TMemory allocates memory for type C.Array_Array_uint8_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocArrayArrayUint8TMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfArrayArrayUint8TValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfArrayArrayUint8TValue = unsafe.Sizeof([1]C.Array_Array_uint8_t{})

// allocPArrayUint8TMemory allocates memory for type *C.Array_uint8_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPArrayUint8TMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPArrayUint8TValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPArrayUint8TValue = unsafe.Sizeof([1]*C.Array_uint8_t{})

// unpackSSArrayUint8T transforms a sliced Go data structure into plain C format.
func unpackSSArrayUint8T(x [][]ArrayUint8T) (unpacked **C.Array_uint8_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPArrayUint8TMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.Array_uint8_t)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocArrayUint8TMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.Array_uint8_t)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.Array_uint8_t)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.Array_uint8_t)(h.Data)
	return
}

// packSSArrayUint8T reads sliced Go data structure out from plain C format.
func packSSArrayUint8T(v [][]ArrayUint8T, ptr0 **C.Array_uint8_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.Array_uint8_t)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfArrayUint8TValue]C.Array_uint8_t)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewArrayUint8TRef(unsafe.Pointer(&ptr2))
		}
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ArrayArrayUint8T) Ref() *C.Array_Array_uint8_t {
	if x == nil {
		return nil
	}
	return x.ref598ef26c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ArrayArrayUint8T) Free() {
	if x != nil && x.allocs598ef26c != nil {
		x.allocs598ef26c.(*cgoAllocMap).Free()
		x.ref598ef26c = nil
	}
}

// NewArrayArrayUint8TRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewArrayArrayUint8TRef(ref unsafe.Pointer) *ArrayArrayUint8T {
	if ref == nil {
		return nil
	}
	obj := new(ArrayArrayUint8T)
	obj.ref598ef26c = (*C.Array_Array_uint8_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ArrayArrayUint8T) PassRef() (*C.Array_Array_uint8_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref598ef26c != nil {
		return x.ref598ef26c, nil
	}
	mem598ef26c := allocArrayArrayUint8TMemory(1)
	ref598ef26c := (*C.Array_Array_uint8_t)(mem598ef26c)
	allocs598ef26c := new(cgoAllocMap)
	allocs598ef26c.Add(mem598ef26c)

	var cptr_allocs *cgoAllocMap
	ref598ef26c.ptr, cptr_allocs = unpackSSArrayUint8T(x.Ptr)
	allocs598ef26c.Borrow(cptr_allocs)

	var clen_allocs *cgoAllocMap
	ref598ef26c.len, clen_allocs = (C.size_t)(x.Len), cgoAllocsUnknown
	allocs598ef26c.Borrow(clen_allocs)

	x.ref598ef26c = ref598ef26c
	x.allocs598ef26c = allocs598ef26c
	return ref598ef26c, allocs598ef26c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ArrayArrayUint8T) PassValue() (C.Array_Array_uint8_t, *cgoAllocMap) {
	if x.ref598ef26c != nil {
		return *x.ref598ef26c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ArrayArrayUint8T) Deref() {
	if x.ref598ef26c == nil {
		return
	}
	packSSArrayUint8T(x.Ptr, x.ref598ef26c.ptr)
	x.Len = (SizeT)(x.ref598ef26c.len)
}

// allocResultArrayArrayUint8TMemory allocates memory for type C.Result_Array_Array_uint8_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocResultArrayArrayUint8TMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfResultArrayArrayUint8TValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfResultArrayArrayUint8TValue = unsafe.Sizeof([1]C.Result_Array_Array_uint8_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ResultArrayArrayUint8T) Ref() *C.Result_Array_Array_uint8_t {
	if x == nil {
		return nil
	}
	return x.ref5436f6c4
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ResultArrayArrayUint8T) Free() {
	if x != nil && x.allocs5436f6c4 != nil {
		x.allocs5436f6c4.(*cgoAllocMap).Free()
		x.ref5436f6c4 = nil
	}
}

// NewResultArrayArrayUint8TRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewResultArrayArrayUint8TRef(ref unsafe.Pointer) *ResultArrayArrayUint8T {
	if ref == nil {
		return nil
	}
	obj := new(ResultArrayArrayUint8T)
	obj.ref5436f6c4 = (*C.Result_Array_Array_uint8_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ResultArrayArrayUint8T) PassRef() (*C.Result_Array_Array_uint8_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5436f6c4 != nil {
		return x.ref5436f6c4, nil
	}
	mem5436f6c4 := allocResultArrayArrayUint8TMemory(1)
	ref5436f6c4 := (*C.Result_Array_Array_uint8_t)(mem5436f6c4)
	allocs5436f6c4 := new(cgoAllocMap)
	allocs5436f6c4.Add(mem5436f6c4)

	var cstatus_code_allocs *cgoAllocMap
	ref5436f6c4.status_code, cstatus_code_allocs = (C.FCPResponseStatus_t)(x.StatusCode), cgoAllocsUnknown
	allocs5436f6c4.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref5436f6c4.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocs5436f6c4.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	ref5436f6c4.value, cvalue_allocs = x.Value.PassValue()
	allocs5436f6c4.Borrow(cvalue_allocs)

	x.ref5436f6c4 = ref5436f6c4
	x.allocs5436f6c4 = allocs5436f6c4
	return ref5436f6c4, allocs5436f6c4

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ResultArrayArrayUint8T) PassValue() (C.Result_Array_Array_uint8_t, *cgoAllocMap) {
	if x.ref5436f6c4 != nil {
		return *x.ref5436f6c4, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ResultArrayArrayUint8T) Deref() {
	if x.ref5436f6c4 == nil {
		return
	}
	x.StatusCode = (FCPResponseStatusT)(x.ref5436f6c4.status_code)
	x.ErrorMsg = *NewArrayUint8TRef(unsafe.Pointer(&x.ref5436f6c4.error_msg))
	x.Value = *NewArrayArrayUint8TRef(unsafe.Pointer(&x.ref5436f6c4.value))
}

// allocResultVoidTMemory allocates memory for type C.Result_void_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocResultVoidTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfResultVoidTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfResultVoidTValue = unsafe.Sizeof([1]C.Result_void_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ResultVoidT) Ref() *C.Result_void_t {
	if x == nil {
		return nil
	}
	return x.ref4381f081
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ResultVoidT) Free() {
	if x != nil && x.allocs4381f081 != nil {
		x.allocs4381f081.(*cgoAllocMap).Free()
		x.ref4381f081 = nil
	}
}

// NewResultVoidTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewResultVoidTRef(ref unsafe.Pointer) *ResultVoidT {
	if ref == nil {
		return nil
	}
	obj := new(ResultVoidT)
	obj.ref4381f081 = (*C.Result_void_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ResultVoidT) PassRef() (*C.Result_void_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4381f081 != nil {
		return x.ref4381f081, nil
	}
	mem4381f081 := allocResultVoidTMemory(1)
	ref4381f081 := (*C.Result_void_t)(mem4381f081)
	allocs4381f081 := new(cgoAllocMap)
	allocs4381f081.Add(mem4381f081)

	var cstatus_code_allocs *cgoAllocMap
	ref4381f081.status_code, cstatus_code_allocs = (C.FCPResponseStatus_t)(x.StatusCode), cgoAllocsUnknown
	allocs4381f081.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref4381f081.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocs4381f081.Borrow(cerror_msg_allocs)

	x.ref4381f081 = ref4381f081
	x.allocs4381f081 = allocs4381f081
	return ref4381f081, allocs4381f081

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ResultVoidT) PassValue() (C.Result_void_t, *cgoAllocMap) {
	if x.ref4381f081 != nil {
		return *x.ref4381f081, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ResultVoidT) Deref() {
	if x.ref4381f081 == nil {
		return
	}
	x.StatusCode = (FCPResponseStatusT)(x.ref4381f081.status_code)
	x.ErrorMsg = *NewArrayUint8TRef(unsafe.Pointer(&x.ref4381f081.error_msg))
}

// allocUint896ArrayTMemory allocates memory for type C.uint8_96_array_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUint896ArrayTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUint896ArrayTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfUint896ArrayTValue = unsafe.Sizeof([1]C.uint8_96_array_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Uint896ArrayT) Ref() *C.uint8_96_array_t {
	if x == nil {
		return nil
	}
	return x.refa6a34c86
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Uint896ArrayT) Free() {
	if x != nil && x.allocsa6a34c86 != nil {
		x.allocsa6a34c86.(*cgoAllocMap).Free()
		x.refa6a34c86 = nil
	}
}

// NewUint896ArrayTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewUint896ArrayTRef(ref unsafe.Pointer) *Uint896ArrayT {
	if ref == nil {
		return nil
	}
	obj := new(Uint896ArrayT)
	obj.refa6a34c86 = (*C.uint8_96_array_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Uint896ArrayT) PassRef() (*C.uint8_96_array_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa6a34c86 != nil {
		return x.refa6a34c86, nil
	}
	mema6a34c86 := allocUint896ArrayTMemory(1)
	refa6a34c86 := (*C.uint8_96_array_t)(mema6a34c86)
	allocsa6a34c86 := new(cgoAllocMap)
	allocsa6a34c86.Add(mema6a34c86)

	var cidx_allocs *cgoAllocMap
	refa6a34c86.idx, cidx_allocs = *(*[96]C.uint8_t)(unsafe.Pointer(&x.Idx)), cgoAllocsUnknown
	allocsa6a34c86.Borrow(cidx_allocs)

	x.refa6a34c86 = refa6a34c86
	x.allocsa6a34c86 = allocsa6a34c86
	return refa6a34c86, allocsa6a34c86

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Uint896ArrayT) PassValue() (C.uint8_96_array_t, *cgoAllocMap) {
	if x.refa6a34c86 != nil {
		return *x.refa6a34c86, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Uint896ArrayT) Deref() {
	if x.refa6a34c86 == nil {
		return
	}
	x.Idx = *(*[96]Uint8T)(unsafe.Pointer(&x.refa6a34c86.idx))
}

// allocBLSDigestTMemory allocates memory for type C.BLSDigest_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBLSDigestTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBLSDigestTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBLSDigestTValue = unsafe.Sizeof([1]C.BLSDigest_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BLSDigestT) Ref() *C.BLSDigest_t {
	if x == nil {
		return nil
	}
	return x.ref9d19b2e1
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BLSDigestT) Free() {
	if x != nil && x.allocs9d19b2e1 != nil {
		x.allocs9d19b2e1.(*cgoAllocMap).Free()
		x.ref9d19b2e1 = nil
	}
}

// NewBLSDigestTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBLSDigestTRef(ref unsafe.Pointer) *BLSDigestT {
	if ref == nil {
		return nil
	}
	obj := new(BLSDigestT)
	obj.ref9d19b2e1 = (*C.BLSDigest_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BLSDigestT) PassRef() (*C.BLSDigest_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9d19b2e1 != nil {
		return x.ref9d19b2e1, nil
	}
	mem9d19b2e1 := allocBLSDigestTMemory(1)
	ref9d19b2e1 := (*C.BLSDigest_t)(mem9d19b2e1)
	allocs9d19b2e1 := new(cgoAllocMap)
	allocs9d19b2e1.Add(mem9d19b2e1)

	var cinner_allocs *cgoAllocMap
	ref9d19b2e1.inner, cinner_allocs = x.Inner.PassValue()
	allocs9d19b2e1.Borrow(cinner_allocs)

	x.ref9d19b2e1 = ref9d19b2e1
	x.allocs9d19b2e1 = allocs9d19b2e1
	return ref9d19b2e1, allocs9d19b2e1

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BLSDigestT) PassValue() (C.BLSDigest_t, *cgoAllocMap) {
	if x.ref9d19b2e1 != nil {
		return *x.ref9d19b2e1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BLSDigestT) Deref() {
	if x.ref9d19b2e1 == nil {
		return
	}
	x.Inner = *NewUint896ArrayTRef(unsafe.Pointer(&x.ref9d19b2e1.inner))
}

// allocHashResponseTMemory allocates memory for type C.HashResponse_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocHashResponseTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfHashResponseTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfHashResponseTValue = unsafe.Sizeof([1]C.HashResponse_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *HashResponseT) Ref() *C.HashResponse_t {
	if x == nil {
		return nil
	}
	return x.ref2e22e5c0
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *HashResponseT) Free() {
	if x != nil && x.allocs2e22e5c0 != nil {
		x.allocs2e22e5c0.(*cgoAllocMap).Free()
		x.ref2e22e5c0 = nil
	}
}

// NewHashResponseTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewHashResponseTRef(ref unsafe.Pointer) *HashResponseT {
	if ref == nil {
		return nil
	}
	obj := new(HashResponseT)
	obj.ref2e22e5c0 = (*C.HashResponse_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *HashResponseT) PassRef() (*C.HashResponse_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2e22e5c0 != nil {
		return x.ref2e22e5c0, nil
	}
	mem2e22e5c0 := allocHashResponseTMemory(1)
	ref2e22e5c0 := (*C.HashResponse_t)(mem2e22e5c0)
	allocs2e22e5c0 := new(cgoAllocMap)
	allocs2e22e5c0.Add(mem2e22e5c0)

	var cdigest_allocs *cgoAllocMap
	ref2e22e5c0.digest, cdigest_allocs = x.Digest.PassValue()
	allocs2e22e5c0.Borrow(cdigest_allocs)

	x.ref2e22e5c0 = ref2e22e5c0
	x.allocs2e22e5c0 = allocs2e22e5c0
	return ref2e22e5c0, allocs2e22e5c0

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x HashResponseT) PassValue() (C.HashResponse_t, *cgoAllocMap) {
	if x.ref2e22e5c0 != nil {
		return *x.ref2e22e5c0, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *HashResponseT) Deref() {
	if x.ref2e22e5c0 == nil {
		return
	}
	x.Digest = *NewBLSDigestTRef(unsafe.Pointer(&x.ref2e22e5c0.digest))
}

// allocBLSSignatureTMemory allocates memory for type C.BLSSignature_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBLSSignatureTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBLSSignatureTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBLSSignatureTValue = unsafe.Sizeof([1]C.BLSSignature_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BLSSignatureT) Ref() *C.BLSSignature_t {
	if x == nil {
		return nil
	}
	return x.ref4552d217
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BLSSignatureT) Free() {
	if x != nil && x.allocs4552d217 != nil {
		x.allocs4552d217.(*cgoAllocMap).Free()
		x.ref4552d217 = nil
	}
}

// NewBLSSignatureTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBLSSignatureTRef(ref unsafe.Pointer) *BLSSignatureT {
	if ref == nil {
		return nil
	}
	obj := new(BLSSignatureT)
	obj.ref4552d217 = (*C.BLSSignature_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BLSSignatureT) PassRef() (*C.BLSSignature_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4552d217 != nil {
		return x.ref4552d217, nil
	}
	mem4552d217 := allocBLSSignatureTMemory(1)
	ref4552d217 := (*C.BLSSignature_t)(mem4552d217)
	allocs4552d217 := new(cgoAllocMap)
	allocs4552d217.Add(mem4552d217)

	var cinner_allocs *cgoAllocMap
	ref4552d217.inner, cinner_allocs = x.Inner.PassValue()
	allocs4552d217.Borrow(cinner_allocs)

	x.ref4552d217 = ref4552d217
	x.allocs4552d217 = allocs4552d217
	return ref4552d217, allocs4552d217

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BLSSignatureT) PassValue() (C.BLSSignature_t, *cgoAllocMap) {
	if x.ref4552d217 != nil {
		return *x.ref4552d217, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BLSSignatureT) Deref() {
	if x.ref4552d217 == nil {
		return
	}
	x.Inner = *NewUint896ArrayTRef(unsafe.Pointer(&x.ref4552d217.inner))
}

// allocAggregateResponseTMemory allocates memory for type C.AggregateResponse_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAggregateResponseTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAggregateResponseTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfAggregateResponseTValue = unsafe.Sizeof([1]C.AggregateResponse_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *AggregateResponseT) Ref() *C.AggregateResponse_t {
	if x == nil {
		return nil
	}
	return x.refe76ad5dd
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *AggregateResponseT) Free() {
	if x != nil && x.allocse76ad5dd != nil {
		x.allocse76ad5dd.(*cgoAllocMap).Free()
		x.refe76ad5dd = nil
	}
}

// NewAggregateResponseTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAggregateResponseTRef(ref unsafe.Pointer) *AggregateResponseT {
	if ref == nil {
		return nil
	}
	obj := new(AggregateResponseT)
	obj.refe76ad5dd = (*C.AggregateResponse_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *AggregateResponseT) PassRef() (*C.AggregateResponse_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe76ad5dd != nil {
		return x.refe76ad5dd, nil
	}
	meme76ad5dd := allocAggregateResponseTMemory(1)
	refe76ad5dd := (*C.AggregateResponse_t)(meme76ad5dd)
	allocse76ad5dd := new(cgoAllocMap)
	allocse76ad5dd.Add(meme76ad5dd)

	var csignature_allocs *cgoAllocMap
	refe76ad5dd.signature, csignature_allocs = x.Signature.PassValue()
	allocse76ad5dd.Borrow(csignature_allocs)

	x.refe76ad5dd = refe76ad5dd
	x.allocse76ad5dd = allocse76ad5dd
	return refe76ad5dd, allocse76ad5dd

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x AggregateResponseT) PassValue() (C.AggregateResponse_t, *cgoAllocMap) {
	if x.refe76ad5dd != nil {
		return *x.refe76ad5dd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *AggregateResponseT) Deref() {
	if x.refe76ad5dd == nil {
		return
	}
	x.Signature = *NewBLSSignatureTRef(unsafe.Pointer(&x.refe76ad5dd.signature))
}

// allocArraySizeTMemory allocates memory for type C.Array_size_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocArraySizeTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfArraySizeTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfArraySizeTValue = unsafe.Sizeof([1]C.Array_size_t{})

// allocPSizeTMemory allocates memory for type *C.size_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPSizeTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPSizeTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPSizeTValue = unsafe.Sizeof([1]*C.size_t{})

// unpackSSUSizeT transforms a sliced Go data structure into plain C format.
func unpackSSUSizeT(x [][]SizeT) (unpacked **C.size_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPSizeTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.size_t)(unsafe.Pointer(h0))
	for i0 := range x {
		h := (*sliceHeader)(unsafe.Pointer(&x[i0]))
		v0[i0] = (*C.size_t)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.size_t)(h.Data)
	return
}

// packSSUSizeT reads sliced Go data structure out from plain C format.
func packSSUSizeT(v [][]SizeT, ptr0 **C.size_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.size_t)(unsafe.Pointer(ptr0)))[i0]
		hxf95e7c8 := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxf95e7c8.Data = unsafe.Pointer(ptr1)
		hxf95e7c8.Cap = 0x7fffffff
		// hxf95e7c8.Len = ?
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ArraySizeT) Ref() *C.Array_size_t {
	if x == nil {
		return nil
	}
	return x.ref903ad2bb
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ArraySizeT) Free() {
	if x != nil && x.allocs903ad2bb != nil {
		x.allocs903ad2bb.(*cgoAllocMap).Free()
		x.ref903ad2bb = nil
	}
}

// NewArraySizeTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewArraySizeTRef(ref unsafe.Pointer) *ArraySizeT {
	if ref == nil {
		return nil
	}
	obj := new(ArraySizeT)
	obj.ref903ad2bb = (*C.Array_size_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ArraySizeT) PassRef() (*C.Array_size_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref903ad2bb != nil {
		return x.ref903ad2bb, nil
	}
	mem903ad2bb := allocArraySizeTMemory(1)
	ref903ad2bb := (*C.Array_size_t)(mem903ad2bb)
	allocs903ad2bb := new(cgoAllocMap)
	allocs903ad2bb.Add(mem903ad2bb)

	var cptr_allocs *cgoAllocMap
	ref903ad2bb.ptr, cptr_allocs = unpackSSUSizeT(x.Ptr)
	allocs903ad2bb.Borrow(cptr_allocs)

	var clen_allocs *cgoAllocMap
	ref903ad2bb.len, clen_allocs = (C.size_t)(x.Len), cgoAllocsUnknown
	allocs903ad2bb.Borrow(clen_allocs)

	x.ref903ad2bb = ref903ad2bb
	x.allocs903ad2bb = allocs903ad2bb
	return ref903ad2bb, allocs903ad2bb

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ArraySizeT) PassValue() (C.Array_size_t, *cgoAllocMap) {
	if x.ref903ad2bb != nil {
		return *x.ref903ad2bb, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ArraySizeT) Deref() {
	if x.ref903ad2bb == nil {
		return
	}
	packSSUSizeT(x.Ptr, x.ref903ad2bb.ptr)
	x.Len = (SizeT)(x.ref903ad2bb.len)
}

// allocUint832ArrayTMemory allocates memory for type C.uint8_32_array_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUint832ArrayTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUint832ArrayTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfUint832ArrayTValue = unsafe.Sizeof([1]C.uint8_32_array_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Uint832ArrayT) Ref() *C.uint8_32_array_t {
	if x == nil {
		return nil
	}
	return x.refec6d8d43
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Uint832ArrayT) Free() {
	if x != nil && x.allocsec6d8d43 != nil {
		x.allocsec6d8d43.(*cgoAllocMap).Free()
		x.refec6d8d43 = nil
	}
}

// NewUint832ArrayTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewUint832ArrayTRef(ref unsafe.Pointer) *Uint832ArrayT {
	if ref == nil {
		return nil
	}
	obj := new(Uint832ArrayT)
	obj.refec6d8d43 = (*C.uint8_32_array_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Uint832ArrayT) PassRef() (*C.uint8_32_array_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refec6d8d43 != nil {
		return x.refec6d8d43, nil
	}
	memec6d8d43 := allocUint832ArrayTMemory(1)
	refec6d8d43 := (*C.uint8_32_array_t)(memec6d8d43)
	allocsec6d8d43 := new(cgoAllocMap)
	allocsec6d8d43.Add(memec6d8d43)

	var cidx_allocs *cgoAllocMap
	refec6d8d43.idx, cidx_allocs = *(*[32]C.uint8_t)(unsafe.Pointer(&x.Idx)), cgoAllocsUnknown
	allocsec6d8d43.Borrow(cidx_allocs)

	x.refec6d8d43 = refec6d8d43
	x.allocsec6d8d43 = allocsec6d8d43
	return refec6d8d43, allocsec6d8d43

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Uint832ArrayT) PassValue() (C.uint8_32_array_t, *cgoAllocMap) {
	if x.refec6d8d43 != nil {
		return *x.refec6d8d43, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Uint832ArrayT) Deref() {
	if x.refec6d8d43 == nil {
		return
	}
	x.Idx = *(*[32]Uint8T)(unsafe.Pointer(&x.refec6d8d43.idx))
}

// allocBLSPrivateKeyTMemory allocates memory for type C.BLSPrivateKey_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBLSPrivateKeyTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBLSPrivateKeyTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBLSPrivateKeyTValue = unsafe.Sizeof([1]C.BLSPrivateKey_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BLSPrivateKeyT) Ref() *C.BLSPrivateKey_t {
	if x == nil {
		return nil
	}
	return x.ref1033d34f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BLSPrivateKeyT) Free() {
	if x != nil && x.allocs1033d34f != nil {
		x.allocs1033d34f.(*cgoAllocMap).Free()
		x.ref1033d34f = nil
	}
}

// NewBLSPrivateKeyTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBLSPrivateKeyTRef(ref unsafe.Pointer) *BLSPrivateKeyT {
	if ref == nil {
		return nil
	}
	obj := new(BLSPrivateKeyT)
	obj.ref1033d34f = (*C.BLSPrivateKey_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BLSPrivateKeyT) PassRef() (*C.BLSPrivateKey_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1033d34f != nil {
		return x.ref1033d34f, nil
	}
	mem1033d34f := allocBLSPrivateKeyTMemory(1)
	ref1033d34f := (*C.BLSPrivateKey_t)(mem1033d34f)
	allocs1033d34f := new(cgoAllocMap)
	allocs1033d34f.Add(mem1033d34f)

	var cinner_allocs *cgoAllocMap
	ref1033d34f.inner, cinner_allocs = x.Inner.PassValue()
	allocs1033d34f.Borrow(cinner_allocs)

	x.ref1033d34f = ref1033d34f
	x.allocs1033d34f = allocs1033d34f
	return ref1033d34f, allocs1033d34f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BLSPrivateKeyT) PassValue() (C.BLSPrivateKey_t, *cgoAllocMap) {
	if x.ref1033d34f != nil {
		return *x.ref1033d34f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BLSPrivateKeyT) Deref() {
	if x.ref1033d34f == nil {
		return
	}
	x.Inner = *NewUint832ArrayTRef(unsafe.Pointer(&x.ref1033d34f.inner))
}

// allocPrivateKeyGenerateResponseTMemory allocates memory for type C.PrivateKeyGenerateResponse_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPrivateKeyGenerateResponseTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPrivateKeyGenerateResponseTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPrivateKeyGenerateResponseTValue = unsafe.Sizeof([1]C.PrivateKeyGenerateResponse_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PrivateKeyGenerateResponseT) Ref() *C.PrivateKeyGenerateResponse_t {
	if x == nil {
		return nil
	}
	return x.ref791c6bf1
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PrivateKeyGenerateResponseT) Free() {
	if x != nil && x.allocs791c6bf1 != nil {
		x.allocs791c6bf1.(*cgoAllocMap).Free()
		x.ref791c6bf1 = nil
	}
}

// NewPrivateKeyGenerateResponseTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPrivateKeyGenerateResponseTRef(ref unsafe.Pointer) *PrivateKeyGenerateResponseT {
	if ref == nil {
		return nil
	}
	obj := new(PrivateKeyGenerateResponseT)
	obj.ref791c6bf1 = (*C.PrivateKeyGenerateResponse_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PrivateKeyGenerateResponseT) PassRef() (*C.PrivateKeyGenerateResponse_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref791c6bf1 != nil {
		return x.ref791c6bf1, nil
	}
	mem791c6bf1 := allocPrivateKeyGenerateResponseTMemory(1)
	ref791c6bf1 := (*C.PrivateKeyGenerateResponse_t)(mem791c6bf1)
	allocs791c6bf1 := new(cgoAllocMap)
	allocs791c6bf1.Add(mem791c6bf1)

	var cprivate_key_allocs *cgoAllocMap
	ref791c6bf1.private_key, cprivate_key_allocs = x.PrivateKey.PassValue()
	allocs791c6bf1.Borrow(cprivate_key_allocs)

	x.ref791c6bf1 = ref791c6bf1
	x.allocs791c6bf1 = allocs791c6bf1
	return ref791c6bf1, allocs791c6bf1

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PrivateKeyGenerateResponseT) PassValue() (C.PrivateKeyGenerateResponse_t, *cgoAllocMap) {
	if x.ref791c6bf1 != nil {
		return *x.ref791c6bf1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PrivateKeyGenerateResponseT) Deref() {
	if x.ref791c6bf1 == nil {
		return
	}
	x.PrivateKey = *NewBLSPrivateKeyTRef(unsafe.Pointer(&x.ref791c6bf1.private_key))
}

// allocByteArray32TMemory allocates memory for type C.ByteArray32_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocByteArray32TMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfByteArray32TValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfByteArray32TValue = unsafe.Sizeof([1]C.ByteArray32_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ByteArray32T) Ref() *C.ByteArray32_t {
	if x == nil {
		return nil
	}
	return x.refd648bba7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ByteArray32T) Free() {
	if x != nil && x.allocsd648bba7 != nil {
		x.allocsd648bba7.(*cgoAllocMap).Free()
		x.refd648bba7 = nil
	}
}

// NewByteArray32TRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewByteArray32TRef(ref unsafe.Pointer) *ByteArray32T {
	if ref == nil {
		return nil
	}
	obj := new(ByteArray32T)
	obj.refd648bba7 = (*C.ByteArray32_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ByteArray32T) PassRef() (*C.ByteArray32_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd648bba7 != nil {
		return x.refd648bba7, nil
	}
	memd648bba7 := allocByteArray32TMemory(1)
	refd648bba7 := (*C.ByteArray32_t)(memd648bba7)
	allocsd648bba7 := new(cgoAllocMap)
	allocsd648bba7.Add(memd648bba7)

	var cinner_allocs *cgoAllocMap
	refd648bba7.inner, cinner_allocs = x.Inner.PassValue()
	allocsd648bba7.Borrow(cinner_allocs)

	x.refd648bba7 = refd648bba7
	x.allocsd648bba7 = allocsd648bba7
	return refd648bba7, allocsd648bba7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ByteArray32T) PassValue() (C.ByteArray32_t, *cgoAllocMap) {
	if x.refd648bba7 != nil {
		return *x.refd648bba7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ByteArray32T) Deref() {
	if x.refd648bba7 == nil {
		return
	}
	x.Inner = *NewUint832ArrayTRef(unsafe.Pointer(&x.refd648bba7.inner))
}

// allocPrivateKeySignResponseTMemory allocates memory for type C.PrivateKeySignResponse_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPrivateKeySignResponseTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPrivateKeySignResponseTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPrivateKeySignResponseTValue = unsafe.Sizeof([1]C.PrivateKeySignResponse_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PrivateKeySignResponseT) Ref() *C.PrivateKeySignResponse_t {
	if x == nil {
		return nil
	}
	return x.ref4b42f5cd
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PrivateKeySignResponseT) Free() {
	if x != nil && x.allocs4b42f5cd != nil {
		x.allocs4b42f5cd.(*cgoAllocMap).Free()
		x.ref4b42f5cd = nil
	}
}

// NewPrivateKeySignResponseTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPrivateKeySignResponseTRef(ref unsafe.Pointer) *PrivateKeySignResponseT {
	if ref == nil {
		return nil
	}
	obj := new(PrivateKeySignResponseT)
	obj.ref4b42f5cd = (*C.PrivateKeySignResponse_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PrivateKeySignResponseT) PassRef() (*C.PrivateKeySignResponse_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4b42f5cd != nil {
		return x.ref4b42f5cd, nil
	}
	mem4b42f5cd := allocPrivateKeySignResponseTMemory(1)
	ref4b42f5cd := (*C.PrivateKeySignResponse_t)(mem4b42f5cd)
	allocs4b42f5cd := new(cgoAllocMap)
	allocs4b42f5cd.Add(mem4b42f5cd)

	var csignature_allocs *cgoAllocMap
	ref4b42f5cd.signature, csignature_allocs = x.Signature.PassValue()
	allocs4b42f5cd.Borrow(csignature_allocs)

	x.ref4b42f5cd = ref4b42f5cd
	x.allocs4b42f5cd = allocs4b42f5cd
	return ref4b42f5cd, allocs4b42f5cd

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PrivateKeySignResponseT) PassValue() (C.PrivateKeySignResponse_t, *cgoAllocMap) {
	if x.ref4b42f5cd != nil {
		return *x.ref4b42f5cd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PrivateKeySignResponseT) Deref() {
	if x.ref4b42f5cd == nil {
		return
	}
	x.Signature = *NewBLSSignatureTRef(unsafe.Pointer(&x.ref4b42f5cd.signature))
}

// allocUint848ArrayTMemory allocates memory for type C.uint8_48_array_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUint848ArrayTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUint848ArrayTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfUint848ArrayTValue = unsafe.Sizeof([1]C.uint8_48_array_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Uint848ArrayT) Ref() *C.uint8_48_array_t {
	if x == nil {
		return nil
	}
	return x.ref9b9f1ca4
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Uint848ArrayT) Free() {
	if x != nil && x.allocs9b9f1ca4 != nil {
		x.allocs9b9f1ca4.(*cgoAllocMap).Free()
		x.ref9b9f1ca4 = nil
	}
}

// NewUint848ArrayTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewUint848ArrayTRef(ref unsafe.Pointer) *Uint848ArrayT {
	if ref == nil {
		return nil
	}
	obj := new(Uint848ArrayT)
	obj.ref9b9f1ca4 = (*C.uint8_48_array_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Uint848ArrayT) PassRef() (*C.uint8_48_array_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9b9f1ca4 != nil {
		return x.ref9b9f1ca4, nil
	}
	mem9b9f1ca4 := allocUint848ArrayTMemory(1)
	ref9b9f1ca4 := (*C.uint8_48_array_t)(mem9b9f1ca4)
	allocs9b9f1ca4 := new(cgoAllocMap)
	allocs9b9f1ca4.Add(mem9b9f1ca4)

	var cidx_allocs *cgoAllocMap
	ref9b9f1ca4.idx, cidx_allocs = *(*[48]C.uint8_t)(unsafe.Pointer(&x.Idx)), cgoAllocsUnknown
	allocs9b9f1ca4.Borrow(cidx_allocs)

	x.ref9b9f1ca4 = ref9b9f1ca4
	x.allocs9b9f1ca4 = allocs9b9f1ca4
	return ref9b9f1ca4, allocs9b9f1ca4

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Uint848ArrayT) PassValue() (C.uint8_48_array_t, *cgoAllocMap) {
	if x.ref9b9f1ca4 != nil {
		return *x.ref9b9f1ca4, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Uint848ArrayT) Deref() {
	if x.ref9b9f1ca4 == nil {
		return
	}
	x.Idx = *(*[48]Uint8T)(unsafe.Pointer(&x.ref9b9f1ca4.idx))
}

// allocBLSPublicKeyTMemory allocates memory for type C.BLSPublicKey_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBLSPublicKeyTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBLSPublicKeyTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBLSPublicKeyTValue = unsafe.Sizeof([1]C.BLSPublicKey_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BLSPublicKeyT) Ref() *C.BLSPublicKey_t {
	if x == nil {
		return nil
	}
	return x.ref24fd8d3
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BLSPublicKeyT) Free() {
	if x != nil && x.allocs24fd8d3 != nil {
		x.allocs24fd8d3.(*cgoAllocMap).Free()
		x.ref24fd8d3 = nil
	}
}

// NewBLSPublicKeyTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBLSPublicKeyTRef(ref unsafe.Pointer) *BLSPublicKeyT {
	if ref == nil {
		return nil
	}
	obj := new(BLSPublicKeyT)
	obj.ref24fd8d3 = (*C.BLSPublicKey_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BLSPublicKeyT) PassRef() (*C.BLSPublicKey_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref24fd8d3 != nil {
		return x.ref24fd8d3, nil
	}
	mem24fd8d3 := allocBLSPublicKeyTMemory(1)
	ref24fd8d3 := (*C.BLSPublicKey_t)(mem24fd8d3)
	allocs24fd8d3 := new(cgoAllocMap)
	allocs24fd8d3.Add(mem24fd8d3)

	var cinner_allocs *cgoAllocMap
	ref24fd8d3.inner, cinner_allocs = x.Inner.PassValue()
	allocs24fd8d3.Borrow(cinner_allocs)

	x.ref24fd8d3 = ref24fd8d3
	x.allocs24fd8d3 = allocs24fd8d3
	return ref24fd8d3, allocs24fd8d3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BLSPublicKeyT) PassValue() (C.BLSPublicKey_t, *cgoAllocMap) {
	if x.ref24fd8d3 != nil {
		return *x.ref24fd8d3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BLSPublicKeyT) Deref() {
	if x.ref24fd8d3 == nil {
		return
	}
	x.Inner = *NewUint848ArrayTRef(unsafe.Pointer(&x.ref24fd8d3.inner))
}

// allocPrivateKeyPublicKeyResponseTMemory allocates memory for type C.PrivateKeyPublicKeyResponse_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPrivateKeyPublicKeyResponseTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPrivateKeyPublicKeyResponseTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPrivateKeyPublicKeyResponseTValue = unsafe.Sizeof([1]C.PrivateKeyPublicKeyResponse_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PrivateKeyPublicKeyResponseT) Ref() *C.PrivateKeyPublicKeyResponse_t {
	if x == nil {
		return nil
	}
	return x.refbd679f8e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PrivateKeyPublicKeyResponseT) Free() {
	if x != nil && x.allocsbd679f8e != nil {
		x.allocsbd679f8e.(*cgoAllocMap).Free()
		x.refbd679f8e = nil
	}
}

// NewPrivateKeyPublicKeyResponseTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPrivateKeyPublicKeyResponseTRef(ref unsafe.Pointer) *PrivateKeyPublicKeyResponseT {
	if ref == nil {
		return nil
	}
	obj := new(PrivateKeyPublicKeyResponseT)
	obj.refbd679f8e = (*C.PrivateKeyPublicKeyResponse_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PrivateKeyPublicKeyResponseT) PassRef() (*C.PrivateKeyPublicKeyResponse_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refbd679f8e != nil {
		return x.refbd679f8e, nil
	}
	membd679f8e := allocPrivateKeyPublicKeyResponseTMemory(1)
	refbd679f8e := (*C.PrivateKeyPublicKeyResponse_t)(membd679f8e)
	allocsbd679f8e := new(cgoAllocMap)
	allocsbd679f8e.Add(membd679f8e)

	var cpublic_key_allocs *cgoAllocMap
	refbd679f8e.public_key, cpublic_key_allocs = x.PublicKey.PassValue()
	allocsbd679f8e.Borrow(cpublic_key_allocs)

	x.refbd679f8e = refbd679f8e
	x.allocsbd679f8e = allocsbd679f8e
	return refbd679f8e, allocsbd679f8e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PrivateKeyPublicKeyResponseT) PassValue() (C.PrivateKeyPublicKeyResponse_t, *cgoAllocMap) {
	if x.refbd679f8e != nil {
		return *x.refbd679f8e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PrivateKeyPublicKeyResponseT) Deref() {
	if x.refbd679f8e == nil {
		return
	}
	x.PublicKey = *NewBLSPublicKeyTRef(unsafe.Pointer(&x.refbd679f8e.public_key))
}

// allocZeroSignatureResponseTMemory allocates memory for type C.ZeroSignatureResponse_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocZeroSignatureResponseTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfZeroSignatureResponseTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfZeroSignatureResponseTValue = unsafe.Sizeof([1]C.ZeroSignatureResponse_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ZeroSignatureResponseT) Ref() *C.ZeroSignatureResponse_t {
	if x == nil {
		return nil
	}
	return x.ref46d5d59
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ZeroSignatureResponseT) Free() {
	if x != nil && x.allocs46d5d59 != nil {
		x.allocs46d5d59.(*cgoAllocMap).Free()
		x.ref46d5d59 = nil
	}
}

// NewZeroSignatureResponseTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewZeroSignatureResponseTRef(ref unsafe.Pointer) *ZeroSignatureResponseT {
	if ref == nil {
		return nil
	}
	obj := new(ZeroSignatureResponseT)
	obj.ref46d5d59 = (*C.ZeroSignatureResponse_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ZeroSignatureResponseT) PassRef() (*C.ZeroSignatureResponse_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref46d5d59 != nil {
		return x.ref46d5d59, nil
	}
	mem46d5d59 := allocZeroSignatureResponseTMemory(1)
	ref46d5d59 := (*C.ZeroSignatureResponse_t)(mem46d5d59)
	allocs46d5d59 := new(cgoAllocMap)
	allocs46d5d59.Add(mem46d5d59)

	var csignature_allocs *cgoAllocMap
	ref46d5d59.signature, csignature_allocs = x.Signature.PassValue()
	allocs46d5d59.Borrow(csignature_allocs)

	x.ref46d5d59 = ref46d5d59
	x.allocs46d5d59 = allocs46d5d59
	return ref46d5d59, allocs46d5d59

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ZeroSignatureResponseT) PassValue() (C.ZeroSignatureResponse_t, *cgoAllocMap) {
	if x.ref46d5d59 != nil {
		return *x.ref46d5d59, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ZeroSignatureResponseT) Deref() {
	if x.ref46d5d59 == nil {
		return
	}
	x.Signature = *NewBLSSignatureTRef(unsafe.Pointer(&x.ref46d5d59.signature))
}

// allocArrayUint64TMemory allocates memory for type C.Array_uint64_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocArrayUint64TMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfArrayUint64TValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfArrayUint64TValue = unsafe.Sizeof([1]C.Array_uint64_t{})

// allocPUint64TMemory allocates memory for type *C.uint64_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPUint64TMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPUint64TValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPUint64TValue = unsafe.Sizeof([1]*C.uint64_t{})

// unpackSSUUint64T transforms a sliced Go data structure into plain C format.
func unpackSSUUint64T(x [][]Uint64T) (unpacked **C.uint64_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPUint64TMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.uint64_t)(unsafe.Pointer(h0))
	for i0 := range x {
		h := (*sliceHeader)(unsafe.Pointer(&x[i0]))
		v0[i0] = (*C.uint64_t)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.uint64_t)(h.Data)
	return
}

// packSSUUint64T reads sliced Go data structure out from plain C format.
func packSSUUint64T(v [][]Uint64T, ptr0 **C.uint64_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.uint64_t)(unsafe.Pointer(ptr0)))[i0]
		hxff2234b := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxff2234b.Data = unsafe.Pointer(ptr1)
		hxff2234b.Cap = 0x7fffffff
		// hxff2234b.Len = ?
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ArrayUint64T) Ref() *C.Array_uint64_t {
	if x == nil {
		return nil
	}
	return x.ref71627081
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ArrayUint64T) Free() {
	if x != nil && x.allocs71627081 != nil {
		x.allocs71627081.(*cgoAllocMap).Free()
		x.ref71627081 = nil
	}
}

// NewArrayUint64TRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewArrayUint64TRef(ref unsafe.Pointer) *ArrayUint64T {
	if ref == nil {
		return nil
	}
	obj := new(ArrayUint64T)
	obj.ref71627081 = (*C.Array_uint64_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ArrayUint64T) PassRef() (*C.Array_uint64_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref71627081 != nil {
		return x.ref71627081, nil
	}
	mem71627081 := allocArrayUint64TMemory(1)
	ref71627081 := (*C.Array_uint64_t)(mem71627081)
	allocs71627081 := new(cgoAllocMap)
	allocs71627081.Add(mem71627081)

	var cptr_allocs *cgoAllocMap
	ref71627081.ptr, cptr_allocs = unpackSSUUint64T(x.Ptr)
	allocs71627081.Borrow(cptr_allocs)

	var clen_allocs *cgoAllocMap
	ref71627081.len, clen_allocs = (C.size_t)(x.Len), cgoAllocsUnknown
	allocs71627081.Borrow(clen_allocs)

	x.ref71627081 = ref71627081
	x.allocs71627081 = allocs71627081
	return ref71627081, allocs71627081

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ArrayUint64T) PassValue() (C.Array_uint64_t, *cgoAllocMap) {
	if x.ref71627081 != nil {
		return *x.ref71627081, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ArrayUint64T) Deref() {
	if x.ref71627081 == nil {
		return
	}
	packSSUUint64T(x.Ptr, x.ref71627081.ptr)
	x.Len = (SizeT)(x.ref71627081.len)
}

// allocWriteWithAlignmentTMemory allocates memory for type C.WriteWithAlignment_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocWriteWithAlignmentTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfWriteWithAlignmentTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfWriteWithAlignmentTValue = unsafe.Sizeof([1]C.WriteWithAlignment_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *WriteWithAlignmentT) Ref() *C.WriteWithAlignment_t {
	if x == nil {
		return nil
	}
	return x.ref3531b450
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *WriteWithAlignmentT) Free() {
	if x != nil && x.allocs3531b450 != nil {
		x.allocs3531b450.(*cgoAllocMap).Free()
		x.ref3531b450 = nil
	}
}

// NewWriteWithAlignmentTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewWriteWithAlignmentTRef(ref unsafe.Pointer) *WriteWithAlignmentT {
	if ref == nil {
		return nil
	}
	obj := new(WriteWithAlignmentT)
	obj.ref3531b450 = (*C.WriteWithAlignment_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *WriteWithAlignmentT) PassRef() (*C.WriteWithAlignment_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3531b450 != nil {
		return x.ref3531b450, nil
	}
	mem3531b450 := allocWriteWithAlignmentTMemory(1)
	ref3531b450 := (*C.WriteWithAlignment_t)(mem3531b450)
	allocs3531b450 := new(cgoAllocMap)
	allocs3531b450.Add(mem3531b450)

	var ccomm_p_allocs *cgoAllocMap
	ref3531b450.comm_p, ccomm_p_allocs = x.CommP.PassValue()
	allocs3531b450.Borrow(ccomm_p_allocs)

	var cleft_alignment_unpadded_allocs *cgoAllocMap
	ref3531b450.left_alignment_unpadded, cleft_alignment_unpadded_allocs = (C.uint64_t)(x.LeftAlignmentUnpadded), cgoAllocsUnknown
	allocs3531b450.Borrow(cleft_alignment_unpadded_allocs)

	var ctotal_write_unpadded_allocs *cgoAllocMap
	ref3531b450.total_write_unpadded, ctotal_write_unpadded_allocs = (C.uint64_t)(x.TotalWriteUnpadded), cgoAllocsUnknown
	allocs3531b450.Borrow(ctotal_write_unpadded_allocs)

	x.ref3531b450 = ref3531b450
	x.allocs3531b450 = allocs3531b450
	return ref3531b450, allocs3531b450

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x WriteWithAlignmentT) PassValue() (C.WriteWithAlignment_t, *cgoAllocMap) {
	if x.ref3531b450 != nil {
		return *x.ref3531b450, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *WriteWithAlignmentT) Deref() {
	if x.ref3531b450 == nil {
		return
	}
	x.CommP = *NewUint832ArrayTRef(unsafe.Pointer(&x.ref3531b450.comm_p))
	x.LeftAlignmentUnpadded = (Uint64T)(x.ref3531b450.left_alignment_unpadded)
	x.TotalWriteUnpadded = (Uint64T)(x.ref3531b450.total_write_unpadded)
}

// allocResultWriteWithAlignmentTMemory allocates memory for type C.Result_WriteWithAlignment_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocResultWriteWithAlignmentTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfResultWriteWithAlignmentTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfResultWriteWithAlignmentTValue = unsafe.Sizeof([1]C.Result_WriteWithAlignment_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ResultWriteWithAlignmentT) Ref() *C.Result_WriteWithAlignment_t {
	if x == nil {
		return nil
	}
	return x.refed31278e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ResultWriteWithAlignmentT) Free() {
	if x != nil && x.allocsed31278e != nil {
		x.allocsed31278e.(*cgoAllocMap).Free()
		x.refed31278e = nil
	}
}

// NewResultWriteWithAlignmentTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewResultWriteWithAlignmentTRef(ref unsafe.Pointer) *ResultWriteWithAlignmentT {
	if ref == nil {
		return nil
	}
	obj := new(ResultWriteWithAlignmentT)
	obj.refed31278e = (*C.Result_WriteWithAlignment_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ResultWriteWithAlignmentT) PassRef() (*C.Result_WriteWithAlignment_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refed31278e != nil {
		return x.refed31278e, nil
	}
	memed31278e := allocResultWriteWithAlignmentTMemory(1)
	refed31278e := (*C.Result_WriteWithAlignment_t)(memed31278e)
	allocsed31278e := new(cgoAllocMap)
	allocsed31278e.Add(memed31278e)

	var cstatus_code_allocs *cgoAllocMap
	refed31278e.status_code, cstatus_code_allocs = (C.FCPResponseStatus_t)(x.StatusCode), cgoAllocsUnknown
	allocsed31278e.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	refed31278e.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocsed31278e.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	refed31278e.value, cvalue_allocs = x.Value.PassValue()
	allocsed31278e.Borrow(cvalue_allocs)

	x.refed31278e = refed31278e
	x.allocsed31278e = allocsed31278e
	return refed31278e, allocsed31278e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ResultWriteWithAlignmentT) PassValue() (C.Result_WriteWithAlignment_t, *cgoAllocMap) {
	if x.refed31278e != nil {
		return *x.refed31278e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ResultWriteWithAlignmentT) Deref() {
	if x.refed31278e == nil {
		return
	}
	x.StatusCode = (FCPResponseStatusT)(x.refed31278e.status_code)
	x.ErrorMsg = *NewArrayUint8TRef(unsafe.Pointer(&x.refed31278e.error_msg))
	x.Value = *NewWriteWithAlignmentTRef(unsafe.Pointer(&x.refed31278e.value))
}

// allocWriteWithoutAlignmentTMemory allocates memory for type C.WriteWithoutAlignment_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocWriteWithoutAlignmentTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfWriteWithoutAlignmentTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfWriteWithoutAlignmentTValue = unsafe.Sizeof([1]C.WriteWithoutAlignment_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *WriteWithoutAlignmentT) Ref() *C.WriteWithoutAlignment_t {
	if x == nil {
		return nil
	}
	return x.ref591a420c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *WriteWithoutAlignmentT) Free() {
	if x != nil && x.allocs591a420c != nil {
		x.allocs591a420c.(*cgoAllocMap).Free()
		x.ref591a420c = nil
	}
}

// NewWriteWithoutAlignmentTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewWriteWithoutAlignmentTRef(ref unsafe.Pointer) *WriteWithoutAlignmentT {
	if ref == nil {
		return nil
	}
	obj := new(WriteWithoutAlignmentT)
	obj.ref591a420c = (*C.WriteWithoutAlignment_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *WriteWithoutAlignmentT) PassRef() (*C.WriteWithoutAlignment_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref591a420c != nil {
		return x.ref591a420c, nil
	}
	mem591a420c := allocWriteWithoutAlignmentTMemory(1)
	ref591a420c := (*C.WriteWithoutAlignment_t)(mem591a420c)
	allocs591a420c := new(cgoAllocMap)
	allocs591a420c.Add(mem591a420c)

	var ccomm_p_allocs *cgoAllocMap
	ref591a420c.comm_p, ccomm_p_allocs = x.CommP.PassValue()
	allocs591a420c.Borrow(ccomm_p_allocs)

	var ctotal_write_unpadded_allocs *cgoAllocMap
	ref591a420c.total_write_unpadded, ctotal_write_unpadded_allocs = (C.uint64_t)(x.TotalWriteUnpadded), cgoAllocsUnknown
	allocs591a420c.Borrow(ctotal_write_unpadded_allocs)

	x.ref591a420c = ref591a420c
	x.allocs591a420c = allocs591a420c
	return ref591a420c, allocs591a420c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x WriteWithoutAlignmentT) PassValue() (C.WriteWithoutAlignment_t, *cgoAllocMap) {
	if x.ref591a420c != nil {
		return *x.ref591a420c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *WriteWithoutAlignmentT) Deref() {
	if x.ref591a420c == nil {
		return
	}
	x.CommP = *NewUint832ArrayTRef(unsafe.Pointer(&x.ref591a420c.comm_p))
	x.TotalWriteUnpadded = (Uint64T)(x.ref591a420c.total_write_unpadded)
}

// allocResultWriteWithoutAlignmentTMemory allocates memory for type C.Result_WriteWithoutAlignment_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocResultWriteWithoutAlignmentTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfResultWriteWithoutAlignmentTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfResultWriteWithoutAlignmentTValue = unsafe.Sizeof([1]C.Result_WriteWithoutAlignment_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ResultWriteWithoutAlignmentT) Ref() *C.Result_WriteWithoutAlignment_t {
	if x == nil {
		return nil
	}
	return x.ref84618337
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ResultWriteWithoutAlignmentT) Free() {
	if x != nil && x.allocs84618337 != nil {
		x.allocs84618337.(*cgoAllocMap).Free()
		x.ref84618337 = nil
	}
}

// NewResultWriteWithoutAlignmentTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewResultWriteWithoutAlignmentTRef(ref unsafe.Pointer) *ResultWriteWithoutAlignmentT {
	if ref == nil {
		return nil
	}
	obj := new(ResultWriteWithoutAlignmentT)
	obj.ref84618337 = (*C.Result_WriteWithoutAlignment_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ResultWriteWithoutAlignmentT) PassRef() (*C.Result_WriteWithoutAlignment_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref84618337 != nil {
		return x.ref84618337, nil
	}
	mem84618337 := allocResultWriteWithoutAlignmentTMemory(1)
	ref84618337 := (*C.Result_WriteWithoutAlignment_t)(mem84618337)
	allocs84618337 := new(cgoAllocMap)
	allocs84618337.Add(mem84618337)

	var cstatus_code_allocs *cgoAllocMap
	ref84618337.status_code, cstatus_code_allocs = (C.FCPResponseStatus_t)(x.StatusCode), cgoAllocsUnknown
	allocs84618337.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref84618337.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocs84618337.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	ref84618337.value, cvalue_allocs = x.Value.PassValue()
	allocs84618337.Borrow(cvalue_allocs)

	x.ref84618337 = ref84618337
	x.allocs84618337 = allocs84618337
	return ref84618337, allocs84618337

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ResultWriteWithoutAlignmentT) PassValue() (C.Result_WriteWithoutAlignment_t, *cgoAllocMap) {
	if x.ref84618337 != nil {
		return *x.ref84618337, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ResultWriteWithoutAlignmentT) Deref() {
	if x.ref84618337 == nil {
		return
	}
	x.StatusCode = (FCPResponseStatusT)(x.ref84618337.status_code)
	x.ErrorMsg = *NewArrayUint8TRef(unsafe.Pointer(&x.ref84618337.error_msg))
	x.Value = *NewWriteWithoutAlignmentTRef(unsafe.Pointer(&x.ref84618337.value))
}

// allocResultByteArray32TMemory allocates memory for type C.Result_ByteArray32_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocResultByteArray32TMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfResultByteArray32TValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfResultByteArray32TValue = unsafe.Sizeof([1]C.Result_ByteArray32_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ResultByteArray32T) Ref() *C.Result_ByteArray32_t {
	if x == nil {
		return nil
	}
	return x.ref4c37f9af
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ResultByteArray32T) Free() {
	if x != nil && x.allocs4c37f9af != nil {
		x.allocs4c37f9af.(*cgoAllocMap).Free()
		x.ref4c37f9af = nil
	}
}

// NewResultByteArray32TRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewResultByteArray32TRef(ref unsafe.Pointer) *ResultByteArray32T {
	if ref == nil {
		return nil
	}
	obj := new(ResultByteArray32T)
	obj.ref4c37f9af = (*C.Result_ByteArray32_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ResultByteArray32T) PassRef() (*C.Result_ByteArray32_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4c37f9af != nil {
		return x.ref4c37f9af, nil
	}
	mem4c37f9af := allocResultByteArray32TMemory(1)
	ref4c37f9af := (*C.Result_ByteArray32_t)(mem4c37f9af)
	allocs4c37f9af := new(cgoAllocMap)
	allocs4c37f9af.Add(mem4c37f9af)

	var cstatus_code_allocs *cgoAllocMap
	ref4c37f9af.status_code, cstatus_code_allocs = (C.FCPResponseStatus_t)(x.StatusCode), cgoAllocsUnknown
	allocs4c37f9af.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref4c37f9af.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocs4c37f9af.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	ref4c37f9af.value, cvalue_allocs = x.Value.PassValue()
	allocs4c37f9af.Borrow(cvalue_allocs)

	x.ref4c37f9af = ref4c37f9af
	x.allocs4c37f9af = allocs4c37f9af
	return ref4c37f9af, allocs4c37f9af

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ResultByteArray32T) PassValue() (C.Result_ByteArray32_t, *cgoAllocMap) {
	if x.ref4c37f9af != nil {
		return *x.ref4c37f9af, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ResultByteArray32T) Deref() {
	if x.ref4c37f9af == nil {
		return
	}
	x.StatusCode = (FCPResponseStatusT)(x.ref4c37f9af.status_code)
	x.ErrorMsg = *NewArrayUint8TRef(unsafe.Pointer(&x.ref4c37f9af.error_msg))
	x.Value = *NewByteArray32TRef(unsafe.Pointer(&x.ref4c37f9af.value))
}

// allocPublicPieceInfoTMemory allocates memory for type C.PublicPieceInfo_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPublicPieceInfoTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPublicPieceInfoTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPublicPieceInfoTValue = unsafe.Sizeof([1]C.PublicPieceInfo_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PublicPieceInfoT) Ref() *C.PublicPieceInfo_t {
	if x == nil {
		return nil
	}
	return x.ref41775798
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PublicPieceInfoT) Free() {
	if x != nil && x.allocs41775798 != nil {
		x.allocs41775798.(*cgoAllocMap).Free()
		x.ref41775798 = nil
	}
}

// NewPublicPieceInfoTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPublicPieceInfoTRef(ref unsafe.Pointer) *PublicPieceInfoT {
	if ref == nil {
		return nil
	}
	obj := new(PublicPieceInfoT)
	obj.ref41775798 = (*C.PublicPieceInfo_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PublicPieceInfoT) PassRef() (*C.PublicPieceInfo_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref41775798 != nil {
		return x.ref41775798, nil
	}
	mem41775798 := allocPublicPieceInfoTMemory(1)
	ref41775798 := (*C.PublicPieceInfo_t)(mem41775798)
	allocs41775798 := new(cgoAllocMap)
	allocs41775798.Add(mem41775798)

	var cnum_bytes_allocs *cgoAllocMap
	ref41775798.num_bytes, cnum_bytes_allocs = (C.uint64_t)(x.NumBytes), cgoAllocsUnknown
	allocs41775798.Borrow(cnum_bytes_allocs)

	var ccomm_p_allocs *cgoAllocMap
	ref41775798.comm_p, ccomm_p_allocs = x.CommP.PassValue()
	allocs41775798.Borrow(ccomm_p_allocs)

	x.ref41775798 = ref41775798
	x.allocs41775798 = allocs41775798
	return ref41775798, allocs41775798

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PublicPieceInfoT) PassValue() (C.PublicPieceInfo_t, *cgoAllocMap) {
	if x.ref41775798 != nil {
		return *x.ref41775798, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PublicPieceInfoT) Deref() {
	if x.ref41775798 == nil {
		return
	}
	x.NumBytes = (Uint64T)(x.ref41775798.num_bytes)
	x.CommP = *NewUint832ArrayTRef(unsafe.Pointer(&x.ref41775798.comm_p))
}

// allocArrayPublicPieceInfoTMemory allocates memory for type C.Array_PublicPieceInfo_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocArrayPublicPieceInfoTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfArrayPublicPieceInfoTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfArrayPublicPieceInfoTValue = unsafe.Sizeof([1]C.Array_PublicPieceInfo_t{})

// allocPPublicPieceInfoTMemory allocates memory for type *C.PublicPieceInfo_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPPublicPieceInfoTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPPublicPieceInfoTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPPublicPieceInfoTValue = unsafe.Sizeof([1]*C.PublicPieceInfo_t{})

// unpackSSPublicPieceInfoT transforms a sliced Go data structure into plain C format.
func unpackSSPublicPieceInfoT(x [][]PublicPieceInfoT) (unpacked **C.PublicPieceInfo_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPPublicPieceInfoTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.PublicPieceInfo_t)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocPublicPieceInfoTMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.PublicPieceInfo_t)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.PublicPieceInfo_t)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.PublicPieceInfo_t)(h.Data)
	return
}

// packSSPublicPieceInfoT reads sliced Go data structure out from plain C format.
func packSSPublicPieceInfoT(v [][]PublicPieceInfoT, ptr0 **C.PublicPieceInfo_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.PublicPieceInfo_t)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfPublicPieceInfoTValue]C.PublicPieceInfo_t)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewPublicPieceInfoTRef(unsafe.Pointer(&ptr2))
		}
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ArrayPublicPieceInfoT) Ref() *C.Array_PublicPieceInfo_t {
	if x == nil {
		return nil
	}
	return x.refe3414758
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ArrayPublicPieceInfoT) Free() {
	if x != nil && x.allocse3414758 != nil {
		x.allocse3414758.(*cgoAllocMap).Free()
		x.refe3414758 = nil
	}
}

// NewArrayPublicPieceInfoTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewArrayPublicPieceInfoTRef(ref unsafe.Pointer) *ArrayPublicPieceInfoT {
	if ref == nil {
		return nil
	}
	obj := new(ArrayPublicPieceInfoT)
	obj.refe3414758 = (*C.Array_PublicPieceInfo_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ArrayPublicPieceInfoT) PassRef() (*C.Array_PublicPieceInfo_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe3414758 != nil {
		return x.refe3414758, nil
	}
	meme3414758 := allocArrayPublicPieceInfoTMemory(1)
	refe3414758 := (*C.Array_PublicPieceInfo_t)(meme3414758)
	allocse3414758 := new(cgoAllocMap)
	allocse3414758.Add(meme3414758)

	var cptr_allocs *cgoAllocMap
	refe3414758.ptr, cptr_allocs = unpackSSPublicPieceInfoT(x.Ptr)
	allocse3414758.Borrow(cptr_allocs)

	var clen_allocs *cgoAllocMap
	refe3414758.len, clen_allocs = (C.size_t)(x.Len), cgoAllocsUnknown
	allocse3414758.Borrow(clen_allocs)

	x.refe3414758 = refe3414758
	x.allocse3414758 = allocse3414758
	return refe3414758, allocse3414758

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ArrayPublicPieceInfoT) PassValue() (C.Array_PublicPieceInfo_t, *cgoAllocMap) {
	if x.refe3414758 != nil {
		return *x.refe3414758, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ArrayPublicPieceInfoT) Deref() {
	if x.refe3414758 == nil {
		return
	}
	packSSPublicPieceInfoT(x.Ptr, x.refe3414758.ptr)
	x.Len = (SizeT)(x.refe3414758.len)
}

// allocResultArrayUint8TMemory allocates memory for type C.Result_Array_uint8_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocResultArrayUint8TMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfResultArrayUint8TValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfResultArrayUint8TValue = unsafe.Sizeof([1]C.Result_Array_uint8_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ResultArrayUint8T) Ref() *C.Result_Array_uint8_t {
	if x == nil {
		return nil
	}
	return x.ref66cb5c38
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ResultArrayUint8T) Free() {
	if x != nil && x.allocs66cb5c38 != nil {
		x.allocs66cb5c38.(*cgoAllocMap).Free()
		x.ref66cb5c38 = nil
	}
}

// NewResultArrayUint8TRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewResultArrayUint8TRef(ref unsafe.Pointer) *ResultArrayUint8T {
	if ref == nil {
		return nil
	}
	obj := new(ResultArrayUint8T)
	obj.ref66cb5c38 = (*C.Result_Array_uint8_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ResultArrayUint8T) PassRef() (*C.Result_Array_uint8_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref66cb5c38 != nil {
		return x.ref66cb5c38, nil
	}
	mem66cb5c38 := allocResultArrayUint8TMemory(1)
	ref66cb5c38 := (*C.Result_Array_uint8_t)(mem66cb5c38)
	allocs66cb5c38 := new(cgoAllocMap)
	allocs66cb5c38.Add(mem66cb5c38)

	var cstatus_code_allocs *cgoAllocMap
	ref66cb5c38.status_code, cstatus_code_allocs = (C.FCPResponseStatus_t)(x.StatusCode), cgoAllocsUnknown
	allocs66cb5c38.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref66cb5c38.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocs66cb5c38.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	ref66cb5c38.value, cvalue_allocs = x.Value.PassValue()
	allocs66cb5c38.Borrow(cvalue_allocs)

	x.ref66cb5c38 = ref66cb5c38
	x.allocs66cb5c38 = allocs66cb5c38
	return ref66cb5c38, allocs66cb5c38

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ResultArrayUint8T) PassValue() (C.Result_Array_uint8_t, *cgoAllocMap) {
	if x.ref66cb5c38 != nil {
		return *x.ref66cb5c38, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ResultArrayUint8T) Deref() {
	if x.ref66cb5c38 == nil {
		return
	}
	x.StatusCode = (FCPResponseStatusT)(x.ref66cb5c38.status_code)
	x.ErrorMsg = *NewArrayUint8TRef(unsafe.Pointer(&x.ref66cb5c38.error_msg))
	x.Value = *NewArrayUint8TRef(unsafe.Pointer(&x.ref66cb5c38.value))
}

// allocSealPreCommitPhase2TMemory allocates memory for type C.SealPreCommitPhase2_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSealPreCommitPhase2TMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSealPreCommitPhase2TValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSealPreCommitPhase2TValue = unsafe.Sizeof([1]C.SealPreCommitPhase2_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SealPreCommitPhase2T) Ref() *C.SealPreCommitPhase2_t {
	if x == nil {
		return nil
	}
	return x.refcd07a1fc
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SealPreCommitPhase2T) Free() {
	if x != nil && x.allocscd07a1fc != nil {
		x.allocscd07a1fc.(*cgoAllocMap).Free()
		x.refcd07a1fc = nil
	}
}

// NewSealPreCommitPhase2TRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSealPreCommitPhase2TRef(ref unsafe.Pointer) *SealPreCommitPhase2T {
	if ref == nil {
		return nil
	}
	obj := new(SealPreCommitPhase2T)
	obj.refcd07a1fc = (*C.SealPreCommitPhase2_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SealPreCommitPhase2T) PassRef() (*C.SealPreCommitPhase2_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refcd07a1fc != nil {
		return x.refcd07a1fc, nil
	}
	memcd07a1fc := allocSealPreCommitPhase2TMemory(1)
	refcd07a1fc := (*C.SealPreCommitPhase2_t)(memcd07a1fc)
	allocscd07a1fc := new(cgoAllocMap)
	allocscd07a1fc.Add(memcd07a1fc)

	var cregistered_proof_allocs *cgoAllocMap
	refcd07a1fc.registered_proof, cregistered_proof_allocs = (C.RegisteredSealProof_t)(x.RegisteredProof), cgoAllocsUnknown
	allocscd07a1fc.Borrow(cregistered_proof_allocs)

	var ccomm_d_allocs *cgoAllocMap
	refcd07a1fc.comm_d, ccomm_d_allocs = x.CommD.PassValue()
	allocscd07a1fc.Borrow(ccomm_d_allocs)

	var ccomm_r_allocs *cgoAllocMap
	refcd07a1fc.comm_r, ccomm_r_allocs = x.CommR.PassValue()
	allocscd07a1fc.Borrow(ccomm_r_allocs)

	x.refcd07a1fc = refcd07a1fc
	x.allocscd07a1fc = allocscd07a1fc
	return refcd07a1fc, allocscd07a1fc

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SealPreCommitPhase2T) PassValue() (C.SealPreCommitPhase2_t, *cgoAllocMap) {
	if x.refcd07a1fc != nil {
		return *x.refcd07a1fc, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SealPreCommitPhase2T) Deref() {
	if x.refcd07a1fc == nil {
		return
	}
	x.RegisteredProof = (RegisteredSealProofT)(x.refcd07a1fc.registered_proof)
	x.CommD = *NewUint832ArrayTRef(unsafe.Pointer(&x.refcd07a1fc.comm_d))
	x.CommR = *NewUint832ArrayTRef(unsafe.Pointer(&x.refcd07a1fc.comm_r))
}

// allocResultSealPreCommitPhase2TMemory allocates memory for type C.Result_SealPreCommitPhase2_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocResultSealPreCommitPhase2TMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfResultSealPreCommitPhase2TValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfResultSealPreCommitPhase2TValue = unsafe.Sizeof([1]C.Result_SealPreCommitPhase2_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ResultSealPreCommitPhase2T) Ref() *C.Result_SealPreCommitPhase2_t {
	if x == nil {
		return nil
	}
	return x.refacb45ebc
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ResultSealPreCommitPhase2T) Free() {
	if x != nil && x.allocsacb45ebc != nil {
		x.allocsacb45ebc.(*cgoAllocMap).Free()
		x.refacb45ebc = nil
	}
}

// NewResultSealPreCommitPhase2TRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewResultSealPreCommitPhase2TRef(ref unsafe.Pointer) *ResultSealPreCommitPhase2T {
	if ref == nil {
		return nil
	}
	obj := new(ResultSealPreCommitPhase2T)
	obj.refacb45ebc = (*C.Result_SealPreCommitPhase2_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ResultSealPreCommitPhase2T) PassRef() (*C.Result_SealPreCommitPhase2_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refacb45ebc != nil {
		return x.refacb45ebc, nil
	}
	memacb45ebc := allocResultSealPreCommitPhase2TMemory(1)
	refacb45ebc := (*C.Result_SealPreCommitPhase2_t)(memacb45ebc)
	allocsacb45ebc := new(cgoAllocMap)
	allocsacb45ebc.Add(memacb45ebc)

	var cstatus_code_allocs *cgoAllocMap
	refacb45ebc.status_code, cstatus_code_allocs = (C.FCPResponseStatus_t)(x.StatusCode), cgoAllocsUnknown
	allocsacb45ebc.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	refacb45ebc.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocsacb45ebc.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	refacb45ebc.value, cvalue_allocs = x.Value.PassValue()
	allocsacb45ebc.Borrow(cvalue_allocs)

	x.refacb45ebc = refacb45ebc
	x.allocsacb45ebc = allocsacb45ebc
	return refacb45ebc, allocsacb45ebc

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ResultSealPreCommitPhase2T) PassValue() (C.Result_SealPreCommitPhase2_t, *cgoAllocMap) {
	if x.refacb45ebc != nil {
		return *x.refacb45ebc, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ResultSealPreCommitPhase2T) Deref() {
	if x.refacb45ebc == nil {
		return
	}
	x.StatusCode = (FCPResponseStatusT)(x.refacb45ebc.status_code)
	x.ErrorMsg = *NewArrayUint8TRef(unsafe.Pointer(&x.refacb45ebc.error_msg))
	x.Value = *NewSealPreCommitPhase2TRef(unsafe.Pointer(&x.refacb45ebc.value))
}

// allocSealCommitPhase2TMemory allocates memory for type C.SealCommitPhase2_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSealCommitPhase2TMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSealCommitPhase2TValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSealCommitPhase2TValue = unsafe.Sizeof([1]C.SealCommitPhase2_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SealCommitPhase2T) Ref() *C.SealCommitPhase2_t {
	if x == nil {
		return nil
	}
	return x.ref66b8d6ea
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SealCommitPhase2T) Free() {
	if x != nil && x.allocs66b8d6ea != nil {
		x.allocs66b8d6ea.(*cgoAllocMap).Free()
		x.ref66b8d6ea = nil
	}
}

// NewSealCommitPhase2TRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSealCommitPhase2TRef(ref unsafe.Pointer) *SealCommitPhase2T {
	if ref == nil {
		return nil
	}
	obj := new(SealCommitPhase2T)
	obj.ref66b8d6ea = (*C.SealCommitPhase2_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SealCommitPhase2T) PassRef() (*C.SealCommitPhase2_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref66b8d6ea != nil {
		return x.ref66b8d6ea, nil
	}
	mem66b8d6ea := allocSealCommitPhase2TMemory(1)
	ref66b8d6ea := (*C.SealCommitPhase2_t)(mem66b8d6ea)
	allocs66b8d6ea := new(cgoAllocMap)
	allocs66b8d6ea.Add(mem66b8d6ea)

	var cproof_allocs *cgoAllocMap
	ref66b8d6ea.proof, cproof_allocs = x.Proof.PassValue()
	allocs66b8d6ea.Borrow(cproof_allocs)

	x.ref66b8d6ea = ref66b8d6ea
	x.allocs66b8d6ea = allocs66b8d6ea
	return ref66b8d6ea, allocs66b8d6ea

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SealCommitPhase2T) PassValue() (C.SealCommitPhase2_t, *cgoAllocMap) {
	if x.ref66b8d6ea != nil {
		return *x.ref66b8d6ea, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SealCommitPhase2T) Deref() {
	if x.ref66b8d6ea == nil {
		return
	}
	x.Proof = *NewArrayUint8TRef(unsafe.Pointer(&x.ref66b8d6ea.proof))
}

// allocResultSealCommitPhase2TMemory allocates memory for type C.Result_SealCommitPhase2_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocResultSealCommitPhase2TMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfResultSealCommitPhase2TValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfResultSealCommitPhase2TValue = unsafe.Sizeof([1]C.Result_SealCommitPhase2_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ResultSealCommitPhase2T) Ref() *C.Result_SealCommitPhase2_t {
	if x == nil {
		return nil
	}
	return x.refb3d64060
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ResultSealCommitPhase2T) Free() {
	if x != nil && x.allocsb3d64060 != nil {
		x.allocsb3d64060.(*cgoAllocMap).Free()
		x.refb3d64060 = nil
	}
}

// NewResultSealCommitPhase2TRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewResultSealCommitPhase2TRef(ref unsafe.Pointer) *ResultSealCommitPhase2T {
	if ref == nil {
		return nil
	}
	obj := new(ResultSealCommitPhase2T)
	obj.refb3d64060 = (*C.Result_SealCommitPhase2_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ResultSealCommitPhase2T) PassRef() (*C.Result_SealCommitPhase2_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb3d64060 != nil {
		return x.refb3d64060, nil
	}
	memb3d64060 := allocResultSealCommitPhase2TMemory(1)
	refb3d64060 := (*C.Result_SealCommitPhase2_t)(memb3d64060)
	allocsb3d64060 := new(cgoAllocMap)
	allocsb3d64060.Add(memb3d64060)

	var cstatus_code_allocs *cgoAllocMap
	refb3d64060.status_code, cstatus_code_allocs = (C.FCPResponseStatus_t)(x.StatusCode), cgoAllocsUnknown
	allocsb3d64060.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	refb3d64060.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocsb3d64060.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	refb3d64060.value, cvalue_allocs = x.Value.PassValue()
	allocsb3d64060.Borrow(cvalue_allocs)

	x.refb3d64060 = refb3d64060
	x.allocsb3d64060 = allocsb3d64060
	return refb3d64060, allocsb3d64060

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ResultSealCommitPhase2T) PassValue() (C.Result_SealCommitPhase2_t, *cgoAllocMap) {
	if x.refb3d64060 != nil {
		return *x.refb3d64060, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ResultSealCommitPhase2T) Deref() {
	if x.refb3d64060 == nil {
		return
	}
	x.StatusCode = (FCPResponseStatusT)(x.refb3d64060.status_code)
	x.ErrorMsg = *NewArrayUint8TRef(unsafe.Pointer(&x.refb3d64060.error_msg))
	x.Value = *NewSealCommitPhase2TRef(unsafe.Pointer(&x.refb3d64060.value))
}

// allocArrayByteArray32TMemory allocates memory for type C.Array_ByteArray32_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocArrayByteArray32TMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfArrayByteArray32TValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfArrayByteArray32TValue = unsafe.Sizeof([1]C.Array_ByteArray32_t{})

// allocPByteArray32TMemory allocates memory for type *C.ByteArray32_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPByteArray32TMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPByteArray32TValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPByteArray32TValue = unsafe.Sizeof([1]*C.ByteArray32_t{})

// unpackSSByteArray32T transforms a sliced Go data structure into plain C format.
func unpackSSByteArray32T(x [][]ByteArray32T) (unpacked **C.ByteArray32_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPByteArray32TMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.ByteArray32_t)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocByteArray32TMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.ByteArray32_t)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.ByteArray32_t)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.ByteArray32_t)(h.Data)
	return
}

// packSSByteArray32T reads sliced Go data structure out from plain C format.
func packSSByteArray32T(v [][]ByteArray32T, ptr0 **C.ByteArray32_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.ByteArray32_t)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfByteArray32TValue]C.ByteArray32_t)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewByteArray32TRef(unsafe.Pointer(&ptr2))
		}
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ArrayByteArray32T) Ref() *C.Array_ByteArray32_t {
	if x == nil {
		return nil
	}
	return x.ref737257fb
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ArrayByteArray32T) Free() {
	if x != nil && x.allocs737257fb != nil {
		x.allocs737257fb.(*cgoAllocMap).Free()
		x.ref737257fb = nil
	}
}

// NewArrayByteArray32TRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewArrayByteArray32TRef(ref unsafe.Pointer) *ArrayByteArray32T {
	if ref == nil {
		return nil
	}
	obj := new(ArrayByteArray32T)
	obj.ref737257fb = (*C.Array_ByteArray32_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ArrayByteArray32T) PassRef() (*C.Array_ByteArray32_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref737257fb != nil {
		return x.ref737257fb, nil
	}
	mem737257fb := allocArrayByteArray32TMemory(1)
	ref737257fb := (*C.Array_ByteArray32_t)(mem737257fb)
	allocs737257fb := new(cgoAllocMap)
	allocs737257fb.Add(mem737257fb)

	var cptr_allocs *cgoAllocMap
	ref737257fb.ptr, cptr_allocs = unpackSSByteArray32T(x.Ptr)
	allocs737257fb.Borrow(cptr_allocs)

	var clen_allocs *cgoAllocMap
	ref737257fb.len, clen_allocs = (C.size_t)(x.Len), cgoAllocsUnknown
	allocs737257fb.Borrow(clen_allocs)

	x.ref737257fb = ref737257fb
	x.allocs737257fb = allocs737257fb
	return ref737257fb, allocs737257fb

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ArrayByteArray32T) PassValue() (C.Array_ByteArray32_t, *cgoAllocMap) {
	if x.ref737257fb != nil {
		return *x.ref737257fb, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ArrayByteArray32T) Deref() {
	if x.ref737257fb == nil {
		return
	}
	packSSByteArray32T(x.Ptr, x.ref737257fb.ptr)
	x.Len = (SizeT)(x.ref737257fb.len)
}

// allocArraySealCommitPhase2TMemory allocates memory for type C.Array_SealCommitPhase2_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocArraySealCommitPhase2TMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfArraySealCommitPhase2TValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfArraySealCommitPhase2TValue = unsafe.Sizeof([1]C.Array_SealCommitPhase2_t{})

// allocPSealCommitPhase2TMemory allocates memory for type *C.SealCommitPhase2_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPSealCommitPhase2TMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPSealCommitPhase2TValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPSealCommitPhase2TValue = unsafe.Sizeof([1]*C.SealCommitPhase2_t{})

// unpackSSSealCommitPhase2T transforms a sliced Go data structure into plain C format.
func unpackSSSealCommitPhase2T(x [][]SealCommitPhase2T) (unpacked **C.SealCommitPhase2_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPSealCommitPhase2TMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.SealCommitPhase2_t)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocSealCommitPhase2TMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.SealCommitPhase2_t)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.SealCommitPhase2_t)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.SealCommitPhase2_t)(h.Data)
	return
}

// packSSSealCommitPhase2T reads sliced Go data structure out from plain C format.
func packSSSealCommitPhase2T(v [][]SealCommitPhase2T, ptr0 **C.SealCommitPhase2_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.SealCommitPhase2_t)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfSealCommitPhase2TValue]C.SealCommitPhase2_t)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewSealCommitPhase2TRef(unsafe.Pointer(&ptr2))
		}
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ArraySealCommitPhase2T) Ref() *C.Array_SealCommitPhase2_t {
	if x == nil {
		return nil
	}
	return x.reffd7e224a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ArraySealCommitPhase2T) Free() {
	if x != nil && x.allocsfd7e224a != nil {
		x.allocsfd7e224a.(*cgoAllocMap).Free()
		x.reffd7e224a = nil
	}
}

// NewArraySealCommitPhase2TRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewArraySealCommitPhase2TRef(ref unsafe.Pointer) *ArraySealCommitPhase2T {
	if ref == nil {
		return nil
	}
	obj := new(ArraySealCommitPhase2T)
	obj.reffd7e224a = (*C.Array_SealCommitPhase2_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ArraySealCommitPhase2T) PassRef() (*C.Array_SealCommitPhase2_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffd7e224a != nil {
		return x.reffd7e224a, nil
	}
	memfd7e224a := allocArraySealCommitPhase2TMemory(1)
	reffd7e224a := (*C.Array_SealCommitPhase2_t)(memfd7e224a)
	allocsfd7e224a := new(cgoAllocMap)
	allocsfd7e224a.Add(memfd7e224a)

	var cptr_allocs *cgoAllocMap
	reffd7e224a.ptr, cptr_allocs = unpackSSSealCommitPhase2T(x.Ptr)
	allocsfd7e224a.Borrow(cptr_allocs)

	var clen_allocs *cgoAllocMap
	reffd7e224a.len, clen_allocs = (C.size_t)(x.Len), cgoAllocsUnknown
	allocsfd7e224a.Borrow(clen_allocs)

	x.reffd7e224a = reffd7e224a
	x.allocsfd7e224a = allocsfd7e224a
	return reffd7e224a, allocsfd7e224a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ArraySealCommitPhase2T) PassValue() (C.Array_SealCommitPhase2_t, *cgoAllocMap) {
	if x.reffd7e224a != nil {
		return *x.reffd7e224a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ArraySealCommitPhase2T) Deref() {
	if x.reffd7e224a == nil {
		return
	}
	packSSSealCommitPhase2T(x.Ptr, x.reffd7e224a.ptr)
	x.Len = (SizeT)(x.reffd7e224a.len)
}

// allocAggregationInputsTMemory allocates memory for type C.AggregationInputs_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAggregationInputsTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAggregationInputsTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfAggregationInputsTValue = unsafe.Sizeof([1]C.AggregationInputs_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *AggregationInputsT) Ref() *C.AggregationInputs_t {
	if x == nil {
		return nil
	}
	return x.refb10889cf
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *AggregationInputsT) Free() {
	if x != nil && x.allocsb10889cf != nil {
		x.allocsb10889cf.(*cgoAllocMap).Free()
		x.refb10889cf = nil
	}
}

// NewAggregationInputsTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAggregationInputsTRef(ref unsafe.Pointer) *AggregationInputsT {
	if ref == nil {
		return nil
	}
	obj := new(AggregationInputsT)
	obj.refb10889cf = (*C.AggregationInputs_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *AggregationInputsT) PassRef() (*C.AggregationInputs_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb10889cf != nil {
		return x.refb10889cf, nil
	}
	memb10889cf := allocAggregationInputsTMemory(1)
	refb10889cf := (*C.AggregationInputs_t)(memb10889cf)
	allocsb10889cf := new(cgoAllocMap)
	allocsb10889cf.Add(memb10889cf)

	var ccomm_r_allocs *cgoAllocMap
	refb10889cf.comm_r, ccomm_r_allocs = x.CommR.PassValue()
	allocsb10889cf.Borrow(ccomm_r_allocs)

	var ccomm_d_allocs *cgoAllocMap
	refb10889cf.comm_d, ccomm_d_allocs = x.CommD.PassValue()
	allocsb10889cf.Borrow(ccomm_d_allocs)

	var csector_id_allocs *cgoAllocMap
	refb10889cf.sector_id, csector_id_allocs = (C.uint64_t)(x.SectorId), cgoAllocsUnknown
	allocsb10889cf.Borrow(csector_id_allocs)

	var cticket_allocs *cgoAllocMap
	refb10889cf.ticket, cticket_allocs = x.Ticket.PassValue()
	allocsb10889cf.Borrow(cticket_allocs)

	var cseed_allocs *cgoAllocMap
	refb10889cf.seed, cseed_allocs = x.Seed.PassValue()
	allocsb10889cf.Borrow(cseed_allocs)

	x.refb10889cf = refb10889cf
	x.allocsb10889cf = allocsb10889cf
	return refb10889cf, allocsb10889cf

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x AggregationInputsT) PassValue() (C.AggregationInputs_t, *cgoAllocMap) {
	if x.refb10889cf != nil {
		return *x.refb10889cf, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *AggregationInputsT) Deref() {
	if x.refb10889cf == nil {
		return
	}
	x.CommR = *NewByteArray32TRef(unsafe.Pointer(&x.refb10889cf.comm_r))
	x.CommD = *NewByteArray32TRef(unsafe.Pointer(&x.refb10889cf.comm_d))
	x.SectorId = (Uint64T)(x.refb10889cf.sector_id)
	x.Ticket = *NewByteArray32TRef(unsafe.Pointer(&x.refb10889cf.ticket))
	x.Seed = *NewByteArray32TRef(unsafe.Pointer(&x.refb10889cf.seed))
}

// allocArrayAggregationInputsTMemory allocates memory for type C.Array_AggregationInputs_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocArrayAggregationInputsTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfArrayAggregationInputsTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfArrayAggregationInputsTValue = unsafe.Sizeof([1]C.Array_AggregationInputs_t{})

// allocPAggregationInputsTMemory allocates memory for type *C.AggregationInputs_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPAggregationInputsTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPAggregationInputsTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPAggregationInputsTValue = unsafe.Sizeof([1]*C.AggregationInputs_t{})

// unpackSSAggregationInputsT transforms a sliced Go data structure into plain C format.
func unpackSSAggregationInputsT(x [][]AggregationInputsT) (unpacked **C.AggregationInputs_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPAggregationInputsTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.AggregationInputs_t)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocAggregationInputsTMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.AggregationInputs_t)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.AggregationInputs_t)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.AggregationInputs_t)(h.Data)
	return
}

// packSSAggregationInputsT reads sliced Go data structure out from plain C format.
func packSSAggregationInputsT(v [][]AggregationInputsT, ptr0 **C.AggregationInputs_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.AggregationInputs_t)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfAggregationInputsTValue]C.AggregationInputs_t)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewAggregationInputsTRef(unsafe.Pointer(&ptr2))
		}
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ArrayAggregationInputsT) Ref() *C.Array_AggregationInputs_t {
	if x == nil {
		return nil
	}
	return x.ref6745ecd3
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ArrayAggregationInputsT) Free() {
	if x != nil && x.allocs6745ecd3 != nil {
		x.allocs6745ecd3.(*cgoAllocMap).Free()
		x.ref6745ecd3 = nil
	}
}

// NewArrayAggregationInputsTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewArrayAggregationInputsTRef(ref unsafe.Pointer) *ArrayAggregationInputsT {
	if ref == nil {
		return nil
	}
	obj := new(ArrayAggregationInputsT)
	obj.ref6745ecd3 = (*C.Array_AggregationInputs_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ArrayAggregationInputsT) PassRef() (*C.Array_AggregationInputs_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6745ecd3 != nil {
		return x.ref6745ecd3, nil
	}
	mem6745ecd3 := allocArrayAggregationInputsTMemory(1)
	ref6745ecd3 := (*C.Array_AggregationInputs_t)(mem6745ecd3)
	allocs6745ecd3 := new(cgoAllocMap)
	allocs6745ecd3.Add(mem6745ecd3)

	var cptr_allocs *cgoAllocMap
	ref6745ecd3.ptr, cptr_allocs = unpackSSAggregationInputsT(x.Ptr)
	allocs6745ecd3.Borrow(cptr_allocs)

	var clen_allocs *cgoAllocMap
	ref6745ecd3.len, clen_allocs = (C.size_t)(x.Len), cgoAllocsUnknown
	allocs6745ecd3.Borrow(clen_allocs)

	x.ref6745ecd3 = ref6745ecd3
	x.allocs6745ecd3 = allocs6745ecd3
	return ref6745ecd3, allocs6745ecd3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ArrayAggregationInputsT) PassValue() (C.Array_AggregationInputs_t, *cgoAllocMap) {
	if x.ref6745ecd3 != nil {
		return *x.ref6745ecd3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ArrayAggregationInputsT) Deref() {
	if x.ref6745ecd3 == nil {
		return
	}
	packSSAggregationInputsT(x.Ptr, x.ref6745ecd3.ptr)
	x.Len = (SizeT)(x.ref6745ecd3.len)
}

// allocResultBoolTMemory allocates memory for type C.Result_bool_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocResultBoolTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfResultBoolTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfResultBoolTValue = unsafe.Sizeof([1]C.Result_bool_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ResultBoolT) Ref() *C.Result_bool_t {
	if x == nil {
		return nil
	}
	return x.reff0bebe68
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ResultBoolT) Free() {
	if x != nil && x.allocsf0bebe68 != nil {
		x.allocsf0bebe68.(*cgoAllocMap).Free()
		x.reff0bebe68 = nil
	}
}

// NewResultBoolTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewResultBoolTRef(ref unsafe.Pointer) *ResultBoolT {
	if ref == nil {
		return nil
	}
	obj := new(ResultBoolT)
	obj.reff0bebe68 = (*C.Result_bool_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ResultBoolT) PassRef() (*C.Result_bool_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff0bebe68 != nil {
		return x.reff0bebe68, nil
	}
	memf0bebe68 := allocResultBoolTMemory(1)
	reff0bebe68 := (*C.Result_bool_t)(memf0bebe68)
	allocsf0bebe68 := new(cgoAllocMap)
	allocsf0bebe68.Add(memf0bebe68)

	var cstatus_code_allocs *cgoAllocMap
	reff0bebe68.status_code, cstatus_code_allocs = (C.FCPResponseStatus_t)(x.StatusCode), cgoAllocsUnknown
	allocsf0bebe68.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	reff0bebe68.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocsf0bebe68.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	reff0bebe68.value, cvalue_allocs = (C._Bool)(x.Value), cgoAllocsUnknown
	allocsf0bebe68.Borrow(cvalue_allocs)

	x.reff0bebe68 = reff0bebe68
	x.allocsf0bebe68 = allocsf0bebe68
	return reff0bebe68, allocsf0bebe68

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ResultBoolT) PassValue() (C.Result_bool_t, *cgoAllocMap) {
	if x.reff0bebe68 != nil {
		return *x.reff0bebe68, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ResultBoolT) Deref() {
	if x.reff0bebe68 == nil {
		return
	}
	x.StatusCode = (FCPResponseStatusT)(x.reff0bebe68.status_code)
	x.ErrorMsg = *NewArrayUint8TRef(unsafe.Pointer(&x.reff0bebe68.error_msg))
	x.Value = (bool)(x.reff0bebe68.value)
}

// allocResultArrayUint64TMemory allocates memory for type C.Result_Array_uint64_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocResultArrayUint64TMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfResultArrayUint64TValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfResultArrayUint64TValue = unsafe.Sizeof([1]C.Result_Array_uint64_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ResultArrayUint64T) Ref() *C.Result_Array_uint64_t {
	if x == nil {
		return nil
	}
	return x.ref7f2387f1
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ResultArrayUint64T) Free() {
	if x != nil && x.allocs7f2387f1 != nil {
		x.allocs7f2387f1.(*cgoAllocMap).Free()
		x.ref7f2387f1 = nil
	}
}

// NewResultArrayUint64TRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewResultArrayUint64TRef(ref unsafe.Pointer) *ResultArrayUint64T {
	if ref == nil {
		return nil
	}
	obj := new(ResultArrayUint64T)
	obj.ref7f2387f1 = (*C.Result_Array_uint64_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ResultArrayUint64T) PassRef() (*C.Result_Array_uint64_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7f2387f1 != nil {
		return x.ref7f2387f1, nil
	}
	mem7f2387f1 := allocResultArrayUint64TMemory(1)
	ref7f2387f1 := (*C.Result_Array_uint64_t)(mem7f2387f1)
	allocs7f2387f1 := new(cgoAllocMap)
	allocs7f2387f1.Add(mem7f2387f1)

	var cstatus_code_allocs *cgoAllocMap
	ref7f2387f1.status_code, cstatus_code_allocs = (C.FCPResponseStatus_t)(x.StatusCode), cgoAllocsUnknown
	allocs7f2387f1.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref7f2387f1.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocs7f2387f1.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	ref7f2387f1.value, cvalue_allocs = x.Value.PassValue()
	allocs7f2387f1.Borrow(cvalue_allocs)

	x.ref7f2387f1 = ref7f2387f1
	x.allocs7f2387f1 = allocs7f2387f1
	return ref7f2387f1, allocs7f2387f1

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ResultArrayUint64T) PassValue() (C.Result_Array_uint64_t, *cgoAllocMap) {
	if x.ref7f2387f1 != nil {
		return *x.ref7f2387f1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ResultArrayUint64T) Deref() {
	if x.ref7f2387f1 == nil {
		return
	}
	x.StatusCode = (FCPResponseStatusT)(x.ref7f2387f1.status_code)
	x.ErrorMsg = *NewArrayUint8TRef(unsafe.Pointer(&x.ref7f2387f1.error_msg))
	x.Value = *NewArrayUint64TRef(unsafe.Pointer(&x.ref7f2387f1.value))
}

// allocGenerateFallbackSectorChallengesTMemory allocates memory for type C.GenerateFallbackSectorChallenges_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocGenerateFallbackSectorChallengesTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfGenerateFallbackSectorChallengesTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfGenerateFallbackSectorChallengesTValue = unsafe.Sizeof([1]C.GenerateFallbackSectorChallenges_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *GenerateFallbackSectorChallengesT) Ref() *C.GenerateFallbackSectorChallenges_t {
	if x == nil {
		return nil
	}
	return x.ref1a0802cf
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *GenerateFallbackSectorChallengesT) Free() {
	if x != nil && x.allocs1a0802cf != nil {
		x.allocs1a0802cf.(*cgoAllocMap).Free()
		x.ref1a0802cf = nil
	}
}

// NewGenerateFallbackSectorChallengesTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewGenerateFallbackSectorChallengesTRef(ref unsafe.Pointer) *GenerateFallbackSectorChallengesT {
	if ref == nil {
		return nil
	}
	obj := new(GenerateFallbackSectorChallengesT)
	obj.ref1a0802cf = (*C.GenerateFallbackSectorChallenges_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *GenerateFallbackSectorChallengesT) PassRef() (*C.GenerateFallbackSectorChallenges_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1a0802cf != nil {
		return x.ref1a0802cf, nil
	}
	mem1a0802cf := allocGenerateFallbackSectorChallengesTMemory(1)
	ref1a0802cf := (*C.GenerateFallbackSectorChallenges_t)(mem1a0802cf)
	allocs1a0802cf := new(cgoAllocMap)
	allocs1a0802cf.Add(mem1a0802cf)

	var cids_allocs *cgoAllocMap
	ref1a0802cf.ids, cids_allocs = x.Ids.PassValue()
	allocs1a0802cf.Borrow(cids_allocs)

	var cchallenges_allocs *cgoAllocMap
	ref1a0802cf.challenges, cchallenges_allocs = x.Challenges.PassValue()
	allocs1a0802cf.Borrow(cchallenges_allocs)

	var cchallenges_stride_allocs *cgoAllocMap
	ref1a0802cf.challenges_stride, cchallenges_stride_allocs = (C.size_t)(x.ChallengesStride), cgoAllocsUnknown
	allocs1a0802cf.Borrow(cchallenges_stride_allocs)

	x.ref1a0802cf = ref1a0802cf
	x.allocs1a0802cf = allocs1a0802cf
	return ref1a0802cf, allocs1a0802cf

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x GenerateFallbackSectorChallengesT) PassValue() (C.GenerateFallbackSectorChallenges_t, *cgoAllocMap) {
	if x.ref1a0802cf != nil {
		return *x.ref1a0802cf, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *GenerateFallbackSectorChallengesT) Deref() {
	if x.ref1a0802cf == nil {
		return
	}
	x.Ids = *NewArrayUint64TRef(unsafe.Pointer(&x.ref1a0802cf.ids))
	x.Challenges = *NewArrayUint64TRef(unsafe.Pointer(&x.ref1a0802cf.challenges))
	x.ChallengesStride = (SizeT)(x.ref1a0802cf.challenges_stride)
}

// allocResultGenerateFallbackSectorChallengesTMemory allocates memory for type C.Result_GenerateFallbackSectorChallenges_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocResultGenerateFallbackSectorChallengesTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfResultGenerateFallbackSectorChallengesTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfResultGenerateFallbackSectorChallengesTValue = unsafe.Sizeof([1]C.Result_GenerateFallbackSectorChallenges_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ResultGenerateFallbackSectorChallengesT) Ref() *C.Result_GenerateFallbackSectorChallenges_t {
	if x == nil {
		return nil
	}
	return x.ref69d095cd
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ResultGenerateFallbackSectorChallengesT) Free() {
	if x != nil && x.allocs69d095cd != nil {
		x.allocs69d095cd.(*cgoAllocMap).Free()
		x.ref69d095cd = nil
	}
}

// NewResultGenerateFallbackSectorChallengesTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewResultGenerateFallbackSectorChallengesTRef(ref unsafe.Pointer) *ResultGenerateFallbackSectorChallengesT {
	if ref == nil {
		return nil
	}
	obj := new(ResultGenerateFallbackSectorChallengesT)
	obj.ref69d095cd = (*C.Result_GenerateFallbackSectorChallenges_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ResultGenerateFallbackSectorChallengesT) PassRef() (*C.Result_GenerateFallbackSectorChallenges_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref69d095cd != nil {
		return x.ref69d095cd, nil
	}
	mem69d095cd := allocResultGenerateFallbackSectorChallengesTMemory(1)
	ref69d095cd := (*C.Result_GenerateFallbackSectorChallenges_t)(mem69d095cd)
	allocs69d095cd := new(cgoAllocMap)
	allocs69d095cd.Add(mem69d095cd)

	var cstatus_code_allocs *cgoAllocMap
	ref69d095cd.status_code, cstatus_code_allocs = (C.FCPResponseStatus_t)(x.StatusCode), cgoAllocsUnknown
	allocs69d095cd.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref69d095cd.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocs69d095cd.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	ref69d095cd.value, cvalue_allocs = x.Value.PassValue()
	allocs69d095cd.Borrow(cvalue_allocs)

	x.ref69d095cd = ref69d095cd
	x.allocs69d095cd = allocs69d095cd
	return ref69d095cd, allocs69d095cd

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ResultGenerateFallbackSectorChallengesT) PassValue() (C.Result_GenerateFallbackSectorChallenges_t, *cgoAllocMap) {
	if x.ref69d095cd != nil {
		return *x.ref69d095cd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ResultGenerateFallbackSectorChallengesT) Deref() {
	if x.ref69d095cd == nil {
		return
	}
	x.StatusCode = (FCPResponseStatusT)(x.ref69d095cd.status_code)
	x.ErrorMsg = *NewArrayUint8TRef(unsafe.Pointer(&x.ref69d095cd.error_msg))
	x.Value = *NewGenerateFallbackSectorChallengesTRef(unsafe.Pointer(&x.ref69d095cd.value))
}

// allocPrivateReplicaInfoTMemory allocates memory for type C.PrivateReplicaInfo_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPrivateReplicaInfoTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPrivateReplicaInfoTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPrivateReplicaInfoTValue = unsafe.Sizeof([1]C.PrivateReplicaInfo_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PrivateReplicaInfoT) Ref() *C.PrivateReplicaInfo_t {
	if x == nil {
		return nil
	}
	return x.ref4fcd660f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PrivateReplicaInfoT) Free() {
	if x != nil && x.allocs4fcd660f != nil {
		x.allocs4fcd660f.(*cgoAllocMap).Free()
		x.ref4fcd660f = nil
	}
}

// NewPrivateReplicaInfoTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPrivateReplicaInfoTRef(ref unsafe.Pointer) *PrivateReplicaInfoT {
	if ref == nil {
		return nil
	}
	obj := new(PrivateReplicaInfoT)
	obj.ref4fcd660f = (*C.PrivateReplicaInfo_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PrivateReplicaInfoT) PassRef() (*C.PrivateReplicaInfo_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4fcd660f != nil {
		return x.ref4fcd660f, nil
	}
	mem4fcd660f := allocPrivateReplicaInfoTMemory(1)
	ref4fcd660f := (*C.PrivateReplicaInfo_t)(mem4fcd660f)
	allocs4fcd660f := new(cgoAllocMap)
	allocs4fcd660f.Add(mem4fcd660f)

	var cregistered_proof_allocs *cgoAllocMap
	ref4fcd660f.registered_proof, cregistered_proof_allocs = (C.RegisteredPoStProof_t)(x.RegisteredProof), cgoAllocsUnknown
	allocs4fcd660f.Borrow(cregistered_proof_allocs)

	var ccache_dir_path_allocs *cgoAllocMap
	ref4fcd660f.cache_dir_path, ccache_dir_path_allocs = x.CacheDirPath.PassValue()
	allocs4fcd660f.Borrow(ccache_dir_path_allocs)

	var ccomm_r_allocs *cgoAllocMap
	ref4fcd660f.comm_r, ccomm_r_allocs = x.CommR.PassValue()
	allocs4fcd660f.Borrow(ccomm_r_allocs)

	var creplica_path_allocs *cgoAllocMap
	ref4fcd660f.replica_path, creplica_path_allocs = x.ReplicaPath.PassValue()
	allocs4fcd660f.Borrow(creplica_path_allocs)

	var csector_id_allocs *cgoAllocMap
	ref4fcd660f.sector_id, csector_id_allocs = (C.uint64_t)(x.SectorId), cgoAllocsUnknown
	allocs4fcd660f.Borrow(csector_id_allocs)

	x.ref4fcd660f = ref4fcd660f
	x.allocs4fcd660f = allocs4fcd660f
	return ref4fcd660f, allocs4fcd660f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PrivateReplicaInfoT) PassValue() (C.PrivateReplicaInfo_t, *cgoAllocMap) {
	if x.ref4fcd660f != nil {
		return *x.ref4fcd660f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PrivateReplicaInfoT) Deref() {
	if x.ref4fcd660f == nil {
		return
	}
	x.RegisteredProof = (RegisteredPoStProofT)(x.ref4fcd660f.registered_proof)
	x.CacheDirPath = *NewArrayUint8TRef(unsafe.Pointer(&x.ref4fcd660f.cache_dir_path))
	x.CommR = *NewUint832ArrayTRef(unsafe.Pointer(&x.ref4fcd660f.comm_r))
	x.ReplicaPath = *NewArrayUint8TRef(unsafe.Pointer(&x.ref4fcd660f.replica_path))
	x.SectorId = (Uint64T)(x.ref4fcd660f.sector_id)
}

// allocPoStProofTMemory allocates memory for type C.PoStProof_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPoStProofTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPoStProofTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPoStProofTValue = unsafe.Sizeof([1]C.PoStProof_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PoStProofT) Ref() *C.PoStProof_t {
	if x == nil {
		return nil
	}
	return x.ref6b19d074
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PoStProofT) Free() {
	if x != nil && x.allocs6b19d074 != nil {
		x.allocs6b19d074.(*cgoAllocMap).Free()
		x.ref6b19d074 = nil
	}
}

// NewPoStProofTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPoStProofTRef(ref unsafe.Pointer) *PoStProofT {
	if ref == nil {
		return nil
	}
	obj := new(PoStProofT)
	obj.ref6b19d074 = (*C.PoStProof_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PoStProofT) PassRef() (*C.PoStProof_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6b19d074 != nil {
		return x.ref6b19d074, nil
	}
	mem6b19d074 := allocPoStProofTMemory(1)
	ref6b19d074 := (*C.PoStProof_t)(mem6b19d074)
	allocs6b19d074 := new(cgoAllocMap)
	allocs6b19d074.Add(mem6b19d074)

	var cregistered_proof_allocs *cgoAllocMap
	ref6b19d074.registered_proof, cregistered_proof_allocs = (C.RegisteredPoStProof_t)(x.RegisteredProof), cgoAllocsUnknown
	allocs6b19d074.Borrow(cregistered_proof_allocs)

	var cproof_allocs *cgoAllocMap
	ref6b19d074.proof, cproof_allocs = x.Proof.PassValue()
	allocs6b19d074.Borrow(cproof_allocs)

	x.ref6b19d074 = ref6b19d074
	x.allocs6b19d074 = allocs6b19d074
	return ref6b19d074, allocs6b19d074

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PoStProofT) PassValue() (C.PoStProof_t, *cgoAllocMap) {
	if x.ref6b19d074 != nil {
		return *x.ref6b19d074, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PoStProofT) Deref() {
	if x.ref6b19d074 == nil {
		return
	}
	x.RegisteredProof = (RegisteredPoStProofT)(x.ref6b19d074.registered_proof)
	x.Proof = *NewArrayUint8TRef(unsafe.Pointer(&x.ref6b19d074.proof))
}

// allocArrayPoStProofTMemory allocates memory for type C.Array_PoStProof_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocArrayPoStProofTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfArrayPoStProofTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfArrayPoStProofTValue = unsafe.Sizeof([1]C.Array_PoStProof_t{})

// allocPPoStProofTMemory allocates memory for type *C.PoStProof_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPPoStProofTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPPoStProofTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPPoStProofTValue = unsafe.Sizeof([1]*C.PoStProof_t{})

// unpackSSPoStProofT transforms a sliced Go data structure into plain C format.
func unpackSSPoStProofT(x [][]PoStProofT) (unpacked **C.PoStProof_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPPoStProofTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.PoStProof_t)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocPoStProofTMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.PoStProof_t)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.PoStProof_t)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.PoStProof_t)(h.Data)
	return
}

// packSSPoStProofT reads sliced Go data structure out from plain C format.
func packSSPoStProofT(v [][]PoStProofT, ptr0 **C.PoStProof_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.PoStProof_t)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfPoStProofTValue]C.PoStProof_t)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewPoStProofTRef(unsafe.Pointer(&ptr2))
		}
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ArrayPoStProofT) Ref() *C.Array_PoStProof_t {
	if x == nil {
		return nil
	}
	return x.ref87d11e9b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ArrayPoStProofT) Free() {
	if x != nil && x.allocs87d11e9b != nil {
		x.allocs87d11e9b.(*cgoAllocMap).Free()
		x.ref87d11e9b = nil
	}
}

// NewArrayPoStProofTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewArrayPoStProofTRef(ref unsafe.Pointer) *ArrayPoStProofT {
	if ref == nil {
		return nil
	}
	obj := new(ArrayPoStProofT)
	obj.ref87d11e9b = (*C.Array_PoStProof_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ArrayPoStProofT) PassRef() (*C.Array_PoStProof_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref87d11e9b != nil {
		return x.ref87d11e9b, nil
	}
	mem87d11e9b := allocArrayPoStProofTMemory(1)
	ref87d11e9b := (*C.Array_PoStProof_t)(mem87d11e9b)
	allocs87d11e9b := new(cgoAllocMap)
	allocs87d11e9b.Add(mem87d11e9b)

	var cptr_allocs *cgoAllocMap
	ref87d11e9b.ptr, cptr_allocs = unpackSSPoStProofT(x.Ptr)
	allocs87d11e9b.Borrow(cptr_allocs)

	var clen_allocs *cgoAllocMap
	ref87d11e9b.len, clen_allocs = (C.size_t)(x.Len), cgoAllocsUnknown
	allocs87d11e9b.Borrow(clen_allocs)

	x.ref87d11e9b = ref87d11e9b
	x.allocs87d11e9b = allocs87d11e9b
	return ref87d11e9b, allocs87d11e9b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ArrayPoStProofT) PassValue() (C.Array_PoStProof_t, *cgoAllocMap) {
	if x.ref87d11e9b != nil {
		return *x.ref87d11e9b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ArrayPoStProofT) Deref() {
	if x.ref87d11e9b == nil {
		return
	}
	packSSPoStProofT(x.Ptr, x.ref87d11e9b.ptr)
	x.Len = (SizeT)(x.ref87d11e9b.len)
}

// allocResultArrayPoStProofTMemory allocates memory for type C.Result_Array_PoStProof_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocResultArrayPoStProofTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfResultArrayPoStProofTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfResultArrayPoStProofTValue = unsafe.Sizeof([1]C.Result_Array_PoStProof_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ResultArrayPoStProofT) Ref() *C.Result_Array_PoStProof_t {
	if x == nil {
		return nil
	}
	return x.ref890670b9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ResultArrayPoStProofT) Free() {
	if x != nil && x.allocs890670b9 != nil {
		x.allocs890670b9.(*cgoAllocMap).Free()
		x.ref890670b9 = nil
	}
}

// NewResultArrayPoStProofTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewResultArrayPoStProofTRef(ref unsafe.Pointer) *ResultArrayPoStProofT {
	if ref == nil {
		return nil
	}
	obj := new(ResultArrayPoStProofT)
	obj.ref890670b9 = (*C.Result_Array_PoStProof_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ResultArrayPoStProofT) PassRef() (*C.Result_Array_PoStProof_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref890670b9 != nil {
		return x.ref890670b9, nil
	}
	mem890670b9 := allocResultArrayPoStProofTMemory(1)
	ref890670b9 := (*C.Result_Array_PoStProof_t)(mem890670b9)
	allocs890670b9 := new(cgoAllocMap)
	allocs890670b9.Add(mem890670b9)

	var cstatus_code_allocs *cgoAllocMap
	ref890670b9.status_code, cstatus_code_allocs = (C.FCPResponseStatus_t)(x.StatusCode), cgoAllocsUnknown
	allocs890670b9.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref890670b9.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocs890670b9.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	ref890670b9.value, cvalue_allocs = x.Value.PassValue()
	allocs890670b9.Borrow(cvalue_allocs)

	x.ref890670b9 = ref890670b9
	x.allocs890670b9 = allocs890670b9
	return ref890670b9, allocs890670b9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ResultArrayPoStProofT) PassValue() (C.Result_Array_PoStProof_t, *cgoAllocMap) {
	if x.ref890670b9 != nil {
		return *x.ref890670b9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ResultArrayPoStProofT) Deref() {
	if x.ref890670b9 == nil {
		return
	}
	x.StatusCode = (FCPResponseStatusT)(x.ref890670b9.status_code)
	x.ErrorMsg = *NewArrayUint8TRef(unsafe.Pointer(&x.ref890670b9.error_msg))
	x.Value = *NewArrayPoStProofTRef(unsafe.Pointer(&x.ref890670b9.value))
}

// allocArrayPrivateReplicaInfoTMemory allocates memory for type C.Array_PrivateReplicaInfo_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocArrayPrivateReplicaInfoTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfArrayPrivateReplicaInfoTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfArrayPrivateReplicaInfoTValue = unsafe.Sizeof([1]C.Array_PrivateReplicaInfo_t{})

// allocPPrivateReplicaInfoTMemory allocates memory for type *C.PrivateReplicaInfo_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPPrivateReplicaInfoTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPPrivateReplicaInfoTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPPrivateReplicaInfoTValue = unsafe.Sizeof([1]*C.PrivateReplicaInfo_t{})

// unpackSSPrivateReplicaInfoT transforms a sliced Go data structure into plain C format.
func unpackSSPrivateReplicaInfoT(x [][]PrivateReplicaInfoT) (unpacked **C.PrivateReplicaInfo_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPPrivateReplicaInfoTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.PrivateReplicaInfo_t)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocPrivateReplicaInfoTMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.PrivateReplicaInfo_t)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.PrivateReplicaInfo_t)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.PrivateReplicaInfo_t)(h.Data)
	return
}

// packSSPrivateReplicaInfoT reads sliced Go data structure out from plain C format.
func packSSPrivateReplicaInfoT(v [][]PrivateReplicaInfoT, ptr0 **C.PrivateReplicaInfo_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.PrivateReplicaInfo_t)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfPrivateReplicaInfoTValue]C.PrivateReplicaInfo_t)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewPrivateReplicaInfoTRef(unsafe.Pointer(&ptr2))
		}
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ArrayPrivateReplicaInfoT) Ref() *C.Array_PrivateReplicaInfo_t {
	if x == nil {
		return nil
	}
	return x.ref5b1a7725
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ArrayPrivateReplicaInfoT) Free() {
	if x != nil && x.allocs5b1a7725 != nil {
		x.allocs5b1a7725.(*cgoAllocMap).Free()
		x.ref5b1a7725 = nil
	}
}

// NewArrayPrivateReplicaInfoTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewArrayPrivateReplicaInfoTRef(ref unsafe.Pointer) *ArrayPrivateReplicaInfoT {
	if ref == nil {
		return nil
	}
	obj := new(ArrayPrivateReplicaInfoT)
	obj.ref5b1a7725 = (*C.Array_PrivateReplicaInfo_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ArrayPrivateReplicaInfoT) PassRef() (*C.Array_PrivateReplicaInfo_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5b1a7725 != nil {
		return x.ref5b1a7725, nil
	}
	mem5b1a7725 := allocArrayPrivateReplicaInfoTMemory(1)
	ref5b1a7725 := (*C.Array_PrivateReplicaInfo_t)(mem5b1a7725)
	allocs5b1a7725 := new(cgoAllocMap)
	allocs5b1a7725.Add(mem5b1a7725)

	var cptr_allocs *cgoAllocMap
	ref5b1a7725.ptr, cptr_allocs = unpackSSPrivateReplicaInfoT(x.Ptr)
	allocs5b1a7725.Borrow(cptr_allocs)

	var clen_allocs *cgoAllocMap
	ref5b1a7725.len, clen_allocs = (C.size_t)(x.Len), cgoAllocsUnknown
	allocs5b1a7725.Borrow(clen_allocs)

	x.ref5b1a7725 = ref5b1a7725
	x.allocs5b1a7725 = allocs5b1a7725
	return ref5b1a7725, allocs5b1a7725

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ArrayPrivateReplicaInfoT) PassValue() (C.Array_PrivateReplicaInfo_t, *cgoAllocMap) {
	if x.ref5b1a7725 != nil {
		return *x.ref5b1a7725, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ArrayPrivateReplicaInfoT) Deref() {
	if x.ref5b1a7725 == nil {
		return
	}
	packSSPrivateReplicaInfoT(x.Ptr, x.ref5b1a7725.ptr)
	x.Len = (SizeT)(x.ref5b1a7725.len)
}

// allocPublicReplicaInfoTMemory allocates memory for type C.PublicReplicaInfo_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPublicReplicaInfoTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPublicReplicaInfoTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPublicReplicaInfoTValue = unsafe.Sizeof([1]C.PublicReplicaInfo_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PublicReplicaInfoT) Ref() *C.PublicReplicaInfo_t {
	if x == nil {
		return nil
	}
	return x.ref2f93037
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PublicReplicaInfoT) Free() {
	if x != nil && x.allocs2f93037 != nil {
		x.allocs2f93037.(*cgoAllocMap).Free()
		x.ref2f93037 = nil
	}
}

// NewPublicReplicaInfoTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPublicReplicaInfoTRef(ref unsafe.Pointer) *PublicReplicaInfoT {
	if ref == nil {
		return nil
	}
	obj := new(PublicReplicaInfoT)
	obj.ref2f93037 = (*C.PublicReplicaInfo_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PublicReplicaInfoT) PassRef() (*C.PublicReplicaInfo_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2f93037 != nil {
		return x.ref2f93037, nil
	}
	mem2f93037 := allocPublicReplicaInfoTMemory(1)
	ref2f93037 := (*C.PublicReplicaInfo_t)(mem2f93037)
	allocs2f93037 := new(cgoAllocMap)
	allocs2f93037.Add(mem2f93037)

	var cregistered_proof_allocs *cgoAllocMap
	ref2f93037.registered_proof, cregistered_proof_allocs = (C.RegisteredPoStProof_t)(x.RegisteredProof), cgoAllocsUnknown
	allocs2f93037.Borrow(cregistered_proof_allocs)

	var ccomm_r_allocs *cgoAllocMap
	ref2f93037.comm_r, ccomm_r_allocs = x.CommR.PassValue()
	allocs2f93037.Borrow(ccomm_r_allocs)

	var csector_id_allocs *cgoAllocMap
	ref2f93037.sector_id, csector_id_allocs = (C.uint64_t)(x.SectorId), cgoAllocsUnknown
	allocs2f93037.Borrow(csector_id_allocs)

	x.ref2f93037 = ref2f93037
	x.allocs2f93037 = allocs2f93037
	return ref2f93037, allocs2f93037

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PublicReplicaInfoT) PassValue() (C.PublicReplicaInfo_t, *cgoAllocMap) {
	if x.ref2f93037 != nil {
		return *x.ref2f93037, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PublicReplicaInfoT) Deref() {
	if x.ref2f93037 == nil {
		return
	}
	x.RegisteredProof = (RegisteredPoStProofT)(x.ref2f93037.registered_proof)
	x.CommR = *NewUint832ArrayTRef(unsafe.Pointer(&x.ref2f93037.comm_r))
	x.SectorId = (Uint64T)(x.ref2f93037.sector_id)
}

// allocArrayPublicReplicaInfoTMemory allocates memory for type C.Array_PublicReplicaInfo_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocArrayPublicReplicaInfoTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfArrayPublicReplicaInfoTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfArrayPublicReplicaInfoTValue = unsafe.Sizeof([1]C.Array_PublicReplicaInfo_t{})

// allocPPublicReplicaInfoTMemory allocates memory for type *C.PublicReplicaInfo_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPPublicReplicaInfoTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPPublicReplicaInfoTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPPublicReplicaInfoTValue = unsafe.Sizeof([1]*C.PublicReplicaInfo_t{})

// unpackSSPublicReplicaInfoT transforms a sliced Go data structure into plain C format.
func unpackSSPublicReplicaInfoT(x [][]PublicReplicaInfoT) (unpacked **C.PublicReplicaInfo_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPPublicReplicaInfoTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.PublicReplicaInfo_t)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocPublicReplicaInfoTMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.PublicReplicaInfo_t)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.PublicReplicaInfo_t)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.PublicReplicaInfo_t)(h.Data)
	return
}

// packSSPublicReplicaInfoT reads sliced Go data structure out from plain C format.
func packSSPublicReplicaInfoT(v [][]PublicReplicaInfoT, ptr0 **C.PublicReplicaInfo_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.PublicReplicaInfo_t)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfPublicReplicaInfoTValue]C.PublicReplicaInfo_t)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewPublicReplicaInfoTRef(unsafe.Pointer(&ptr2))
		}
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ArrayPublicReplicaInfoT) Ref() *C.Array_PublicReplicaInfo_t {
	if x == nil {
		return nil
	}
	return x.refd4b4552b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ArrayPublicReplicaInfoT) Free() {
	if x != nil && x.allocsd4b4552b != nil {
		x.allocsd4b4552b.(*cgoAllocMap).Free()
		x.refd4b4552b = nil
	}
}

// NewArrayPublicReplicaInfoTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewArrayPublicReplicaInfoTRef(ref unsafe.Pointer) *ArrayPublicReplicaInfoT {
	if ref == nil {
		return nil
	}
	obj := new(ArrayPublicReplicaInfoT)
	obj.refd4b4552b = (*C.Array_PublicReplicaInfo_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ArrayPublicReplicaInfoT) PassRef() (*C.Array_PublicReplicaInfo_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd4b4552b != nil {
		return x.refd4b4552b, nil
	}
	memd4b4552b := allocArrayPublicReplicaInfoTMemory(1)
	refd4b4552b := (*C.Array_PublicReplicaInfo_t)(memd4b4552b)
	allocsd4b4552b := new(cgoAllocMap)
	allocsd4b4552b.Add(memd4b4552b)

	var cptr_allocs *cgoAllocMap
	refd4b4552b.ptr, cptr_allocs = unpackSSPublicReplicaInfoT(x.Ptr)
	allocsd4b4552b.Borrow(cptr_allocs)

	var clen_allocs *cgoAllocMap
	refd4b4552b.len, clen_allocs = (C.size_t)(x.Len), cgoAllocsUnknown
	allocsd4b4552b.Borrow(clen_allocs)

	x.refd4b4552b = refd4b4552b
	x.allocsd4b4552b = allocsd4b4552b
	return refd4b4552b, allocsd4b4552b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ArrayPublicReplicaInfoT) PassValue() (C.Array_PublicReplicaInfo_t, *cgoAllocMap) {
	if x.refd4b4552b != nil {
		return *x.refd4b4552b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ArrayPublicReplicaInfoT) Deref() {
	if x.refd4b4552b == nil {
		return
	}
	packSSPublicReplicaInfoT(x.Ptr, x.refd4b4552b.ptr)
	x.Len = (SizeT)(x.refd4b4552b.len)
}

// allocGenerateWindowPoStTMemory allocates memory for type C.GenerateWindowPoSt_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocGenerateWindowPoStTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfGenerateWindowPoStTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfGenerateWindowPoStTValue = unsafe.Sizeof([1]C.GenerateWindowPoSt_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *GenerateWindowPoStT) Ref() *C.GenerateWindowPoSt_t {
	if x == nil {
		return nil
	}
	return x.refcee66945
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *GenerateWindowPoStT) Free() {
	if x != nil && x.allocscee66945 != nil {
		x.allocscee66945.(*cgoAllocMap).Free()
		x.refcee66945 = nil
	}
}

// NewGenerateWindowPoStTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewGenerateWindowPoStTRef(ref unsafe.Pointer) *GenerateWindowPoStT {
	if ref == nil {
		return nil
	}
	obj := new(GenerateWindowPoStT)
	obj.refcee66945 = (*C.GenerateWindowPoSt_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *GenerateWindowPoStT) PassRef() (*C.GenerateWindowPoSt_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refcee66945 != nil {
		return x.refcee66945, nil
	}
	memcee66945 := allocGenerateWindowPoStTMemory(1)
	refcee66945 := (*C.GenerateWindowPoSt_t)(memcee66945)
	allocscee66945 := new(cgoAllocMap)
	allocscee66945.Add(memcee66945)

	var cproofs_allocs *cgoAllocMap
	refcee66945.proofs, cproofs_allocs = x.Proofs.PassValue()
	allocscee66945.Borrow(cproofs_allocs)

	var cfaulty_sectors_allocs *cgoAllocMap
	refcee66945.faulty_sectors, cfaulty_sectors_allocs = x.FaultySectors.PassValue()
	allocscee66945.Borrow(cfaulty_sectors_allocs)

	x.refcee66945 = refcee66945
	x.allocscee66945 = allocscee66945
	return refcee66945, allocscee66945

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x GenerateWindowPoStT) PassValue() (C.GenerateWindowPoSt_t, *cgoAllocMap) {
	if x.refcee66945 != nil {
		return *x.refcee66945, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *GenerateWindowPoStT) Deref() {
	if x.refcee66945 == nil {
		return
	}
	x.Proofs = *NewArrayPoStProofTRef(unsafe.Pointer(&x.refcee66945.proofs))
	x.FaultySectors = *NewArrayUint64TRef(unsafe.Pointer(&x.refcee66945.faulty_sectors))
}

// allocResultGenerateWindowPoStTMemory allocates memory for type C.Result_GenerateWindowPoSt_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocResultGenerateWindowPoStTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfResultGenerateWindowPoStTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfResultGenerateWindowPoStTValue = unsafe.Sizeof([1]C.Result_GenerateWindowPoSt_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ResultGenerateWindowPoStT) Ref() *C.Result_GenerateWindowPoSt_t {
	if x == nil {
		return nil
	}
	return x.ref16e6fa9b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ResultGenerateWindowPoStT) Free() {
	if x != nil && x.allocs16e6fa9b != nil {
		x.allocs16e6fa9b.(*cgoAllocMap).Free()
		x.ref16e6fa9b = nil
	}
}

// NewResultGenerateWindowPoStTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewResultGenerateWindowPoStTRef(ref unsafe.Pointer) *ResultGenerateWindowPoStT {
	if ref == nil {
		return nil
	}
	obj := new(ResultGenerateWindowPoStT)
	obj.ref16e6fa9b = (*C.Result_GenerateWindowPoSt_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ResultGenerateWindowPoStT) PassRef() (*C.Result_GenerateWindowPoSt_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref16e6fa9b != nil {
		return x.ref16e6fa9b, nil
	}
	mem16e6fa9b := allocResultGenerateWindowPoStTMemory(1)
	ref16e6fa9b := (*C.Result_GenerateWindowPoSt_t)(mem16e6fa9b)
	allocs16e6fa9b := new(cgoAllocMap)
	allocs16e6fa9b.Add(mem16e6fa9b)

	var cstatus_code_allocs *cgoAllocMap
	ref16e6fa9b.status_code, cstatus_code_allocs = (C.FCPResponseStatus_t)(x.StatusCode), cgoAllocsUnknown
	allocs16e6fa9b.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref16e6fa9b.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocs16e6fa9b.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	ref16e6fa9b.value, cvalue_allocs = x.Value.PassValue()
	allocs16e6fa9b.Borrow(cvalue_allocs)

	x.ref16e6fa9b = ref16e6fa9b
	x.allocs16e6fa9b = allocs16e6fa9b
	return ref16e6fa9b, allocs16e6fa9b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ResultGenerateWindowPoStT) PassValue() (C.Result_GenerateWindowPoSt_t, *cgoAllocMap) {
	if x.ref16e6fa9b != nil {
		return *x.ref16e6fa9b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ResultGenerateWindowPoStT) Deref() {
	if x.ref16e6fa9b == nil {
		return
	}
	x.StatusCode = (FCPResponseStatusT)(x.ref16e6fa9b.status_code)
	x.ErrorMsg = *NewArrayUint8TRef(unsafe.Pointer(&x.ref16e6fa9b.error_msg))
	x.Value = *NewGenerateWindowPoStTRef(unsafe.Pointer(&x.ref16e6fa9b.value))
}

// allocPartitionSnarkProofTMemory allocates memory for type C.PartitionSnarkProof_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPartitionSnarkProofTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPartitionSnarkProofTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPartitionSnarkProofTValue = unsafe.Sizeof([1]C.PartitionSnarkProof_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PartitionSnarkProofT) Ref() *C.PartitionSnarkProof_t {
	if x == nil {
		return nil
	}
	return x.ref66732a1e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PartitionSnarkProofT) Free() {
	if x != nil && x.allocs66732a1e != nil {
		x.allocs66732a1e.(*cgoAllocMap).Free()
		x.ref66732a1e = nil
	}
}

// NewPartitionSnarkProofTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPartitionSnarkProofTRef(ref unsafe.Pointer) *PartitionSnarkProofT {
	if ref == nil {
		return nil
	}
	obj := new(PartitionSnarkProofT)
	obj.ref66732a1e = (*C.PartitionSnarkProof_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PartitionSnarkProofT) PassRef() (*C.PartitionSnarkProof_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref66732a1e != nil {
		return x.ref66732a1e, nil
	}
	mem66732a1e := allocPartitionSnarkProofTMemory(1)
	ref66732a1e := (*C.PartitionSnarkProof_t)(mem66732a1e)
	allocs66732a1e := new(cgoAllocMap)
	allocs66732a1e.Add(mem66732a1e)

	var cregistered_proof_allocs *cgoAllocMap
	ref66732a1e.registered_proof, cregistered_proof_allocs = (C.RegisteredPoStProof_t)(x.RegisteredProof), cgoAllocsUnknown
	allocs66732a1e.Borrow(cregistered_proof_allocs)

	var cproof_allocs *cgoAllocMap
	ref66732a1e.proof, cproof_allocs = x.Proof.PassValue()
	allocs66732a1e.Borrow(cproof_allocs)

	x.ref66732a1e = ref66732a1e
	x.allocs66732a1e = allocs66732a1e
	return ref66732a1e, allocs66732a1e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PartitionSnarkProofT) PassValue() (C.PartitionSnarkProof_t, *cgoAllocMap) {
	if x.ref66732a1e != nil {
		return *x.ref66732a1e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PartitionSnarkProofT) Deref() {
	if x.ref66732a1e == nil {
		return
	}
	x.RegisteredProof = (RegisteredPoStProofT)(x.ref66732a1e.registered_proof)
	x.Proof = *NewArrayUint8TRef(unsafe.Pointer(&x.ref66732a1e.proof))
}

// allocArrayPartitionSnarkProofTMemory allocates memory for type C.Array_PartitionSnarkProof_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocArrayPartitionSnarkProofTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfArrayPartitionSnarkProofTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfArrayPartitionSnarkProofTValue = unsafe.Sizeof([1]C.Array_PartitionSnarkProof_t{})

// allocPPartitionSnarkProofTMemory allocates memory for type *C.PartitionSnarkProof_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPPartitionSnarkProofTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPPartitionSnarkProofTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPPartitionSnarkProofTValue = unsafe.Sizeof([1]*C.PartitionSnarkProof_t{})

// unpackSSPartitionSnarkProofT transforms a sliced Go data structure into plain C format.
func unpackSSPartitionSnarkProofT(x [][]PartitionSnarkProofT) (unpacked **C.PartitionSnarkProof_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPPartitionSnarkProofTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.PartitionSnarkProof_t)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocPartitionSnarkProofTMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.PartitionSnarkProof_t)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.PartitionSnarkProof_t)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.PartitionSnarkProof_t)(h.Data)
	return
}

// packSSPartitionSnarkProofT reads sliced Go data structure out from plain C format.
func packSSPartitionSnarkProofT(v [][]PartitionSnarkProofT, ptr0 **C.PartitionSnarkProof_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.PartitionSnarkProof_t)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfPartitionSnarkProofTValue]C.PartitionSnarkProof_t)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewPartitionSnarkProofTRef(unsafe.Pointer(&ptr2))
		}
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ArrayPartitionSnarkProofT) Ref() *C.Array_PartitionSnarkProof_t {
	if x == nil {
		return nil
	}
	return x.refbddc34d9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ArrayPartitionSnarkProofT) Free() {
	if x != nil && x.allocsbddc34d9 != nil {
		x.allocsbddc34d9.(*cgoAllocMap).Free()
		x.refbddc34d9 = nil
	}
}

// NewArrayPartitionSnarkProofTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewArrayPartitionSnarkProofTRef(ref unsafe.Pointer) *ArrayPartitionSnarkProofT {
	if ref == nil {
		return nil
	}
	obj := new(ArrayPartitionSnarkProofT)
	obj.refbddc34d9 = (*C.Array_PartitionSnarkProof_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ArrayPartitionSnarkProofT) PassRef() (*C.Array_PartitionSnarkProof_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refbddc34d9 != nil {
		return x.refbddc34d9, nil
	}
	membddc34d9 := allocArrayPartitionSnarkProofTMemory(1)
	refbddc34d9 := (*C.Array_PartitionSnarkProof_t)(membddc34d9)
	allocsbddc34d9 := new(cgoAllocMap)
	allocsbddc34d9.Add(membddc34d9)

	var cptr_allocs *cgoAllocMap
	refbddc34d9.ptr, cptr_allocs = unpackSSPartitionSnarkProofT(x.Ptr)
	allocsbddc34d9.Borrow(cptr_allocs)

	var clen_allocs *cgoAllocMap
	refbddc34d9.len, clen_allocs = (C.size_t)(x.Len), cgoAllocsUnknown
	allocsbddc34d9.Borrow(clen_allocs)

	x.refbddc34d9 = refbddc34d9
	x.allocsbddc34d9 = allocsbddc34d9
	return refbddc34d9, allocsbddc34d9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ArrayPartitionSnarkProofT) PassValue() (C.Array_PartitionSnarkProof_t, *cgoAllocMap) {
	if x.refbddc34d9 != nil {
		return *x.refbddc34d9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ArrayPartitionSnarkProofT) Deref() {
	if x.refbddc34d9 == nil {
		return
	}
	packSSPartitionSnarkProofT(x.Ptr, x.refbddc34d9.ptr)
	x.Len = (SizeT)(x.refbddc34d9.len)
}

// allocResultPoStProofTMemory allocates memory for type C.Result_PoStProof_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocResultPoStProofTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfResultPoStProofTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfResultPoStProofTValue = unsafe.Sizeof([1]C.Result_PoStProof_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ResultPoStProofT) Ref() *C.Result_PoStProof_t {
	if x == nil {
		return nil
	}
	return x.ref20cbfc0b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ResultPoStProofT) Free() {
	if x != nil && x.allocs20cbfc0b != nil {
		x.allocs20cbfc0b.(*cgoAllocMap).Free()
		x.ref20cbfc0b = nil
	}
}

// NewResultPoStProofTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewResultPoStProofTRef(ref unsafe.Pointer) *ResultPoStProofT {
	if ref == nil {
		return nil
	}
	obj := new(ResultPoStProofT)
	obj.ref20cbfc0b = (*C.Result_PoStProof_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ResultPoStProofT) PassRef() (*C.Result_PoStProof_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref20cbfc0b != nil {
		return x.ref20cbfc0b, nil
	}
	mem20cbfc0b := allocResultPoStProofTMemory(1)
	ref20cbfc0b := (*C.Result_PoStProof_t)(mem20cbfc0b)
	allocs20cbfc0b := new(cgoAllocMap)
	allocs20cbfc0b.Add(mem20cbfc0b)

	var cstatus_code_allocs *cgoAllocMap
	ref20cbfc0b.status_code, cstatus_code_allocs = (C.FCPResponseStatus_t)(x.StatusCode), cgoAllocsUnknown
	allocs20cbfc0b.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref20cbfc0b.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocs20cbfc0b.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	ref20cbfc0b.value, cvalue_allocs = x.Value.PassValue()
	allocs20cbfc0b.Borrow(cvalue_allocs)

	x.ref20cbfc0b = ref20cbfc0b
	x.allocs20cbfc0b = allocs20cbfc0b
	return ref20cbfc0b, allocs20cbfc0b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ResultPoStProofT) PassValue() (C.Result_PoStProof_t, *cgoAllocMap) {
	if x.ref20cbfc0b != nil {
		return *x.ref20cbfc0b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ResultPoStProofT) Deref() {
	if x.ref20cbfc0b == nil {
		return
	}
	x.StatusCode = (FCPResponseStatusT)(x.ref20cbfc0b.status_code)
	x.ErrorMsg = *NewArrayUint8TRef(unsafe.Pointer(&x.ref20cbfc0b.error_msg))
	x.Value = *NewPoStProofTRef(unsafe.Pointer(&x.ref20cbfc0b.value))
}

// allocResultSizeTMemory allocates memory for type C.Result_size_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocResultSizeTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfResultSizeTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfResultSizeTValue = unsafe.Sizeof([1]C.Result_size_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ResultSizeT) Ref() *C.Result_size_t {
	if x == nil {
		return nil
	}
	return x.refdf6206d4
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ResultSizeT) Free() {
	if x != nil && x.allocsdf6206d4 != nil {
		x.allocsdf6206d4.(*cgoAllocMap).Free()
		x.refdf6206d4 = nil
	}
}

// NewResultSizeTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewResultSizeTRef(ref unsafe.Pointer) *ResultSizeT {
	if ref == nil {
		return nil
	}
	obj := new(ResultSizeT)
	obj.refdf6206d4 = (*C.Result_size_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ResultSizeT) PassRef() (*C.Result_size_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refdf6206d4 != nil {
		return x.refdf6206d4, nil
	}
	memdf6206d4 := allocResultSizeTMemory(1)
	refdf6206d4 := (*C.Result_size_t)(memdf6206d4)
	allocsdf6206d4 := new(cgoAllocMap)
	allocsdf6206d4.Add(memdf6206d4)

	var cstatus_code_allocs *cgoAllocMap
	refdf6206d4.status_code, cstatus_code_allocs = (C.FCPResponseStatus_t)(x.StatusCode), cgoAllocsUnknown
	allocsdf6206d4.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	refdf6206d4.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocsdf6206d4.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	refdf6206d4.value, cvalue_allocs = (C.size_t)(x.Value), cgoAllocsUnknown
	allocsdf6206d4.Borrow(cvalue_allocs)

	x.refdf6206d4 = refdf6206d4
	x.allocsdf6206d4 = allocsdf6206d4
	return refdf6206d4, allocsdf6206d4

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ResultSizeT) PassValue() (C.Result_size_t, *cgoAllocMap) {
	if x.refdf6206d4 != nil {
		return *x.refdf6206d4, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ResultSizeT) Deref() {
	if x.refdf6206d4 == nil {
		return
	}
	x.StatusCode = (FCPResponseStatusT)(x.refdf6206d4.status_code)
	x.ErrorMsg = *NewArrayUint8TRef(unsafe.Pointer(&x.refdf6206d4.error_msg))
	x.Value = (SizeT)(x.refdf6206d4.value)
}

// allocGenerateSingleWindowPoStWithVanillaTMemory allocates memory for type C.GenerateSingleWindowPoStWithVanilla_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocGenerateSingleWindowPoStWithVanillaTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfGenerateSingleWindowPoStWithVanillaTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfGenerateSingleWindowPoStWithVanillaTValue = unsafe.Sizeof([1]C.GenerateSingleWindowPoStWithVanilla_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *GenerateSingleWindowPoStWithVanillaT) Ref() *C.GenerateSingleWindowPoStWithVanilla_t {
	if x == nil {
		return nil
	}
	return x.refe1ddcd34
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *GenerateSingleWindowPoStWithVanillaT) Free() {
	if x != nil && x.allocse1ddcd34 != nil {
		x.allocse1ddcd34.(*cgoAllocMap).Free()
		x.refe1ddcd34 = nil
	}
}

// NewGenerateSingleWindowPoStWithVanillaTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewGenerateSingleWindowPoStWithVanillaTRef(ref unsafe.Pointer) *GenerateSingleWindowPoStWithVanillaT {
	if ref == nil {
		return nil
	}
	obj := new(GenerateSingleWindowPoStWithVanillaT)
	obj.refe1ddcd34 = (*C.GenerateSingleWindowPoStWithVanilla_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *GenerateSingleWindowPoStWithVanillaT) PassRef() (*C.GenerateSingleWindowPoStWithVanilla_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe1ddcd34 != nil {
		return x.refe1ddcd34, nil
	}
	meme1ddcd34 := allocGenerateSingleWindowPoStWithVanillaTMemory(1)
	refe1ddcd34 := (*C.GenerateSingleWindowPoStWithVanilla_t)(meme1ddcd34)
	allocse1ddcd34 := new(cgoAllocMap)
	allocse1ddcd34.Add(meme1ddcd34)

	var cpartition_proof_allocs *cgoAllocMap
	refe1ddcd34.partition_proof, cpartition_proof_allocs = x.PartitionProof.PassValue()
	allocse1ddcd34.Borrow(cpartition_proof_allocs)

	var cfaulty_sectors_allocs *cgoAllocMap
	refe1ddcd34.faulty_sectors, cfaulty_sectors_allocs = x.FaultySectors.PassValue()
	allocse1ddcd34.Borrow(cfaulty_sectors_allocs)

	x.refe1ddcd34 = refe1ddcd34
	x.allocse1ddcd34 = allocse1ddcd34
	return refe1ddcd34, allocse1ddcd34

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x GenerateSingleWindowPoStWithVanillaT) PassValue() (C.GenerateSingleWindowPoStWithVanilla_t, *cgoAllocMap) {
	if x.refe1ddcd34 != nil {
		return *x.refe1ddcd34, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *GenerateSingleWindowPoStWithVanillaT) Deref() {
	if x.refe1ddcd34 == nil {
		return
	}
	x.PartitionProof = *NewPartitionSnarkProofTRef(unsafe.Pointer(&x.refe1ddcd34.partition_proof))
	x.FaultySectors = *NewArrayUint64TRef(unsafe.Pointer(&x.refe1ddcd34.faulty_sectors))
}

// allocResultGenerateSingleWindowPoStWithVanillaTMemory allocates memory for type C.Result_GenerateSingleWindowPoStWithVanilla_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocResultGenerateSingleWindowPoStWithVanillaTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfResultGenerateSingleWindowPoStWithVanillaTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfResultGenerateSingleWindowPoStWithVanillaTValue = unsafe.Sizeof([1]C.Result_GenerateSingleWindowPoStWithVanilla_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ResultGenerateSingleWindowPoStWithVanillaT) Ref() *C.Result_GenerateSingleWindowPoStWithVanilla_t {
	if x == nil {
		return nil
	}
	return x.ref54515f12
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ResultGenerateSingleWindowPoStWithVanillaT) Free() {
	if x != nil && x.allocs54515f12 != nil {
		x.allocs54515f12.(*cgoAllocMap).Free()
		x.ref54515f12 = nil
	}
}

// NewResultGenerateSingleWindowPoStWithVanillaTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewResultGenerateSingleWindowPoStWithVanillaTRef(ref unsafe.Pointer) *ResultGenerateSingleWindowPoStWithVanillaT {
	if ref == nil {
		return nil
	}
	obj := new(ResultGenerateSingleWindowPoStWithVanillaT)
	obj.ref54515f12 = (*C.Result_GenerateSingleWindowPoStWithVanilla_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ResultGenerateSingleWindowPoStWithVanillaT) PassRef() (*C.Result_GenerateSingleWindowPoStWithVanilla_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref54515f12 != nil {
		return x.ref54515f12, nil
	}
	mem54515f12 := allocResultGenerateSingleWindowPoStWithVanillaTMemory(1)
	ref54515f12 := (*C.Result_GenerateSingleWindowPoStWithVanilla_t)(mem54515f12)
	allocs54515f12 := new(cgoAllocMap)
	allocs54515f12.Add(mem54515f12)

	var cstatus_code_allocs *cgoAllocMap
	ref54515f12.status_code, cstatus_code_allocs = (C.FCPResponseStatus_t)(x.StatusCode), cgoAllocsUnknown
	allocs54515f12.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref54515f12.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocs54515f12.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	ref54515f12.value, cvalue_allocs = x.Value.PassValue()
	allocs54515f12.Borrow(cvalue_allocs)

	x.ref54515f12 = ref54515f12
	x.allocs54515f12 = allocs54515f12
	return ref54515f12, allocs54515f12

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ResultGenerateSingleWindowPoStWithVanillaT) PassValue() (C.Result_GenerateSingleWindowPoStWithVanilla_t, *cgoAllocMap) {
	if x.ref54515f12 != nil {
		return *x.ref54515f12, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ResultGenerateSingleWindowPoStWithVanillaT) Deref() {
	if x.ref54515f12 == nil {
		return
	}
	x.StatusCode = (FCPResponseStatusT)(x.ref54515f12.status_code)
	x.ErrorMsg = *NewArrayUint8TRef(unsafe.Pointer(&x.ref54515f12.error_msg))
	x.Value = *NewGenerateSingleWindowPoStWithVanillaTRef(unsafe.Pointer(&x.ref54515f12.value))
}

// allocEmptySectorUpdateEncodeIntoTMemory allocates memory for type C.EmptySectorUpdateEncodeInto_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocEmptySectorUpdateEncodeIntoTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfEmptySectorUpdateEncodeIntoTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfEmptySectorUpdateEncodeIntoTValue = unsafe.Sizeof([1]C.EmptySectorUpdateEncodeInto_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *EmptySectorUpdateEncodeIntoT) Ref() *C.EmptySectorUpdateEncodeInto_t {
	if x == nil {
		return nil
	}
	return x.ref7572da08
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *EmptySectorUpdateEncodeIntoT) Free() {
	if x != nil && x.allocs7572da08 != nil {
		x.allocs7572da08.(*cgoAllocMap).Free()
		x.ref7572da08 = nil
	}
}

// NewEmptySectorUpdateEncodeIntoTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewEmptySectorUpdateEncodeIntoTRef(ref unsafe.Pointer) *EmptySectorUpdateEncodeIntoT {
	if ref == nil {
		return nil
	}
	obj := new(EmptySectorUpdateEncodeIntoT)
	obj.ref7572da08 = (*C.EmptySectorUpdateEncodeInto_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *EmptySectorUpdateEncodeIntoT) PassRef() (*C.EmptySectorUpdateEncodeInto_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7572da08 != nil {
		return x.ref7572da08, nil
	}
	mem7572da08 := allocEmptySectorUpdateEncodeIntoTMemory(1)
	ref7572da08 := (*C.EmptySectorUpdateEncodeInto_t)(mem7572da08)
	allocs7572da08 := new(cgoAllocMap)
	allocs7572da08.Add(mem7572da08)

	var ccomm_r_new_allocs *cgoAllocMap
	ref7572da08.comm_r_new, ccomm_r_new_allocs = x.CommRNew.PassValue()
	allocs7572da08.Borrow(ccomm_r_new_allocs)

	var ccomm_r_last_new_allocs *cgoAllocMap
	ref7572da08.comm_r_last_new, ccomm_r_last_new_allocs = x.CommRLastNew.PassValue()
	allocs7572da08.Borrow(ccomm_r_last_new_allocs)

	var ccomm_d_new_allocs *cgoAllocMap
	ref7572da08.comm_d_new, ccomm_d_new_allocs = x.CommDNew.PassValue()
	allocs7572da08.Borrow(ccomm_d_new_allocs)

	x.ref7572da08 = ref7572da08
	x.allocs7572da08 = allocs7572da08
	return ref7572da08, allocs7572da08

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x EmptySectorUpdateEncodeIntoT) PassValue() (C.EmptySectorUpdateEncodeInto_t, *cgoAllocMap) {
	if x.ref7572da08 != nil {
		return *x.ref7572da08, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *EmptySectorUpdateEncodeIntoT) Deref() {
	if x.ref7572da08 == nil {
		return
	}
	x.CommRNew = *NewUint832ArrayTRef(unsafe.Pointer(&x.ref7572da08.comm_r_new))
	x.CommRLastNew = *NewUint832ArrayTRef(unsafe.Pointer(&x.ref7572da08.comm_r_last_new))
	x.CommDNew = *NewUint832ArrayTRef(unsafe.Pointer(&x.ref7572da08.comm_d_new))
}

// allocResultEmptySectorUpdateEncodeIntoTMemory allocates memory for type C.Result_EmptySectorUpdateEncodeInto_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocResultEmptySectorUpdateEncodeIntoTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfResultEmptySectorUpdateEncodeIntoTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfResultEmptySectorUpdateEncodeIntoTValue = unsafe.Sizeof([1]C.Result_EmptySectorUpdateEncodeInto_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ResultEmptySectorUpdateEncodeIntoT) Ref() *C.Result_EmptySectorUpdateEncodeInto_t {
	if x == nil {
		return nil
	}
	return x.reff6d56df3
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ResultEmptySectorUpdateEncodeIntoT) Free() {
	if x != nil && x.allocsf6d56df3 != nil {
		x.allocsf6d56df3.(*cgoAllocMap).Free()
		x.reff6d56df3 = nil
	}
}

// NewResultEmptySectorUpdateEncodeIntoTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewResultEmptySectorUpdateEncodeIntoTRef(ref unsafe.Pointer) *ResultEmptySectorUpdateEncodeIntoT {
	if ref == nil {
		return nil
	}
	obj := new(ResultEmptySectorUpdateEncodeIntoT)
	obj.reff6d56df3 = (*C.Result_EmptySectorUpdateEncodeInto_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ResultEmptySectorUpdateEncodeIntoT) PassRef() (*C.Result_EmptySectorUpdateEncodeInto_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff6d56df3 != nil {
		return x.reff6d56df3, nil
	}
	memf6d56df3 := allocResultEmptySectorUpdateEncodeIntoTMemory(1)
	reff6d56df3 := (*C.Result_EmptySectorUpdateEncodeInto_t)(memf6d56df3)
	allocsf6d56df3 := new(cgoAllocMap)
	allocsf6d56df3.Add(memf6d56df3)

	var cstatus_code_allocs *cgoAllocMap
	reff6d56df3.status_code, cstatus_code_allocs = (C.FCPResponseStatus_t)(x.StatusCode), cgoAllocsUnknown
	allocsf6d56df3.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	reff6d56df3.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocsf6d56df3.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	reff6d56df3.value, cvalue_allocs = x.Value.PassValue()
	allocsf6d56df3.Borrow(cvalue_allocs)

	x.reff6d56df3 = reff6d56df3
	x.allocsf6d56df3 = allocsf6d56df3
	return reff6d56df3, allocsf6d56df3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ResultEmptySectorUpdateEncodeIntoT) PassValue() (C.Result_EmptySectorUpdateEncodeInto_t, *cgoAllocMap) {
	if x.reff6d56df3 != nil {
		return *x.reff6d56df3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ResultEmptySectorUpdateEncodeIntoT) Deref() {
	if x.reff6d56df3 == nil {
		return
	}
	x.StatusCode = (FCPResponseStatusT)(x.reff6d56df3.status_code)
	x.ErrorMsg = *NewArrayUint8TRef(unsafe.Pointer(&x.reff6d56df3.error_msg))
	x.Value = *NewEmptySectorUpdateEncodeIntoTRef(unsafe.Pointer(&x.reff6d56df3.value))
}

// allocGeneratePieceCommitmentTMemory allocates memory for type C.GeneratePieceCommitment_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocGeneratePieceCommitmentTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfGeneratePieceCommitmentTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfGeneratePieceCommitmentTValue = unsafe.Sizeof([1]C.GeneratePieceCommitment_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *GeneratePieceCommitmentT) Ref() *C.GeneratePieceCommitment_t {
	if x == nil {
		return nil
	}
	return x.refba03f700
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *GeneratePieceCommitmentT) Free() {
	if x != nil && x.allocsba03f700 != nil {
		x.allocsba03f700.(*cgoAllocMap).Free()
		x.refba03f700 = nil
	}
}

// NewGeneratePieceCommitmentTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewGeneratePieceCommitmentTRef(ref unsafe.Pointer) *GeneratePieceCommitmentT {
	if ref == nil {
		return nil
	}
	obj := new(GeneratePieceCommitmentT)
	obj.refba03f700 = (*C.GeneratePieceCommitment_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *GeneratePieceCommitmentT) PassRef() (*C.GeneratePieceCommitment_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refba03f700 != nil {
		return x.refba03f700, nil
	}
	memba03f700 := allocGeneratePieceCommitmentTMemory(1)
	refba03f700 := (*C.GeneratePieceCommitment_t)(memba03f700)
	allocsba03f700 := new(cgoAllocMap)
	allocsba03f700.Add(memba03f700)

	var ccomm_p_allocs *cgoAllocMap
	refba03f700.comm_p, ccomm_p_allocs = x.CommP.PassValue()
	allocsba03f700.Borrow(ccomm_p_allocs)

	var cnum_bytes_aligned_allocs *cgoAllocMap
	refba03f700.num_bytes_aligned, cnum_bytes_aligned_allocs = (C.uint64_t)(x.NumBytesAligned), cgoAllocsUnknown
	allocsba03f700.Borrow(cnum_bytes_aligned_allocs)

	x.refba03f700 = refba03f700
	x.allocsba03f700 = allocsba03f700
	return refba03f700, allocsba03f700

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x GeneratePieceCommitmentT) PassValue() (C.GeneratePieceCommitment_t, *cgoAllocMap) {
	if x.refba03f700 != nil {
		return *x.refba03f700, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *GeneratePieceCommitmentT) Deref() {
	if x.refba03f700 == nil {
		return
	}
	x.CommP = *NewUint832ArrayTRef(unsafe.Pointer(&x.refba03f700.comm_p))
	x.NumBytesAligned = (Uint64T)(x.refba03f700.num_bytes_aligned)
}

// allocResultGeneratePieceCommitmentTMemory allocates memory for type C.Result_GeneratePieceCommitment_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocResultGeneratePieceCommitmentTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfResultGeneratePieceCommitmentTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfResultGeneratePieceCommitmentTValue = unsafe.Sizeof([1]C.Result_GeneratePieceCommitment_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ResultGeneratePieceCommitmentT) Ref() *C.Result_GeneratePieceCommitment_t {
	if x == nil {
		return nil
	}
	return x.ref6ad23765
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ResultGeneratePieceCommitmentT) Free() {
	if x != nil && x.allocs6ad23765 != nil {
		x.allocs6ad23765.(*cgoAllocMap).Free()
		x.ref6ad23765 = nil
	}
}

// NewResultGeneratePieceCommitmentTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewResultGeneratePieceCommitmentTRef(ref unsafe.Pointer) *ResultGeneratePieceCommitmentT {
	if ref == nil {
		return nil
	}
	obj := new(ResultGeneratePieceCommitmentT)
	obj.ref6ad23765 = (*C.Result_GeneratePieceCommitment_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ResultGeneratePieceCommitmentT) PassRef() (*C.Result_GeneratePieceCommitment_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6ad23765 != nil {
		return x.ref6ad23765, nil
	}
	mem6ad23765 := allocResultGeneratePieceCommitmentTMemory(1)
	ref6ad23765 := (*C.Result_GeneratePieceCommitment_t)(mem6ad23765)
	allocs6ad23765 := new(cgoAllocMap)
	allocs6ad23765.Add(mem6ad23765)

	var cstatus_code_allocs *cgoAllocMap
	ref6ad23765.status_code, cstatus_code_allocs = (C.FCPResponseStatus_t)(x.StatusCode), cgoAllocsUnknown
	allocs6ad23765.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref6ad23765.error_msg, cerror_msg_allocs = x.ErrorMsg.PassValue()
	allocs6ad23765.Borrow(cerror_msg_allocs)

	var cvalue_allocs *cgoAllocMap
	ref6ad23765.value, cvalue_allocs = x.Value.PassValue()
	allocs6ad23765.Borrow(cvalue_allocs)

	x.ref6ad23765 = ref6ad23765
	x.allocs6ad23765 = allocs6ad23765
	return ref6ad23765, allocs6ad23765

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ResultGeneratePieceCommitmentT) PassValue() (C.Result_GeneratePieceCommitment_t, *cgoAllocMap) {
	if x.ref6ad23765 != nil {
		return *x.ref6ad23765, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ResultGeneratePieceCommitmentT) Deref() {
	if x.ref6ad23765 == nil {
		return
	}
	x.StatusCode = (FCPResponseStatusT)(x.ref6ad23765.status_code)
	x.ErrorMsg = *NewArrayUint8TRef(unsafe.Pointer(&x.ref6ad23765.error_msg))
	x.Value = *NewGeneratePieceCommitmentTRef(unsafe.Pointer(&x.ref6ad23765.value))
}

// copyPCharBytes copies the data from Go slice as *C.char.
func copyPCharBytes(slice *sliceHeader) (*C.char, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfCharValue) * slice.Len,
		Cap:  int(sizeOfCharValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.char)(mem0), allocs
}

// allocCharMemory allocates memory for type C.char in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCharMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCharValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCharValue = unsafe.Sizeof([1]C.char{})

// unpackArgSResultArrayArrayUint8T transforms a sliced Go data structure into plain C format.
func unpackArgSResultArrayArrayUint8T(x []ResultArrayArrayUint8T) (unpacked *C.Result_Array_Array_uint8_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocResultArrayArrayUint8TMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Result_Array_Array_uint8_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Result_Array_Array_uint8_t)(h.Data)
	return
}

// packSResultArrayArrayUint8T reads sliced Go data structure out from plain C format.
func packSResultArrayArrayUint8T(v []ResultArrayArrayUint8T, ptr0 *C.Result_Array_Array_uint8_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfResultArrayArrayUint8TValue]C.Result_Array_Array_uint8_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewResultArrayArrayUint8TRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSResultVoidT transforms a sliced Go data structure into plain C format.
func unpackArgSResultVoidT(x []ResultVoidT) (unpacked *C.Result_void_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocResultVoidTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Result_void_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Result_void_t)(h.Data)
	return
}

// packSResultVoidT reads sliced Go data structure out from plain C format.
func packSResultVoidT(v []ResultVoidT, ptr0 *C.Result_void_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfResultVoidTValue]C.Result_void_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewResultVoidTRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSArrayUint8T transforms a sliced Go data structure into plain C format.
func unpackArgSArrayUint8T(x []ArrayUint8T) (unpacked *C.Array_uint8_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocArrayUint8TMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Array_uint8_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Array_uint8_t)(h.Data)
	return
}

// packSArrayUint8T reads sliced Go data structure out from plain C format.
func packSArrayUint8T(v []ArrayUint8T, ptr0 *C.Array_uint8_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfArrayUint8TValue]C.Array_uint8_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewArrayUint8TRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSUint896ArrayT transforms a sliced Go data structure into plain C format.
func unpackArgSUint896ArrayT(x []Uint896ArrayT) (unpacked *C.uint8_96_array_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocUint896ArrayTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.uint8_96_array_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.uint8_96_array_t)(h.Data)
	return
}

// packSUint896ArrayT reads sliced Go data structure out from plain C format.
func packSUint896ArrayT(v []Uint896ArrayT, ptr0 *C.uint8_96_array_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfUint896ArrayTValue]C.uint8_96_array_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewUint896ArrayTRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSArraySizeT transforms a sliced Go data structure into plain C format.
func unpackArgSArraySizeT(x []ArraySizeT) (unpacked *C.Array_size_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocArraySizeTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Array_size_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Array_size_t)(h.Data)
	return
}

// packSArraySizeT reads sliced Go data structure out from plain C format.
func packSArraySizeT(v []ArraySizeT, ptr0 *C.Array_size_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfArraySizeTValue]C.Array_size_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewArraySizeTRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSUint832ArrayT transforms a sliced Go data structure into plain C format.
func unpackArgSUint832ArrayT(x []Uint832ArrayT) (unpacked *C.uint8_32_array_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocUint832ArrayTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.uint8_32_array_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.uint8_32_array_t)(h.Data)
	return
}

// packSUint832ArrayT reads sliced Go data structure out from plain C format.
func packSUint832ArrayT(v []Uint832ArrayT, ptr0 *C.uint8_32_array_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfUint832ArrayTValue]C.uint8_32_array_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewUint832ArrayTRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSZeroSignatureResponseT transforms a sliced Go data structure into plain C format.
func unpackArgSZeroSignatureResponseT(x []ZeroSignatureResponseT) (unpacked *C.ZeroSignatureResponse_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocZeroSignatureResponseTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.ZeroSignatureResponse_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.ZeroSignatureResponse_t)(h.Data)
	return
}

// packSZeroSignatureResponseT reads sliced Go data structure out from plain C format.
func packSZeroSignatureResponseT(v []ZeroSignatureResponseT, ptr0 *C.ZeroSignatureResponse_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfZeroSignatureResponseTValue]C.ZeroSignatureResponse_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewZeroSignatureResponseTRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSArrayUint64T transforms a sliced Go data structure into plain C format.
func unpackArgSArrayUint64T(x []ArrayUint64T) (unpacked *C.Array_uint64_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocArrayUint64TMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Array_uint64_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Array_uint64_t)(h.Data)
	return
}

// packSArrayUint64T reads sliced Go data structure out from plain C format.
func packSArrayUint64T(v []ArrayUint64T, ptr0 *C.Array_uint64_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfArrayUint64TValue]C.Array_uint64_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewArrayUint64TRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSArrayPublicPieceInfoT transforms a sliced Go data structure into plain C format.
func unpackArgSArrayPublicPieceInfoT(x []ArrayPublicPieceInfoT) (unpacked *C.Array_PublicPieceInfo_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocArrayPublicPieceInfoTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Array_PublicPieceInfo_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Array_PublicPieceInfo_t)(h.Data)
	return
}

// packSArrayPublicPieceInfoT reads sliced Go data structure out from plain C format.
func packSArrayPublicPieceInfoT(v []ArrayPublicPieceInfoT, ptr0 *C.Array_PublicPieceInfo_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfArrayPublicPieceInfoTValue]C.Array_PublicPieceInfo_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewArrayPublicPieceInfoTRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSArraySealCommitPhase2T transforms a sliced Go data structure into plain C format.
func unpackArgSArraySealCommitPhase2T(x []ArraySealCommitPhase2T) (unpacked *C.Array_SealCommitPhase2_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocArraySealCommitPhase2TMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Array_SealCommitPhase2_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Array_SealCommitPhase2_t)(h.Data)
	return
}

// packSArraySealCommitPhase2T reads sliced Go data structure out from plain C format.
func packSArraySealCommitPhase2T(v []ArraySealCommitPhase2T, ptr0 *C.Array_SealCommitPhase2_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfArraySealCommitPhase2TValue]C.Array_SealCommitPhase2_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewArraySealCommitPhase2TRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSArrayAggregationInputsT transforms a sliced Go data structure into plain C format.
func unpackArgSArrayAggregationInputsT(x []ArrayAggregationInputsT) (unpacked *C.Array_AggregationInputs_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocArrayAggregationInputsTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Array_AggregationInputs_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Array_AggregationInputs_t)(h.Data)
	return
}

// packSArrayAggregationInputsT reads sliced Go data structure out from plain C format.
func packSArrayAggregationInputsT(v []ArrayAggregationInputsT, ptr0 *C.Array_AggregationInputs_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfArrayAggregationInputsTValue]C.Array_AggregationInputs_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewArrayAggregationInputsTRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSArrayArrayUint8T transforms a sliced Go data structure into plain C format.
func unpackArgSArrayArrayUint8T(x []ArrayArrayUint8T) (unpacked *C.Array_Array_uint8_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocArrayArrayUint8TMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Array_Array_uint8_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Array_Array_uint8_t)(h.Data)
	return
}

// packSArrayArrayUint8T reads sliced Go data structure out from plain C format.
func packSArrayArrayUint8T(v []ArrayArrayUint8T, ptr0 *C.Array_Array_uint8_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfArrayArrayUint8TValue]C.Array_Array_uint8_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewArrayArrayUint8TRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSArrayPrivateReplicaInfoT transforms a sliced Go data structure into plain C format.
func unpackArgSArrayPrivateReplicaInfoT(x []ArrayPrivateReplicaInfoT) (unpacked *C.Array_PrivateReplicaInfo_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocArrayPrivateReplicaInfoTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Array_PrivateReplicaInfo_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Array_PrivateReplicaInfo_t)(h.Data)
	return
}

// packSArrayPrivateReplicaInfoT reads sliced Go data structure out from plain C format.
func packSArrayPrivateReplicaInfoT(v []ArrayPrivateReplicaInfoT, ptr0 *C.Array_PrivateReplicaInfo_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfArrayPrivateReplicaInfoTValue]C.Array_PrivateReplicaInfo_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewArrayPrivateReplicaInfoTRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSArrayPublicReplicaInfoT transforms a sliced Go data structure into plain C format.
func unpackArgSArrayPublicReplicaInfoT(x []ArrayPublicReplicaInfoT) (unpacked *C.Array_PublicReplicaInfo_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocArrayPublicReplicaInfoTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Array_PublicReplicaInfo_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Array_PublicReplicaInfo_t)(h.Data)
	return
}

// packSArrayPublicReplicaInfoT reads sliced Go data structure out from plain C format.
func packSArrayPublicReplicaInfoT(v []ArrayPublicReplicaInfoT, ptr0 *C.Array_PublicReplicaInfo_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfArrayPublicReplicaInfoTValue]C.Array_PublicReplicaInfo_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewArrayPublicReplicaInfoTRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSArrayPoStProofT transforms a sliced Go data structure into plain C format.
func unpackArgSArrayPoStProofT(x []ArrayPoStProofT) (unpacked *C.Array_PoStProof_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocArrayPoStProofTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Array_PoStProof_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Array_PoStProof_t)(h.Data)
	return
}

// packSArrayPoStProofT reads sliced Go data structure out from plain C format.
func packSArrayPoStProofT(v []ArrayPoStProofT, ptr0 *C.Array_PoStProof_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfArrayPoStProofTValue]C.Array_PoStProof_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewArrayPoStProofTRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSArrayPartitionSnarkProofT transforms a sliced Go data structure into plain C format.
func unpackArgSArrayPartitionSnarkProofT(x []ArrayPartitionSnarkProofT) (unpacked *C.Array_PartitionSnarkProof_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocArrayPartitionSnarkProofTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Array_PartitionSnarkProof_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Array_PartitionSnarkProof_t)(h.Data)
	return
}

// packSArrayPartitionSnarkProofT reads sliced Go data structure out from plain C format.
func packSArrayPartitionSnarkProofT(v []ArrayPartitionSnarkProofT, ptr0 *C.Array_PartitionSnarkProof_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfArrayPartitionSnarkProofTValue]C.Array_PartitionSnarkProof_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewArrayPartitionSnarkProofTRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSResultWriteWithAlignmentT transforms a sliced Go data structure into plain C format.
func unpackArgSResultWriteWithAlignmentT(x []ResultWriteWithAlignmentT) (unpacked *C.Result_WriteWithAlignment_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocResultWriteWithAlignmentTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Result_WriteWithAlignment_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Result_WriteWithAlignment_t)(h.Data)
	return
}

// packSResultWriteWithAlignmentT reads sliced Go data structure out from plain C format.
func packSResultWriteWithAlignmentT(v []ResultWriteWithAlignmentT, ptr0 *C.Result_WriteWithAlignment_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfResultWriteWithAlignmentTValue]C.Result_WriteWithAlignment_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewResultWriteWithAlignmentTRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSResultWriteWithoutAlignmentT transforms a sliced Go data structure into plain C format.
func unpackArgSResultWriteWithoutAlignmentT(x []ResultWriteWithoutAlignmentT) (unpacked *C.Result_WriteWithoutAlignment_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocResultWriteWithoutAlignmentTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Result_WriteWithoutAlignment_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Result_WriteWithoutAlignment_t)(h.Data)
	return
}

// packSResultWriteWithoutAlignmentT reads sliced Go data structure out from plain C format.
func packSResultWriteWithoutAlignmentT(v []ResultWriteWithoutAlignmentT, ptr0 *C.Result_WriteWithoutAlignment_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfResultWriteWithoutAlignmentTValue]C.Result_WriteWithoutAlignment_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewResultWriteWithoutAlignmentTRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSResultByteArray32T transforms a sliced Go data structure into plain C format.
func unpackArgSResultByteArray32T(x []ResultByteArray32T) (unpacked *C.Result_ByteArray32_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocResultByteArray32TMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Result_ByteArray32_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Result_ByteArray32_t)(h.Data)
	return
}

// packSResultByteArray32T reads sliced Go data structure out from plain C format.
func packSResultByteArray32T(v []ResultByteArray32T, ptr0 *C.Result_ByteArray32_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfResultByteArray32TValue]C.Result_ByteArray32_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewResultByteArray32TRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSResultArrayUint8T transforms a sliced Go data structure into plain C format.
func unpackArgSResultArrayUint8T(x []ResultArrayUint8T) (unpacked *C.Result_Array_uint8_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocResultArrayUint8TMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Result_Array_uint8_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Result_Array_uint8_t)(h.Data)
	return
}

// packSResultArrayUint8T reads sliced Go data structure out from plain C format.
func packSResultArrayUint8T(v []ResultArrayUint8T, ptr0 *C.Result_Array_uint8_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfResultArrayUint8TValue]C.Result_Array_uint8_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewResultArrayUint8TRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSResultSealPreCommitPhase2T transforms a sliced Go data structure into plain C format.
func unpackArgSResultSealPreCommitPhase2T(x []ResultSealPreCommitPhase2T) (unpacked *C.Result_SealPreCommitPhase2_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocResultSealPreCommitPhase2TMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Result_SealPreCommitPhase2_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Result_SealPreCommitPhase2_t)(h.Data)
	return
}

// packSResultSealPreCommitPhase2T reads sliced Go data structure out from plain C format.
func packSResultSealPreCommitPhase2T(v []ResultSealPreCommitPhase2T, ptr0 *C.Result_SealPreCommitPhase2_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfResultSealPreCommitPhase2TValue]C.Result_SealPreCommitPhase2_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewResultSealPreCommitPhase2TRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSResultSealCommitPhase2T transforms a sliced Go data structure into plain C format.
func unpackArgSResultSealCommitPhase2T(x []ResultSealCommitPhase2T) (unpacked *C.Result_SealCommitPhase2_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocResultSealCommitPhase2TMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Result_SealCommitPhase2_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Result_SealCommitPhase2_t)(h.Data)
	return
}

// packSResultSealCommitPhase2T reads sliced Go data structure out from plain C format.
func packSResultSealCommitPhase2T(v []ResultSealCommitPhase2T, ptr0 *C.Result_SealCommitPhase2_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfResultSealCommitPhase2TValue]C.Result_SealCommitPhase2_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewResultSealCommitPhase2TRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSResultGeneratePieceCommitmentT transforms a sliced Go data structure into plain C format.
func unpackArgSResultGeneratePieceCommitmentT(x []ResultGeneratePieceCommitmentT) (unpacked *C.Result_GeneratePieceCommitment_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocResultGeneratePieceCommitmentTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Result_GeneratePieceCommitment_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Result_GeneratePieceCommitment_t)(h.Data)
	return
}

// packSResultGeneratePieceCommitmentT reads sliced Go data structure out from plain C format.
func packSResultGeneratePieceCommitmentT(v []ResultGeneratePieceCommitmentT, ptr0 *C.Result_GeneratePieceCommitment_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfResultGeneratePieceCommitmentTValue]C.Result_GeneratePieceCommitment_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewResultGeneratePieceCommitmentTRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSResultBoolT transforms a sliced Go data structure into plain C format.
func unpackArgSResultBoolT(x []ResultBoolT) (unpacked *C.Result_bool_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocResultBoolTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Result_bool_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Result_bool_t)(h.Data)
	return
}

// packSResultBoolT reads sliced Go data structure out from plain C format.
func packSResultBoolT(v []ResultBoolT, ptr0 *C.Result_bool_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfResultBoolTValue]C.Result_bool_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewResultBoolTRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSResultGenerateFallbackSectorChallengesT transforms a sliced Go data structure into plain C format.
func unpackArgSResultGenerateFallbackSectorChallengesT(x []ResultGenerateFallbackSectorChallengesT) (unpacked *C.Result_GenerateFallbackSectorChallenges_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocResultGenerateFallbackSectorChallengesTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Result_GenerateFallbackSectorChallenges_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Result_GenerateFallbackSectorChallenges_t)(h.Data)
	return
}

// packSResultGenerateFallbackSectorChallengesT reads sliced Go data structure out from plain C format.
func packSResultGenerateFallbackSectorChallengesT(v []ResultGenerateFallbackSectorChallengesT, ptr0 *C.Result_GenerateFallbackSectorChallenges_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfResultGenerateFallbackSectorChallengesTValue]C.Result_GenerateFallbackSectorChallenges_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewResultGenerateFallbackSectorChallengesTRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSResultGenerateSingleWindowPoStWithVanillaT transforms a sliced Go data structure into plain C format.
func unpackArgSResultGenerateSingleWindowPoStWithVanillaT(x []ResultGenerateSingleWindowPoStWithVanillaT) (unpacked *C.Result_GenerateSingleWindowPoStWithVanilla_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocResultGenerateSingleWindowPoStWithVanillaTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Result_GenerateSingleWindowPoStWithVanilla_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Result_GenerateSingleWindowPoStWithVanilla_t)(h.Data)
	return
}

// packSResultGenerateSingleWindowPoStWithVanillaT reads sliced Go data structure out from plain C format.
func packSResultGenerateSingleWindowPoStWithVanillaT(v []ResultGenerateSingleWindowPoStWithVanillaT, ptr0 *C.Result_GenerateSingleWindowPoStWithVanilla_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfResultGenerateSingleWindowPoStWithVanillaTValue]C.Result_GenerateSingleWindowPoStWithVanilla_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewResultGenerateSingleWindowPoStWithVanillaTRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSResultSizeT transforms a sliced Go data structure into plain C format.
func unpackArgSResultSizeT(x []ResultSizeT) (unpacked *C.Result_size_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocResultSizeTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Result_size_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Result_size_t)(h.Data)
	return
}

// packSResultSizeT reads sliced Go data structure out from plain C format.
func packSResultSizeT(v []ResultSizeT, ptr0 *C.Result_size_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfResultSizeTValue]C.Result_size_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewResultSizeTRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSResultPoStProofT transforms a sliced Go data structure into plain C format.
func unpackArgSResultPoStProofT(x []ResultPoStProofT) (unpacked *C.Result_PoStProof_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocResultPoStProofTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Result_PoStProof_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Result_PoStProof_t)(h.Data)
	return
}

// packSResultPoStProofT reads sliced Go data structure out from plain C format.
func packSResultPoStProofT(v []ResultPoStProofT, ptr0 *C.Result_PoStProof_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfResultPoStProofTValue]C.Result_PoStProof_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewResultPoStProofTRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSResultArrayPoStProofT transforms a sliced Go data structure into plain C format.
func unpackArgSResultArrayPoStProofT(x []ResultArrayPoStProofT) (unpacked *C.Result_Array_PoStProof_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocResultArrayPoStProofTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Result_Array_PoStProof_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Result_Array_PoStProof_t)(h.Data)
	return
}

// packSResultArrayPoStProofT reads sliced Go data structure out from plain C format.
func packSResultArrayPoStProofT(v []ResultArrayPoStProofT, ptr0 *C.Result_Array_PoStProof_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfResultArrayPoStProofTValue]C.Result_Array_PoStProof_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewResultArrayPoStProofTRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSResultGenerateWindowPoStT transforms a sliced Go data structure into plain C format.
func unpackArgSResultGenerateWindowPoStT(x []ResultGenerateWindowPoStT) (unpacked *C.Result_GenerateWindowPoSt_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocResultGenerateWindowPoStTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Result_GenerateWindowPoSt_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Result_GenerateWindowPoSt_t)(h.Data)
	return
}

// packSResultGenerateWindowPoStT reads sliced Go data structure out from plain C format.
func packSResultGenerateWindowPoStT(v []ResultGenerateWindowPoStT, ptr0 *C.Result_GenerateWindowPoSt_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfResultGenerateWindowPoStTValue]C.Result_GenerateWindowPoSt_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewResultGenerateWindowPoStTRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSResultArrayUint64T transforms a sliced Go data structure into plain C format.
func unpackArgSResultArrayUint64T(x []ResultArrayUint64T) (unpacked *C.Result_Array_uint64_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocResultArrayUint64TMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Result_Array_uint64_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Result_Array_uint64_t)(h.Data)
	return
}

// packSResultArrayUint64T reads sliced Go data structure out from plain C format.
func packSResultArrayUint64T(v []ResultArrayUint64T, ptr0 *C.Result_Array_uint64_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfResultArrayUint64TValue]C.Result_Array_uint64_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewResultArrayUint64TRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSResultEmptySectorUpdateEncodeIntoT transforms a sliced Go data structure into plain C format.
func unpackArgSResultEmptySectorUpdateEncodeIntoT(x []ResultEmptySectorUpdateEncodeIntoT) (unpacked *C.Result_EmptySectorUpdateEncodeInto_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocResultEmptySectorUpdateEncodeIntoTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Result_EmptySectorUpdateEncodeInto_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Result_EmptySectorUpdateEncodeInto_t)(h.Data)
	return
}

// packSResultEmptySectorUpdateEncodeIntoT reads sliced Go data structure out from plain C format.
func packSResultEmptySectorUpdateEncodeIntoT(v []ResultEmptySectorUpdateEncodeIntoT, ptr0 *C.Result_EmptySectorUpdateEncodeInto_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfResultEmptySectorUpdateEncodeIntoTValue]C.Result_EmptySectorUpdateEncodeInto_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewResultEmptySectorUpdateEncodeIntoTRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSHashResponseT transforms a sliced Go data structure into plain C format.
func unpackArgSHashResponseT(x []HashResponseT) (unpacked *C.HashResponse_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocHashResponseTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.HashResponse_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.HashResponse_t)(h.Data)
	return
}

// packSHashResponseT reads sliced Go data structure out from plain C format.
func packSHashResponseT(v []HashResponseT, ptr0 *C.HashResponse_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfHashResponseTValue]C.HashResponse_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewHashResponseTRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSAggregateResponseT transforms a sliced Go data structure into plain C format.
func unpackArgSAggregateResponseT(x []AggregateResponseT) (unpacked *C.AggregateResponse_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocAggregateResponseTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.AggregateResponse_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.AggregateResponse_t)(h.Data)
	return
}

// packSAggregateResponseT reads sliced Go data structure out from plain C format.
func packSAggregateResponseT(v []AggregateResponseT, ptr0 *C.AggregateResponse_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfAggregateResponseTValue]C.AggregateResponse_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewAggregateResponseTRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSPrivateKeyGenerateResponseT transforms a sliced Go data structure into plain C format.
func unpackArgSPrivateKeyGenerateResponseT(x []PrivateKeyGenerateResponseT) (unpacked *C.PrivateKeyGenerateResponse_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPrivateKeyGenerateResponseTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.PrivateKeyGenerateResponse_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.PrivateKeyGenerateResponse_t)(h.Data)
	return
}

// packSPrivateKeyGenerateResponseT reads sliced Go data structure out from plain C format.
func packSPrivateKeyGenerateResponseT(v []PrivateKeyGenerateResponseT, ptr0 *C.PrivateKeyGenerateResponse_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPrivateKeyGenerateResponseTValue]C.PrivateKeyGenerateResponse_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPrivateKeyGenerateResponseTRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSPrivateKeySignResponseT transforms a sliced Go data structure into plain C format.
func unpackArgSPrivateKeySignResponseT(x []PrivateKeySignResponseT) (unpacked *C.PrivateKeySignResponse_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPrivateKeySignResponseTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.PrivateKeySignResponse_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.PrivateKeySignResponse_t)(h.Data)
	return
}

// packSPrivateKeySignResponseT reads sliced Go data structure out from plain C format.
func packSPrivateKeySignResponseT(v []PrivateKeySignResponseT, ptr0 *C.PrivateKeySignResponse_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPrivateKeySignResponseTValue]C.PrivateKeySignResponse_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPrivateKeySignResponseTRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSPrivateKeyPublicKeyResponseT transforms a sliced Go data structure into plain C format.
func unpackArgSPrivateKeyPublicKeyResponseT(x []PrivateKeyPublicKeyResponseT) (unpacked *C.PrivateKeyPublicKeyResponse_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPrivateKeyPublicKeyResponseTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.PrivateKeyPublicKeyResponse_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.PrivateKeyPublicKeyResponse_t)(h.Data)
	return
}

// packSPrivateKeyPublicKeyResponseT reads sliced Go data structure out from plain C format.
func packSPrivateKeyPublicKeyResponseT(v []PrivateKeyPublicKeyResponseT, ptr0 *C.PrivateKeyPublicKeyResponse_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPrivateKeyPublicKeyResponseTValue]C.PrivateKeyPublicKeyResponse_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPrivateKeyPublicKeyResponseTRef(unsafe.Pointer(&ptr1))
	}
}
